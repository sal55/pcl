## PCL Intermediate Language

* An IL that is suited as the target of lower level languages such as C and my own 'M' systems language
* Provides a stack-based VM
* Uses the usual machine types `u8-u64 i8-i64 r32-r64`, with all aggregate types represented by a single 'block' type of so many bytes
* Although only little higher level then assembly, PCL is a portable code that hides details of registers, ABIs and calling conventions

There is no textual form of PCL; code is generated via an API. There is no binary file format either. It is expected that PCL code is generated by the front-end (the 'Host') and then immediately processed into its final target.

I decided that a text format, while appearing to be simpler to get going with, was not that practical. In a real project, you'd probably end up creating an API to generate PCL source code anyway.

There are some use-cases for textual IL (for example when the host runs on one machine and the PCL is consumed on other). But that can be added on as another front-end language.

PCL is not a new product, but previous versions were closely integrated into a compiler, and tended to be 64-bit-oriented with most narrow integer values promoted to 64 bits. This new version is more general and exactly the same library can be used for different languages and compilers.

### Availability

This is an experimental project for my own compilers and for a limited range of targets. I'm not really looking at making a tool for general use, for several reasons:

* It's not mature enough
* It doesn't support enough targets (eg. only Win64 right now)
* The native code backends don't generate optimised code
* Everything is buggy
* While the PCL design is reasonably stable, the API is not yet fixed
* There are a number of problems still to sort out, which currently only have workarounds
* It is also aimed at whole-program front-ends (it can be used for independently compiled modules, but then the outputs are limited to ASM/OBJ)

But mainly I'm not interested in that and don't want to get involved in support.

It was just an interesting challenge, plus there was some satisfaction in producing a tiny self-contained library that basically does what LLVM does but of a size and complexity several magnitudes smaller, and up to a couple of magnitudes faster.

It is showing what is possible even working at this scale.

### Structure

````
Front-ends             IR/IL             Back-ends             

M7 Compiler ──>──┐                ┌────> PCL Source
C Compiler  ──>──┼────> PCL ──>───┼────> PCL Interepreter
PCL Parser ───>──┤                ├────> Windows-x64 ─────> EXE/DLL/OBJ/MX/ASM/NASM/RUN
Q Demo ───────>──┤                ├────> (Linux-x64 ──────> NASM/MX/RUN)
C Demo ───────>──┤                ├────> (Linux-ARM64 ────> AT&T-ASM)
(Other) ──────>──┘                ├────> (Z80 8-bit ──────> ZASM)
                                  ├────> (32-bit targets)
                                  └────> (Linear C)
Key:
 PCL Source       API-generated in-memory PCL can be written in a textual format. This can be fed to a PCL parser
 PCL Interpreter  This immediately interpret the PCL code. It is platform-independent
 EXE/DLL/OBJ      Windows' PE-format binaries
 RUN              Runs the generated native code in-memory
 MX               My private binary format
 ASM              x64 assembly in the syntax used by my AA assembler/linker
 NASM             x64 assembly in NASM syntax (NASM runs under Linux too)
 ZASM             My Z80 assembly syntax
````

Elements in parentheses are either experimental or don't exist. However they helped keep the design flexible by having to allow for those possibilities.

Everything else works to some degree. The M7-EXE compiler is almost production ready and can self-host. C-EXE has some issues. M7/C-RUNPCL is still buggy. There are other minor issues with other combinations. There is a lot to test and lots of configurations.

I'm not yet at the point where I can chain several products together, however some combinations like this one do work:
````
c:\cxp>\bx\mm -run cc -runp lua fib.lua
````
(`bx\mm` is the M7 compiler. This translates the C compiler `cc` to PCL then to x64 code which is immediately run. `cc` in turn translates the one-file Lua interpreter `lua.c` to PCL, and immediately executes that by interpreting the PCL. In turn, the Lua interpreter loads and runs `fib.lua`.

The tricky bit is managing all those commandline parameters, as each of these three programs should only see the ones relevant to it, while any belonging to subsequent programs are passed on.)

### Deployment

Each back-end in the chart is intended to be a self-contained library. It is used as follows:

* M7 and C compilers - the build process makes it part of the main compiler (via `import pcl` which adds the two dozen modules needed)
* Q Demo - the PCL library is formed into a separate DLL library
* C Demo - it can either be statically linked (via an OBJ file), or can also use a DLL

Currently the Win64 product includes also the PCL dump routine and the PCL interpreter.

As a DLL, it is single binary of under 200KB, and supports PCL/RUNPCL/EXE/DLL/OBJ/MX/ASM/RUN. (8 different outputs. NASM would be a 9th output, but there can only be one ASM option in a particular build.)

A DLL supporting only RUNPCL (minimal needed to execute PCL code) is about 64KB. Probably this could be reduced as 30KB is the M language's standard library. See Example Session for how the library could be used.

### Source Code

Everything is written in my M systems language. Tests are built with the M6 production compiler and run on Windows. M7 is the new compiler.

For use from Q and C languages, suitable interface files are provided (`pcl.q` and `pcl.h`).

The C demo (`cdemo.c`) needs a binary, either `pcl.obj` or `pcl.dll`, but because these are troublesome to distribute, an ASM version `pcl.asm` is provided, in NASM syntax, which can be assembled locally.

### The PCL API

This is not docoumented yet. The API consists of about 50 functions and a bunch of enumerations; see `pcl.q` or `pcl.h` for a summary. (The M7/C compiler projects don't need any such interface; written in my language, they just do `import pcl` and all exported entities of the library become available, including extras to deal with inline assembly for example.)

The true interface also exports some global variables; these are not needed for the demos, so are not part of those interface files. The API needs to be tidied up so that it only uses functions to control the process.

The library uses global state. There is no context handle returned by `pcl_start` for example. Only one program at a time can be processed, and as written, at most one program can be translated. For use via a DLL, it needs to be capable of translating successive programs, but this is not ready.

### PCL Types and Opcodes

These are listed and documented in [README.md](README.md)

### Adding PCL to the C Compiler

C needs to do independent compilation which would limit what this PCL backend could provide. I decided to make a new, more streamlined C compiler which would work only on a single module. This means it can work like a whole-program compiler and can directly generate EXE or DLL files, or run or intepret the programs. (It also makes compilation twice as fast compared with going through intermediate ASM.)

Multi-module C programs can still be built, but via a driver program (a 200-line script), which invokes PCL per-module and with an ASM target (it then invokes my AA assembler-linker on the results).

Some things were challenging. For example the `argn, argv` arguments of `main`, which don't exist under Windows and needs to be emulated. But does that happen before PCL or after? I moved that mechanism to after PCL; it takes away that headache from the host.

Another thing was supporting var-args, which in my main implementation, assumes the stack grows downwards. In the PCL interpreter however, it grows upwards!

### Interpreting PCL

This wasn't considered seriously first. Why interpret? PCL as it is is quite unsuitable for interpretation: there too many combinations of operands and types, which need to be sorted at runtime. It would translation to a more expansive, more specific set of bytecodes. However I decided to try it anyway. And yes, it was very slow.

But there are some benefits in having a reference implementation that is independent of platform. Debugging becomes easier. Various kinds of survey can be done. If the interpreter at least was ported to another language, that provides one way of getting my M code to run across machines.

There are difficulties however:
* Running interpreted code that calls into external native code requires solving the 'LIBFFI' problem. That has an ugly, awkward solution in that C library. In my language I can solve it trivially, but then porting the code to another language is harder.
* It is not possible to deal with callback functions, where an external function is passed a pointer to a function in your program. Native code can't call a pointer to bytecode!

It does allow very quick development cycles, but those are quick anyway; see below. Anyway, it's cool.

### Run from Source and JIT

This is possible in two ways:

* Compile to PCL then interpret that (but it is slow, and with the limitations mentioned)
* Compile to PCL, translate to native code then the resulting code is run in-memory

The latter takes a tiny bit longer, but with typical programs, that is tens of milliseconds. (Eg. sqlite3.c, some 250Kloc, takes 150ms to turn into PCL, but still only 300ms to turn into x64 code. Most projects of mine are smaller.)

So JIT in the usual sense isn't necessary, as whole-program translation from source to native code is more or less instant anyway (depending on the scale of the program of course).

### Targeting Linux x64, and MX Files

This is probably the next challenge. On the face of it it sounds a minor change to the x64 code generator: a different ABI, but a complicated one. (There may also be problems with passing structs by value: the SYS V ABI may need to now the their internal layout, but PCL flattens them into an untyped sequence of bytes.)

Because I do not support Linux binary file formats, I need to generate NASM-format ASM, and use NASM on Linux to produce object files, then use other Linux tools to create an executable.

There are other options, such as the MX file format. That was a binary format I developed for other reasons, which I no longer need, but it is a simple binary executable format, and it's portable. So I could generate that instead. This format needs a small stub program to load and fix up the MX files before calling their entry point. That program is a 900-line C program, which just needs tweaking to work with `dlopen/dlsym`.

### Generating 'Linear  C'

This is something that was once considered and was experimented with. Each IL instruction translates to a C statement, with the VM stack represented by a set of C local variables.

The trouble is that the C generated is terrible with lots of redundant assignments, so that it *needs* an optimising compiler to clean up the mess.

It is unlikely to be done as one of the reasons for creating PCL was to avoid having to use intermediate C. Probably it is easier to generate structured C from an AST than linear C from an IL.

### The PCL Runtime

The job of a PCL backend is to turn each instruction into inline native code. But sometimes the task is too complex to do inline.

Some ops result in a call to an external library (eg. to do `power r64`, which uses `pow` in `msvcrt.dll`), but sometimes a local function is needed (eg. for `power i64`).

I don't have a general solution for this right now. A workaround used in the M7 compiler is for the backend to request the front end for a reference to a suitable function (eg. `m$power_i64` is part of the M7 compiler's standard library).

Synthesising such code through function calls is not practical (`m$power_i64` is 50 PCL instructions for example). So I might introduce a limited form of textual PCL; those 50 lines are represented by a table of 50 strings, or possibly it will embed a small text file, and a mini parser turns that into internal PCL using the same API the front-end uses.


### Backend Optimisations

The M6 compiler for x64 does two kinds of enhancements to generate code:

* Some locals and parameters can sometimes be kept in registers
* There is a small peephole optimiser that works on generated x64 code

Neither really make applications much faster. Using locals in register can sometimes give impressive results with benchmarks, or where an M-language routine is called from my scripting language. Mainly they just make the code smaller. As it is, the very impressive throughputs of all my language tools are achieved with pretty much unoptimised code.

PCL's x64 backend doesn't yet have even the above enhancements. So neither M7 nor the new C compiler have them (that means code generated by them is a little bit larger too).

They will be added in due course. Generated PCL code can be tided up too. Some is up to the host compiler. There are some reductions that can be done by the PCL API functions (for example combining sequences involving address calculations). But at the moment all that is low priority. I can live without a 10% improvement in speed or size!

### Inline Assembly

This is not directly supported by PCL. With a version involving discrete IL files, it wouldn't be possible at all.

Yet the M7 compiler supports inline assembly. It generates `assem` PCL opcodes, which have a opaque reference to an AST structure in the host which contains more details.

When an `assem` instruction needs to be translated to x64 code, it calls back into the host to deal with it. So there is an untidy leakage of symbols between the host on one side of PCL, and the backend on the other. But it works. The native backend will anyway contain the several hundred reserved words (instructions, registers etc) which the front end needs to be able to parse assembly.

(The PCL interpreter doesn't suport `assem`, so that is another limitation. But neither would a C transpiler.)

### Q Demo

I wanted to try out using PCL from a dynamic language, and via a DLL. The program below synthesises a hello-world program, then selects one of several output options.
````
module pcl

proc main =
    pcl_start("demo")

        dmain:=pc_makesymbol("main", export_id)
        dputs:=pc_makesymbol("puts", import_id)

        pc_defproc(dmain)
            pc_gen(kload, genstring("Hello, World!"))
            pc_setmode(tpu64)

            pc_genxy(kcallp, 1,0, genmemaddr(dputs))

            pc_gen(kload, genint(0))
            pc_setmode(tpi64)

            pc_gen(kstop)
            pc_gen(kretproc)

        pc_endproc()

        pc_addplib("msvcrt")            ! Needed by most targets

    pcl_end()
````
At this point, the generated PCL program exists as global state within the library. Now any one of the following calls can be made. For this test, all but one is commented out:
````
    pcl_writepcl("hello.pcl")           ! Dump as PCL text

    pcl_runpcl()                        ! Run PCL via interpreter

    pcl_writeasm("hello.asm")           ! Generate ASM for my AA assemble
    pcl_writeasm("hello.asm", 'NASM')   ! Generate ASM for NASM (only one of these two will be available)

    pcl_writeexe("hello.exe")           ! Write Windows PE executable

    pcl_setflags(highmem:2)             ! needed if to be linked via gcc or ld
    pcl_writeobj("hello.obj")           ! Write Windows COFF object file

    pcl_writemx("hello.mx")             ! Write my private executable format
 
    pcl_exec(0)                         ! Run native code in-memory
end
````
That `pcl` module is the file `pcl.q`. This is manually written. (The M7 compiler is supposed to write such interface files automatically when creating DLLs, but that needs a lot more work. Besides there was a lot more backend stuff exported that is not needed here.)

BTW is the PCL dump produced by `pcl-writepcl`:
````
 proc main()::
     load      "Hello, World!"    u64
     callp     &puts              --- (1 0)
     load      0                  i64
     stop                         ---
     retproc                      ---
 endproc
 endprog
````
(The `::` indicates an exported function. That `puts` is imported, is only shown in the symbol table, that can be listed separately using `pcl_writepst`.)

### C Demo

The demo was repeated in C; see `cdemo.c`. The matching interface file is `pcl.h`. If someone wants to try this on Windows, they will need the PCL library. I've supplied this as an ASM file in NASM format: `pcl.asm`. It needs the NASM assembler to turn it into a `.obj` file. Build instructions are at the top of the `cdemo.c` file.

Not all outputs work. For example, `pcl_exec()` doesn't work if compiled with gcc; that needs investigating (probably I'm writing memory that gcc puts into a read-only section).

The C API suffers a little because the language doesn't support default argument values.

### The PCL M Library

The library is written in my language as a collection of two dozen modules (for the Win64 version with all outputs bundled). It forms a 'sub-program' which can be included in any M project by writing 'import pcl'.

Here the module scheme works effectively, provided I do want all 24 modules. Configuring a different arrangement involves using a different lead module with a different selection of modules. But currently the internal structure doesn't allow them to be split up so easily. So this is an interesting challenge of the module scheme.

I think however it can cope. The expectation is that with two main targets for example, an M compiler for Windows will include:
````
import pcl_win64
````
and one for Linux will have:
````
import pcl_lin64
````
in their lead modules. (Such modules usually only list the modules/libraries that comprise the project.)

### Example Session

This example shows what might be involved in building `pcl.dll` and using it to run the demos. Everything needed is contained within this folder. There are no dependencies other that what is part of Windows (specifically, msvcrt.dll), and no other languages are involved.

First, these files were copied into this folder:
````
c:\demo>dir
    389,120 mm.exe              M Compiler (this is M7)
    553,472 qq.exe              Q Interpreter
    273,920 cc.exe              C Compiler (production version)
    296,932 pcl.ma              PCL Library sources, as one amalgamated source file with 22 modules
      1,293 qdemo.q             Two files for the Q demo
      5,766 pcl.q
      1,806 cdemo.c             Two files for the C demo
      4,394 pcl.h
````
Now PCL.DLL needs to be created:
````
c:\demo>mm -dll pcl.ma
Compiling pcl.ma to pcl.dll
````
The binary is 188KB fully-loaded, not space-optimised. (M6 would creat a 173KB version.)

Now running those demos:
````
c:\demo>qq qdemo
Hello, World!

c:\demo>cc cdemo pcl.dll
Compiling cdemo.c to cdemo.exe

c:\demo>cdemo
Hello, World!
````
I can use external tools as well, for example I ought to be able to use gcc or tcc to run the C too. But they don't like something about my interpreter loop (which uses a 0.6MB stack frame). If I change it to use the heap,  then those will work too:
````
c:\demo>gcc cdemo.c pcl.dll -o cdemo.exe
c:\demo>cdemo
Hello, World!
````
The pcl.asm file uploaded here includes that revised verson, created like this:
````
c:\bx>mm -nasm pcl
Compiling pcl.m to pcl.asm
c:\bx>copy pcl.asm \demo
````
I can test that in this demo version:
````
c:\demo>nasm -fwin64 pcl.asm
c:\demo>gcc cdemo.c pcl.obj -o cdemo.exe          # this version uses a statically linked library
c:\demo>cdemo
Hello, World!
````
The `pcl.ma` amalgamation was created like this then copied to the demo folder:
````
c:\bx>mm -ma pcl
Writing pcl.ma
````

### Performance

Performance of native code generated with PCL is not going to be great. This is about compilation speed.

A quick survey suggests that a front-end can generate PCL code at some 15M instructions per second. That is, when the starting point is the final AST. (Generally there are 3 PCL ops per source line.)

That part is done by the host, a task that occupies 1800 lines in the C compiler, and the 2800 lines in the M compiler, which is more feature-rich.

Probably it is easier to show an example:
````
c:\bx>mm -time big\fann4
Compiling big\fann4.m to big\fann4.exe
PCL: 2,248,563
Load:            0 ms   0.0 %
Parse:         235 ms  25.3 %
Resolve:        78 ms   8.4 %
Type:           78 ms   8.4 %
PCL:           142 ms  15.3 %              Turn final AST to PCL code (done in host)
MCL:           173 ms  18.6 %              Turn PCL to native code /representation/
SS:            220 ms  23.7 %              Turn that into actual binary code
EXE:             0 ms   0.0 %
-----------------------------
Total:         930 ms 100.0 %
````
This example is for a 740Kloc benchmark, that generates 2.2M PCL instructions. (OS file caching usually means load time is zero. I don't know if finising writing a file, which here is 7.7MB, continues after the compiler terminates.)

