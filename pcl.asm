;NASM VERSION
    default rel
    extern fmod
    extern sin
    extern cos
    extern tan
    extern asin
    extern acos
    extern atan
    extern log
    extern log10
    extern exp
    extern floor
    extern ceil
    extern pow

    global $cmdskip
    global pcstart
    global pccurr
    global pcend
    global strpmode
    global addstr
    global assemused
    global mmpos
    global igetmsourceinfo
    global assemtype
    global pstdnames
    global psize
    global psigned
    global pfloat
    global pmin
    global piwrb
    global pclnames
    global pclhastype
    global pclextra
    global ccnames
    global idnames
    global mclnames
    global mclnopnds
    global mclcodes
    global regnames
    global regcodes
    global dregnames
    global regsizes
    global regindices
    global xmmregnames
    global fregnames
    global mregnames
    global jmpccnames
    global jmpcccodes
    global setccnames
    global setcccodes
    global cmovccnames
    global cmovcccodes
    global segmentnames
    global reftypenames
    global opndnames_ma
    global mlabelno
    global mccode
    global mccodex
    global regmodes
    global phighmem
    global idomcl_assem
    global igethostfn
    global mcxdirnames
    global mcxrelocnames
    global nsymimports
    global nsymexports
    extern __getmainargs
    extern printf
    extern sprintf
    extern strlen
    extern fprintf
    extern memcpy
    extern toupper
    extern strncpy
    extern strcpy
    extern sscanf
    extern puts
    extern free
    extern memset
    extern malloc
    extern realloc
    extern ftell
    extern fseek
    extern fread
    extern fwrite
    extern fopen
    extern fclose
    extern getchar
    extern fgets
    extern tolower
    extern strcat
    extern fgetc
    extern ungetc
    extern strchr
    extern strcmp
    extern strncmp
    extern memcmp
    extern GetStdHandle
    extern SetConsoleCtrlHandler
    extern SetConsoleMode
    extern CreateProcessA
    extern GetLastError
    extern WaitForSingleObject
    extern GetExitCodeProcess
    extern CloseHandle
    extern GetNumberOfConsoleInputEvents
    extern LoadLibraryA
    extern GetProcAddress
    extern LoadCursorA
    extern RegisterClassExA
    extern DefWindowProcA
    extern ReadConsoleInputA
    extern system
    extern Sleep
    extern GetModuleFileNameA
    extern clock
    extern GetTickCount64
    extern GetLocalTime
    extern PeekMessageA
    extern VirtualAlloc
    extern VirtualProtect
    extern FindFirstFileA
    extern FindNextFileA
    extern FindClose
    global pcl_start
    global pc_makesymbol
    global pcl_end
    global pc_gen
    global pcl_writepcl
    global pcl_genmcl
    global pcl_genss
    global pcl_writeasm
    global pcl_writeobj
    global pcl_writedll
    global pcl_writeexe
    global pcl_writemx
    global pcl_exec
    global pcl_setflags
    global pc_genix
    global pc_genx
    global pc_genxy
    global pc_gencond
    global genint
    global genreal
    global genrealimm
    global genstring
    global genpcstrimm
    global genlabel
    global genmem
    global genmemaddr
    global gendata
    global gencomment
    global genname
    global gennameaddr
    global genassem
    global pc_setmode
    global pc_setmode2
    global pc_setxy
    global pc_setscaleoff
    global pc_setoffset
    global pc_addoffset
    global pc_setincr
    global pc_setnargs
    global pc_setnvariadics
    global pc_setalign
    global pc_addplib
    global pc_defproc
    global pc_addparam
    global pc_addlocal
    global pc_endproc
    global pcl_writepst
    global pcl_runpcl
    global mgenint
    global genmc
    global merror
    global mgenreg
    global mgenindex
    global mgenxreg
    global mgenlabel
    global mgenmemaddr
    extern exit

    segment .bss
    alignb    8
msys.fmtparam:
    resb      8
    alignb    8
msys.$cmdskip:
$cmdskip:
    resb      8
    segment .data
    align     8
msys.needgap:
    dq  0
    align     8
msys.outdev:
    dq  1
    align     8
msys.outchan:
    dq  0
    align     8
msys.fmtstr:
    dq  0
    segment .bss
    alignb    8
msys.outchan_stack:
    resb      80
    alignb    8
msys.outdev_stack:
    resb      80
    alignb    8
msys.fmtstr_stack:
    resb      80
msys.needgap_stack:
    resb      10
    alignb    8
msys.ptr_stack:
    resb      80
    segment .data
    align     8
msys.niostack:
    dq  0
msys.digits:
    dq  0x3736353433323130
    dq  0x4645444342413938
;ENDDATA
    align     8
msys.defaultfmt:
    db        0
    db        0
    db        10
    db        0
    db        32
    db        102
    db        0
    db        0
    db        0
    db        82
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    segment .bss
    alignb    8
msys.rd_buffer:
    resb      8
    alignb    8
msys.rd_length:
    resb      8
    alignb    8
msys.rd_pos:
    resb      8
    alignb    8
msys.rd_lastpos:
    resb      8
    alignb    8
msys.termchar:
    resb      8
    alignb    8
msys.itemerror:
    resb      8
msys.printbuffer:
    resb      4096
    alignb    8
msys.printptr:
    resb      8
    alignb    8
msys.printlen:
    resb      8
    alignb    8
msys.nsysparams:
    resb      8
    alignb    8
msys.ncmdparams:
    resb      8
    alignb    8
msys.nenvstrings:
    resb      8
    alignb    8
msys.sysparams:
    resb      1024
    alignb    8
msys.cmdparams:
    resb      8
    alignb    8
msys.envstrings:
    resb      8
    alignb    8
msys.callbackstack:
    resb      576
    segment .data
    align     8
msys.ncallbacks:
    dq  0
    segment .bss
msys.start.startupinfo:
    resb      128
    alignb    8
msys.getfmt.fmt:
    resb      16
msys.strint.str:
    resb      100
msys.strword.str:
    resb      100
msys.strreal.str:
    resb      320
    alignb    8
mlib.allocupper:
    resb      2408
    alignb    8
mlib.alloccode:
    resb      8
    alignb    8
mlib.allocbytes:
    resb      8
    segment .data
    align     8
mlib.fdebug:
    dq  0
    segment .bss
    alignb    8
mlib.rfsize:
    resb      8
    alignb    8
mlib.maxmemory:
    resb      8
    alignb    8
mlib.maxalloccode:
    resb      8
    segment .data
mlib.pcm_setup:
    db        0
    align     8
mlib.show:
    dq  0
    align     8
mlib.memtotal:
    dq  0
    align     8
mlib.smallmemtotal:
    dq  0
    align     8
mlib.smallmemobjs:
    dq  0
    align     8
mlib.maxmemtotal:
    dq  0
    segment .bss
    alignb    8
mlib.memalloctable:
    resb      24
    alignb    4
mlib.memallocsize:
    resb      12
    alignb    8
mlib.pcheapstart:
    resb      8
    alignb    8
mlib.pcheapend:
    resb      8
    alignb    8
mlib.pcheapptr:
    resb      8
mlib.sizeindextable:
    resb      2049
    alignb    8
mlib.freelist:
    resb      72
    segment .data
    align     8
mlib.pmnames:
    dq  L4729
    dq  L4730
    dq  L4731
    dq  L4732
    dq  L4733
    dq  L4734
    align     8
mlib.seed:
    dq  0x2989881111111272
    dq  0x1673267373358264
    segment .bss
    alignb    8
mlib.pcm_newblock.totalheapsize:
    resb      8
    segment .data
    align     4
mlib.pcm_round.allocbytes:
    dd        0
    dd        16
    dd        32
    dd        64
    dd        128
    dd        256
    dd        512
    dd        1024
    dd        2048
    segment .bss
mlib.changeext.newfile:
    resb      260
mlib.extractpath.str:
    resb      260
mlib.extractbasefile.str:
    resb      100
    segment .data
    align     8
mlib.nextcmdparamnew.infile:
    dq  0
    align     8
mlib.nextcmdparamnew.filestart:
    dq  0
    align     8
mlib.nextcmdparamnew.fileptr:
    dq  0
mlib.nextcmdparamnew.colonseen:
    db        0
    segment .bss
mlib.nextcmdparamnew.str:
    resb      300
mlib.readnextfileitem.str:
    resb      256
mlib.padstr.str:
    resb      256
mlib.chr.str:
    resb      8
    alignb    8
mwindows.hconsole:
    resb      8
    alignb    8
mwindows.hconsolein:
    resb      8
    alignb    8
mwindows.lastkey:
    resb      20
    alignb    8
mwindows.pendkey:
    resb      20
    alignb    8
mwindows.keypending:
    resb      8
    segment .data
    align     8
mwindows.wndproc_callbackfn:
    dq  0
    align     8
mwindows.init_flag:
    dq  0
    segment .bss
mwindows.os_gxregisterclass.registered:
    resb      1
    segment .data
    align     8
mwindows.mainwndproc.count:
    dq  0
    segment .bss
mwindows.os_gethostname.name:
    resb      300
    alignb    8
mwindows.os_gethostname.n:
    resb      8
    alignb    8
mwindows.os_peek.lastticks:
    resb      8
    alignb    8
pc_api.pclseqno:
    resb      8
    alignb    8
pc_api.pcstart:
pcstart:
    resb      8
    alignb    8
pc_api.pccurr:
pccurr:
    resb      8
    alignb    8
pc_api.pcend:
pcend:
    resb      8
    alignb    8
pc_api.pcalloc:
    resb      8
pc_api.pcfixed:
    resb      1
    alignb    8
pc_api.pcseqno:
    resb      8
    alignb    8
pc_api.pcneedfntable:
    resb      8
    segment .data
    align     8
pc_api.initpcalloc:
    dq  0x10000
    segment .bss
    alignb    8
pc_api.longstring:
    resb      8
    alignb    8
pc_api.longstringlen:
    resb      8
    alignb    8
pc_api.errormess:
    resb      8
pc_api.strpmode.str:
    resb      32
pc_api.getfullname.str:
    resb      256
pc_api.addstr.str:
    resb      256
    alignb    8
pc_decls.frameoffset:
    resb      8
    alignb    8
pc_decls.paramoffset:
    resb      8
    alignb    8
pc_decls.framebytes:
    resb      8
    alignb    8
pc_decls.usedparams:
    resb      8
    alignb    8
pc_decls.usedxparams:
    resb      8
    alignb    8
pc_decls.highreg:
    resb      8
    alignb    8
pc_decls.highxreg:
    resb      8
    alignb    8
pc_decls.bspill:
    resb      8
    alignb    8
pc_decls.bxspill:
    resb      8
    alignb    8
pc_decls.bxspilloffset:
    resb      8
pc_decls.r10used:
    resb      1
pc_decls.r11used:
    resb      1
pc_decls.r13used:
    resb      1
    alignb    8
pc_decls.maxregvars:
    resb      8
    alignb    8
pc_decls.maxxregvars:
    resb      8
    alignb    8
pc_decls.nproccalls:
    resb      8
    alignb    8
pc_decls.highargs:
    resb      8
pc_decls.localshadow:
    resb      1
pc_decls.assemused:
assemused:
    resb      1
    alignb    8
pc_decls.passno:
    resb      8
    alignb    8
pc_decls.mmlabelno:
    resb      8
    alignb    8
pc_decls.mmpos:
mmpos:
    resb      8
    alignb    8
pc_decls.psymboltable:
    resb      8
    alignb    8
pc_decls.psymboltablex:
    resb      8
    alignb    8
pc_decls.currprog:
    resb      8
    alignb    8
pc_decls.currfunc:
    resb      8
    alignb    8
pc_decls.blockretname:
    resb      8
    alignb    8
pc_decls.entryproc:
    resb      8
    alignb    8
pc_decls.sbuffer:
    resb      16
    segment .data
    align     8
pc_decls.pdest:
    dq  pc_decls.sbuffer
    segment .bss
    alignb    8
pc_decls.plibfiles:
    resb      400
    alignb    8
pc_decls.plibinst:
    resb      400
    alignb    8
pc_decls.nplibfiles:
    resb      8
    alignb    8
pc_decls.igetmsourceinfo:
igetmsourceinfo:
    resb      8
pc_decls.pcldone:
    resb      1
pc_decls.mcldone:
    resb      1
pc_decls.ssdone:
    resb      1
pc_decls.pverbose:
    resb      1
    alignb    8
pc_decls.pcmdskip:
    resb      8
    segment .data
    align     8
pc_decls.assemtype:
assemtype:
    dq  0x4141
    segment .bss
    alignb    8
pc_diags.currlineno:
    resb      8
    alignb    8
pc_diags.currfileno:
    resb      8
    alignb    8
pc_diags.sbuffer:
    resb      16
    segment .data
    align     8
pc_diags.dest:
    dq  pc_diags.sbuffer
    segment .bss
    alignb    8
pc_diags.destlinestart:
    resb      8
pc_diags.stropnd.str:
    resb      512
pc_diags.stropndstack.str:
    resb      512
    segment .data
    align     8
pc_run.dostep:
    dq  0
    segment .bss
    alignb    8
pc_run.go:
    resb      8
    alignb    8
pc_run.labeltable:
    resb      8
    segment .data
    align     8
pc_tables.pstdnames:
pstdnames:
    dq  L4735
    dq  L4736
    dq  L4737
    dq  L4738
    dq  L4739
    dq  L4740
    dq  L4741
    dq  L4742
    dq  L4743
    dq  L4744
    dq  L4745
    dq  L4746
    dq  L4747
    dq  L4748
pc_tables.psize:
psize:
    dq  0x108040201080400
    db        2
    db        4
    db        8
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.psigned:
psigned:
    dq  0x100000000000000
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pfloat:
pfloat:
    dq  0x10100
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pmin:
pmin:
    dq  0x906050505020100
    db        9
    db        9
    db        10
    db        11
    db        12
    db        0
;ENDDATA
pc_tables.piwrb:
piwrb:
    dq  0xA06060606020100
    db        10
    db        10
    db        10
    db        0
    db        0
    db        0
;ENDDATA
    align     8
pc_tables.opndnames:
    dq  L4749
    dq  L4750
    dq  L4751
    dq  L4752
    dq  L4753
    dq  L4754
    dq  L4755
    dq  L4756
    dq  L4757
    dq  L4758
    dq  L4759
    dq  L4760
    dq  L4761
    align     8
pc_tables.pclnames:
pclnames:
    dq  L4762
    dq  L4763
    dq  L4764
    dq  L4765
    dq  L4766
    dq  L4767
    dq  L4768
    dq  L4769
    dq  L4770
    dq  L4771
    dq  L4772
    dq  L4773
    dq  L4774
    dq  L4775
    dq  L4776
    dq  L4777
    dq  L4778
    dq  L4779
    dq  L4780
    dq  L4781
    dq  L4782
    dq  L4783
    dq  L4784
    dq  L4785
    dq  L4786
    dq  L4787
    dq  L4788
    dq  L4789
    dq  L4790
    dq  L4791
    dq  L4792
    dq  L4793
    dq  L4794
    dq  L4795
    dq  L4796
    dq  L4797
    dq  L4798
    dq  L4799
    dq  L4800
    dq  L4801
    dq  L4802
    dq  L4803
    dq  L4804
    dq  L4805
    dq  L4806
    dq  L4807
    dq  L4808
    dq  L4809
    dq  L4810
    dq  L4811
    dq  L4812
    dq  L4813
    dq  L4814
    dq  L4815
    dq  L4816
    dq  L4817
    dq  L4818
    dq  L4819
    dq  L4820
    dq  L4821
    dq  L4822
    dq  L4823
    dq  L4824
    dq  L4825
    dq  L4826
    dq  L4827
    dq  L4828
    dq  L4829
    dq  L4830
    dq  L4831
    dq  L4832
    dq  L4833
    dq  L4834
    dq  L4835
    dq  L4836
    dq  L4837
    dq  L4838
    dq  L4839
    dq  L4840
    dq  L4841
    dq  L4842
    dq  L4843
    dq  L4844
    dq  L4845
    dq  L4846
    dq  L4847
    dq  L4848
    dq  L4849
    dq  L4850
    dq  L4851
    dq  L4852
    dq  L4853
    dq  L4854
    dq  L4855
    dq  L4856
    dq  L4857
    dq  L4858
    dq  L4859
    dq  L4860
    dq  L4861
    dq  L4862
    dq  L4863
    dq  L4864
    dq  L4865
    dq  L4866
    dq  L4867
    dq  L4868
    dq  L4869
    dq  L4870
    dq  L4871
    dq  L4872
    dq  L4873
    dq  L4874
    dq  L4875
    dq  L4876
    dq  L4877
    dq  L4878
    dq  L4879
    dq  L4880
    dq  L4881
    dq  L4882
    dq  L4883
    dq  L4884
    dq  L4885
    dq  L4886
    dq  L4887
    dq  L4888
    dq  L4889
    dq  L4890
    dq  L4891
    dq  L4892
    dq  L4893
    dq  L4894
    dq  L4895
    dq  L4896
    dq  L4897
    dq  L4898
    dq  L4899
    dq  L4900
    dq  L4901
pc_tables.pclhastype:
pclhastype:
    dq  0x1010101010100
    dq  0x101010101010000
    dq  0x1010100000001
    dq  0x1010101010100
    dq  0x1010101
    dq  0x101010101010001
    dq  0x101010101010101
    dq  0x201010101010101
    dq  0x101010101010102
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x202020101010101
    dq  0x1010002020202
    dq  0x101010000
    dq  0x100000000000000
    db        1
    db        1
    db        1
    db        1
;ENDDATA
pc_tables.pclextra:
pclextra:
    dq  0x2000002000000
    dq  0x200
    dq  0x20200020200
    dq  0x100
    dq  0x20200010100
    dq  0x100
    dq  0
    dq  0x10202
    dq  0
    dq  0
    dq  0x101010101000000
    dq  1
    dq  0x101000000000000
    dq  0
    dq  0x1010100000000
    dq  0
    dq  0x10100
    db        0
    db        0
    db        0
    db        0
;ENDDATA
    align     8
pc_tables.ccnames:
ccnames:
    dq  L4902
    dq  L4903
    dq  L4904
    dq  L4905
    dq  L4906
    dq  L4907
    dq  L4908
    align     8
pc_tables.idnames:
idnames:
    dq  L4909
    dq  L4910
    dq  L4911
    dq  L4912
    dq  L4913
    dq  L4914
    dq  L4915
    dq  L4916
    segment .bss
    alignb    8
mc_genmcl.debug:
    resb      8
    alignb    8
mc_genmcl.framebytes:
    resb      8
    alignb    8
mc_genmcl.pxoffset:
    resb      8
    alignb    8
mc_genmcl.px_handlertable:
    resb      1120
    segment .data
mc_genmcl.scondcodes:
    db        4
    db        5
    db        12
    db        14
    db        13
    db        15
;ENDDATA
mc_genmcl.ucondcodes:
    db        4
    db        5
    db        2
    db        6
    db        3
    db        7
;ENDDATA
    segment .bss
    alignb    8
mc_genmcl.ppseqno:
    resb      8
    segment .data
mc_genmcl.inithandlers.initdone:
    db        0
mc_genmcl.inithandlers.dupltable:
    db        "@?"
;ENDDATA
    db        20
    db        17
;ENDDATA
    db        18
    db        17
;ENDDATA
    db        21
    db        17
;ENDDATA
    db        "vu"
;ENDDATA
    db        "xw"
;ENDDATA
    db        "xw"
;ENDDATA
    db        "]."
;ENDDATA
    db        "^/"
;ENDDATA
    segment .bss
mc_genss.rex:
    resb      1
mc_genss.sizeoverride:
    resb      1
mc_genss.addroverride:
    resb      1
mc_genss.f2override:
    resb      1
mc_genss.f3override:
    resb      1
mc_genss.nowmask:
    resb      1
mc_genss.usesizeb:
    resb      1
    alignb    8
mc_genss.extraparam:
    resb      8
    segment .data
    align     8
mc_genss.currseg:
    dq  0
    segment .bss
    alignb    8
mc_genss.currdata:
    resb      8
    alignb    8
mc_genss.currrelocs:
    resb      8
    alignb    8
mc_genss.nrelocs:
    resb      8
    segment .data
    align     8
mc_genss.instrno:
    dq  2
    segment .bss
mc_genss.ishighreg:
    resb      16
    alignb    8
mc_genss.currmcl:
    resb      8
    alignb    8
mc_genss.ripentry:
    resb      8
    segment .data
    align     8
mc_genss.genrm.scaletable:
    dq  0
    dq  1
    dq  0
    dq  2
    dq  0
    dq  0
    dq  0
    dq  3
    segment .bss
    alignb    8
mc_libmcl.mclseqno:
    resb      8
    alignb    8
mc_libmcl.smallinttable:
    resb      96
    alignb    8
mc_libmcl.nametable:
    resb      160
    alignb    8
mc_libmcl.nnametable:
    resb      8
    alignb    8
mc_libmcl.mgenextname.table:
    resb      160
    alignb    8
mc_libmcl.mgenextname.ntable:
    resb      8
    segment .data
    align     8
mc_decls.valtypenames:
    dq  L4917
    dq  L4918
    dq  L4919
    dq  L4920
    dq  L4921
    dq  L4922
    dq  L4923
    dq  L4924
    dq  L4925
    align     8
mc_decls.mclnames:
mclnames:
    dq  L4926
    dq  L4927
    dq  L4928
    dq  L4929
    dq  L4930
    dq  L4931
    dq  L4932
    dq  L4933
    dq  L4934
    dq  L4935
    dq  L4936
    dq  L4937
    dq  L4938
    dq  L4939
    dq  L4940
    dq  L4941
    dq  L4942
    dq  L4943
    dq  L4944
    dq  L4945
    dq  L4946
    dq  L4947
    dq  L4948
    dq  L4949
    dq  L4950
    dq  L4951
    dq  L4952
    dq  L4953
    dq  L4954
    dq  L4955
    dq  L4956
    dq  L4957
    dq  L4958
    dq  L4959
    dq  L4960
    dq  L4961
    dq  L4962
    dq  L4963
    dq  L4964
    dq  L4965
    dq  L4966
    dq  L4967
    dq  L4968
    dq  L4969
    dq  L4970
    dq  L4971
    dq  L4972
    dq  L4973
    dq  L4974
    dq  L4975
    dq  L4976
    dq  L4977
    dq  L4978
    dq  L4979
    dq  L4980
    dq  L4981
    dq  L4982
    dq  L4983
    dq  L4984
    dq  L4985
    dq  L4986
    dq  L4987
    dq  L4988
    dq  L4989
    dq  L4990
    dq  L4991
    dq  L4992
    dq  L4993
    dq  L4994
    dq  L4995
    dq  L4996
    dq  L4997
    dq  L4998
    dq  L4999
    dq  L5000
    dq  L5001
    dq  L5002
    dq  L5003
    dq  L5004
    dq  L5005
    dq  L5006
    dq  L5007
    dq  L5008
    dq  L5009
    dq  L5010
    dq  L5011
    dq  L5012
    dq  L5013
    dq  L5014
    dq  L5015
    dq  L5016
    dq  L5017
    dq  L5018
    dq  L5019
    dq  L5020
    dq  L5021
    dq  L5022
    dq  L5023
    dq  L5024
    dq  L5025
    dq  L5026
    dq  L5027
    dq  L5028
    dq  L5029
    dq  L5030
    dq  L5031
    dq  L5032
    dq  L5033
    dq  L5034
    dq  L5035
    dq  L5036
    dq  L5037
    dq  L5038
    dq  L5039
    dq  L5040
    dq  L5041
    dq  L5042
    dq  L5043
    dq  L5044
    dq  L5045
    dq  L5046
    dq  L5047
    dq  L5048
    dq  L5049
    dq  L5050
    dq  L5051
    dq  L5052
    dq  L5053
    dq  L5054
    dq  L5055
    dq  L5056
    dq  L5057
    dq  L5058
    dq  L5059
    dq  L5060
    dq  L5061
    dq  L5062
    dq  L5063
    dq  L5064
    dq  L5065
    dq  L5066
    dq  L5067
    dq  L5068
    dq  L5069
    dq  L5070
    dq  L5071
    dq  L5072
    dq  L5073
    dq  L5074
    dq  L5075
mc_decls.mclnopnds:
mclnopnds:
    dq  0
    dq  0x202010102010001
    dq  0x10202020202
    dq  0x202020202020101
    dq  0x202010103020101
    dq  0x202020202020202
    dq  0x10101010202
    dq  0x202020202020000
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x101010303020202
    dq  0x10101
    dq  0x200000000000000
    dq  0x1010101020202
    dq  0x1010101010000
    dq  0x101010101
    dq  0x1020000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
mc_decls.mclcodes:
mclcodes:
    dq  0
    dq  0x9000
    dq  0xC9C3E80000000000
    dq  0x30205000000E900
    dq  0x104060700000405
    dq  0x100050704070006
    dq  0x10002030302
    dq  0x51ACA4BDBC000000
    dq  0x5E59595C5C585851
    dq  0xEF5454575700005E
    dq  0xDB
    dq  0x302006263F36600
    dq  0xFAF9C9E9C1030200
    dq  0x5DE0E1F3F2FBFFFE
    dq  0x5F5D5F
    dq  0xD708040201000000
    dq  0xE3E3E2E1E0
    dq  0xEBE8EE0000003100
    db        233
    db        234
    db        236
    db        237
    db        0
    db        244
;ENDDATA
    align     8
mc_decls.regnames:
regnames:
    dq  L5076
    dq  L5077
    dq  L5078
    dq  L5079
    dq  L5080
    dq  L5081
    dq  L5082
    dq  L5083
    dq  L5084
    dq  L5085
    dq  L5086
    dq  L5087
    dq  L5088
    dq  L5089
    dq  L5090
    dq  L5091
    dq  L5092
    dq  L5093
    dq  L5094
    dq  L5095
    dq  L5096
mc_decls.regcodes:
regcodes:
    dq  0xC0603070B0A0000
    dq  0x5090802010F0E0D
    db        4
    db        4
    db        7
    db        5
    db        6
;ENDDATA
    align     8
mc_decls.condnames:
    dq  L5097
    dq  L5098
    dq  L5099
    dq  L5100
    dq  L5101
    dq  L5102
    dq  L5103
    dq  L5104
    dq  L5105
    dq  L5106
    dq  L5107
    dq  L5108
    dq  L5109
    dq  L5110
    dq  L5111
    dq  L5112
    dq  L5113
    dq  L5114
    dq  L5115
    dq  L5116
    align     8
mc_decls.asmcondnames:
    dq  L5117
    dq  L5118
    dq  L5119
    dq  L5120
    dq  L5121
    dq  L5122
    dq  L5123
    dq  L5124
    dq  L5125
    dq  L5126
    dq  L5127
    dq  L5128
    dq  L5129
    dq  L5130
    dq  L5131
    dq  L5132
    dq  L5133
    dq  L5134
    dq  L5135
    dq  L5136
    align     8
mc_decls.asmrevcond:
    dq  1
    dq  0
    dq  3
    dq  2
    dq  5
    dq  4
    dq  7
    dq  6
    dq  9
    dq  8
    dq  0xB
    dq  0xA
    dq  0xD
    dq  0xC
    dq  0xF
    dq  0xE
    dq  0x11
    dq  0x10
    dq  0x13
    dq  0x12
    align     8
mc_decls.dregnames:
dregnames:
    dq  L5137
    dq  L5138
    dq  L5139
    dq  L5140
    dq  L5141
    dq  L5142
    dq  L5143
    dq  L5144
    dq  L5145
    dq  L5146
    dq  L5147
    dq  L5148
    dq  L5149
    dq  L5150
    dq  L5151
    dq  L5152
    dq  L5153
    dq  L5154
    dq  L5155
    dq  L5156
    dq  L5157
    dq  L5158
    dq  L5159
    dq  L5160
    dq  L5161
    dq  L5162
    dq  L5163
    dq  L5164
    dq  L5165
    dq  L5166
    dq  L5167
    dq  L5168
    dq  L5169
    dq  L5170
    dq  L5171
    dq  L5172
    dq  L5173
    dq  L5174
    dq  L5175
    dq  L5176
    dq  L5177
    dq  L5178
    dq  L5179
    dq  L5180
    dq  L5181
    dq  L5182
    dq  L5183
    dq  L5184
    dq  L5185
    dq  L5186
    dq  L5187
    dq  L5188
    dq  L5189
    dq  L5190
    dq  L5191
    dq  L5192
    dq  L5193
    dq  L5194
    dq  L5195
    dq  L5196
    dq  L5197
    dq  L5198
    dq  L5199
    dq  L5200
    dq  L5201
    dq  L5202
    dq  L5203
    dq  L5204
    dq  L5205
    dq  L5206
    dq  L5207
    dq  L5208
    dq  L5209
    dq  L5210
    dq  L5211
    dq  L5212
    dq  L5213
    dq  L5214
    dq  L5215
    dq  L5216
    dq  L5217
    dq  L5218
    dq  L5219
    dq  L5220
    dq  L5221
    dq  L5222
    dq  L5223
    dq  L5224
    dq  L5225
    dq  L5226
    dq  L5227
    dq  L5228
    dq  L5229
    dq  L5230
    dq  L5231
    dq  L5232
    dq  L5233
    dq  L5234
    dq  L5235
    dq  L5236
    dq  L5237
    dq  L5238
    dq  L5239
    dq  L5240
    dq  L5241
    dq  L5242
    dq  L5243
    dq  L5244
    dq  L5245
    dq  L5246
    dq  L5247
    dq  L5248
    dq  L5249
    dq  L5250
    dq  L5251
    dq  L5252
    dq  L5253
    dq  L5254
    dq  L5255
    dq  L5256
    dq  L5257
    dq  L5258
    dq  L5259
    dq  L5260
    dq  L5261
    dq  L5262
    dq  L5263
    dq  L5264
    dq  L5265
    dq  L5266
    dq  L5267
    dq  L5268
    dq  L5269
    dq  L5270
    dq  L5271
    dq  L5272
    dq  L5273
mc_decls.regsizes:
regsizes:
    dq  0x808080808080808
    dq  0x808080808080808
    dq  0x404040404040404
    dq  0x404040404040404
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x808080001010101
    dq  0x808080808080808
    dq  0x404040808080808
    dq  0x404040404040404
    dq  0x202020404040404
    dq  0x202020202020202
    dq  0x101010202020202
    dq  0x101010101010101
    dq  0x101010101010101
    db        1
;ENDDATA
mc_decls.regindices:
regindices:
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0xB05010014131211
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0xF0406141312110C
    dq  0x9080703020E0D10
    db        10
;ENDDATA
    align     8
mc_decls.xmmregnames:
xmmregnames:
    dq  L5274
    dq  L5275
    dq  L5276
    dq  L5277
    dq  L5278
    dq  L5279
    dq  L5280
    dq  L5281
    dq  L5282
    dq  L5283
    dq  L5284
    dq  L5285
    dq  L5286
    dq  L5287
    dq  L5288
    dq  L5289
    align     8
mc_decls.fregnames:
fregnames:
    dq  L5290
    dq  L5291
    dq  L5292
    dq  L5293
    dq  L5294
    dq  L5295
    dq  L5296
    dq  L5297
    align     8
mc_decls.mregnames:
mregnames:
    dq  L5298
    dq  L5299
    dq  L5300
    dq  L5301
    dq  L5302
    dq  L5303
    dq  L5304
    dq  L5305
    align     8
mc_decls.jmpccnames:
jmpccnames:
    dq  L5306
    dq  L5307
    dq  L5308
    dq  L5309
    dq  L5310
    dq  L5311
    dq  L5312
    dq  L5313
    dq  L5314
    dq  L5315
    dq  L5316
    dq  L5317
    dq  L5318
    dq  L5319
    dq  L5320
    dq  L5321
    dq  L5322
    dq  L5323
mc_decls.jmpcccodes:
jmpcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
    db        2
    db        3
;ENDDATA
    align     8
mc_decls.setccnames:
setccnames:
    dq  L5324
    dq  L5325
    dq  L5326
    dq  L5327
    dq  L5328
    dq  L5329
    dq  L5330
    dq  L5331
    dq  L5332
    dq  L5333
    dq  L5334
    dq  L5335
    dq  L5336
    dq  L5337
    dq  L5338
    dq  L5339
mc_decls.setcccodes:
setcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
;ENDDATA
    align     8
mc_decls.cmovccnames:
cmovccnames:
    dq  L5340
    dq  L5341
    dq  L5342
    dq  L5343
    dq  L5344
    dq  L5345
    dq  L5346
    dq  L5347
    dq  L5348
    dq  L5349
    dq  L5350
    dq  L5351
    dq  L5352
    dq  L5353
    dq  L5354
    dq  L5355
mc_decls.cmovcccodes:
cmovcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
;ENDDATA
    align     8
mc_decls.segmentnames:
segmentnames:
    dq  L5356
    dq  L5357
    dq  L5358
    dq  L5359
    dq  L5360
    dq  L5361
    align     8
mc_decls.reftypenames:
reftypenames:
    dq  L5362
    dq  L5363
    dq  L5364
    align     8
mc_decls.opndnames_ma:
opndnames_ma:
    dq  L5365
    dq  L5366
    dq  L5367
    dq  L5368
    dq  L5369
    dq  L5370
    align     8
mc_decls.opndcatnames:
    dq  L5371
    dq  L5372
    dq  L5373
    dq  L5374
    dq  L5375
    dq  L5376
    segment .bss
    alignb    8
mc_decls.mlabelno:
mlabelno:
    resb      8
    alignb    8
mc_decls.pclopnd:
    resb      160
mc_decls.pclreg:
    resb      20
mc_decls.pclmode:
    resb      20
mc_decls.pclcount:
    resb      20
mc_decls.pclloc:
    resb      20
mc_decls.pcltempflags:
    resb      20
    alignb    8
mc_decls.pcltempopnds:
    resb      160
    alignb    8
mc_decls.noperands:
    resb      8
    alignb    8
mc_decls.mstackdepth:
    resb      8
    segment .data
    align     8
mc_decls.locnames:
    dq  L5377
    dq  L5378
    dq  L5379
    segment .bss
mc_decls.workregs:
    resb      16
mc_decls.workxregs:
    resb      16
mc_decls.spillregs:
    resb      16
mc_decls.spillxregs:
    resb      16
mc_decls.regset:
    resb      16
mc_decls.xregset:
    resb      16
mc_decls.isregvar:
    resb      16
mc_decls.isxregvar:
    resb      16
mc_decls.noxorclear:
    resb      1
    segment .data
    align     8
mc_decls.xregnames:
    dq  L5380
    dq  L5381
    dq  L5382
    dq  L5383
    dq  L5384
    dq  L5385
    dq  L5386
    dq  L5387
    dq  L5388
    dq  L5389
    dq  L5390
    dq  L5391
    dq  L5392
    dq  L5393
    dq  L5394
    dq  L5395
    dq  L5396
    segment .bss
mc_decls.callalign:
    resb      16
mc_decls.callblockret:
    resb      16
    alignb    4
mc_decls.callblocksize:
    resb      64
    alignb    4
mc_decls.callargsize:
    resb      256
    alignb    8
mc_decls.ncalldepth:
    resb      8
    alignb    8
mc_decls.lababs32:
    resb      8
    alignb    8
mc_decls.lababs64:
    resb      8
    alignb    8
mc_decls.labneg32:
    resb      8
    alignb    8
mc_decls.labneg64:
    resb      8
    alignb    8
mc_decls.labmask63:
    resb      8
    alignb    8
mc_decls.laboffset64:
    resb      8
    alignb    8
mc_decls.labzero:
    resb      8
    segment .data
    align     8
mc_decls.kk0used:
    dq  0
    segment .bss
    alignb    8
mc_decls.mccode:
mccode:
    resb      8
    alignb    8
mc_decls.mccodex:
mccodex:
    resb      8
    segment .data
    align     8
mc_decls.currsegment:
    dq  0
    segment .bss
    alignb    8
mc_decls.dstackopnd:
    resb      8
    alignb    8
mc_decls.dframeopnd:
    resb      8
    alignb    8
mc_decls.regtable:
    resb      1024
    alignb    8
mc_decls.frameregtable:
    resb      1544
    alignb    8
mc_decls.cstringlist:
    resb      8
    alignb    8
mc_decls.vstringlist:
    resb      8
    alignb    8
mc_decls.creallist:
    resb      8
    alignb    8
mc_decls.creal32list:
    resb      8
    alignb    8
mc_decls.currasmproc:
    resb      8
    alignb    8
mc_decls.lab_funcnametable:
    resb      8
    alignb    8
mc_decls.lab_funcaddrtable:
    resb      8
    alignb    8
mc_decls.lab_funcnprocs:
    resb      8
    alignb    8
mc_decls.ss_zdatalen:
    resb      8
    alignb    8
mc_decls.ss_zdata:
    resb      8
    alignb    8
mc_decls.ss_idata:
    resb      8
    alignb    8
mc_decls.ss_code:
    resb      8
    alignb    8
mc_decls.ss_idatarelocs:
    resb      8
    alignb    8
mc_decls.ss_coderelocs:
    resb      8
    alignb    8
mc_decls.ss_nidatarelocs:
    resb      8
    alignb    8
mc_decls.ss_ncoderelocs:
    resb      8
    alignb    8
mc_decls.ss_symboltable:
    resb      8
    alignb    8
mc_decls.ss_nsymbols:
    resb      8
    alignb    8
mc_decls.ss_symboltablesize:
    resb      8
    alignb    8
mc_decls.labeldeftable:
    resb      8
    alignb    8
mc_decls.aaseqno:
    resb      8
    segment .data
mc_decls.regmodes:
regmodes:
    dq  0x600000005000403
;ENDDATA
    segment .bss
mc_decls.pmode:
    resb      1
    alignb    8
mc_decls.currpcl:
    resb      8
    alignb    8
mc_decls.mclprocentry:
    resb      8
    alignb    8
mc_decls.mce_oldmccodex:
    resb      8
    alignb    8
mc_decls.mce_nextmcl:
    resb      8
mc_decls.fppeephole:
    resb      1
mc_decls.fpregoptim:
    resb      1
mc_decls.fpshortnames:
    resb      1
mc_decls.fpcheckunusedlocals:
    resb      1
mc_decls.phighmem:
phighmem:
    resb      1
    alignb    8
mc_decls.riplist:
    resb      8
    alignb    8
mc_decls.idomcl_assem:
idomcl_assem:
    resb      8
    alignb    8
mc_decls.igethostfn:
igethostfn:
    resb      8
    alignb    8
mc_decls.blockdefs:
    resb      400
    alignb    8
mc_decls.nblocktemps:
    resb      8
    segment .data
    align     8
mc_decls.multregs:
    dq  1
    dq  2
    dq  3
    dq  0xB
    dq  0xC
    dq  0xD
    align     8
mc_decls.multxregs:
    dq  1
    dq  2
    dq  3
    dq  4
    dq  5
    dq  6
    segment .bss
mc_decls.ploadopx:
    resb      14
mc_decls.ploadop:
    resb      14
    segment .data
    align     8
mc_objdecls.relocnames:
    dq  L5397
    dq  L5398
    dq  L5399
    dq  L5400
    dq  L5401
    dq  L5402
    dq  L5403
    segment .bss
    alignb    8
mc_writenasm.nregnames:
    resb      1024
mc_writenasm.currseg:
    resb      1
mc_writenasm.strmcl.str:
    resb      512
mc_writenasm.mstropnd.str:
    resb      512
mc_writenasm.strvalue.str:
    resb      512
    segment .data
    align     8
mc_writenasm.getregname.prefix:
    dq  L5404
    dq  L5405
    dq  L5406
    dq  L5407
    dq  L5408
    dq  L5408
    dq  L5408
    dq  L5409
    dq  L5410
    dq  L5410
    dq  L5410
    dq  L5410
    dq  L5410
    dq  L5410
    dq  L5410
    dq  L5411
    dq  L5412
    segment .bss
mc_writenasm.getregname.str:
    resb      32
mc_writenasm.getxregname.str:
    resb      32
mc_writenasm.getdispname.str:
    resb      256
mc_writenasm.gettempname.str:
    resb      128
    alignb    8
mc_writeexe.libinsttable:
    resb      400
    alignb    8
mc_writeexe.libinstnames:
    resb      400
    alignb    8
mc_writeexe.libnotable:
    resb      400
    alignb    8
mc_writeexe.basereloclist:
    resb      8
    alignb    8
mc_writeexe.nbaserelocs:
    resb      8
    alignb    8
mc_writeexe.maxrelocaddr:
    resb      8
    alignb    8
mc_writeexe.blockbases:
    resb      4000
    alignb    4
mc_writeexe.blockcounts:
    resb      2000
    alignb    4
mc_writeexe.blockbytes:
    resb      2000
mc_writeexe.blockpadding:
    resb      500
    alignb    8
mc_writeexe.nbaseblocks:
    resb      8
    alignb    8
mc_writeexe.basetablesize:
    resb      8
    alignb    8
mc_writeexe.imagebase:
    resb      8
    alignb    8
mc_writeexe.imagesize:
    resb      8
    alignb    8
mc_writeexe.filesize:
    resb      8
    alignb    8
mc_writeexe.thunktable:
    resb      8
    alignb    8
mc_writeexe.fileiatoffset:
    resb      8
    alignb    8
mc_writeexe.fileiatsize:
    resb      8
    alignb    8
mc_writeexe.stentrypoint:
    resb      8
    alignb    8
mc_writeexe.stentrypoint2:
    resb      8
    alignb    8
mc_writeexe.stentrypoint3:
    resb      8
    alignb    8
mc_writeexe.sectiontable:
    resb      720
    alignb    8
mc_writeexe.nsections:
    resb      8
    alignb    8
mc_writeexe.importdir:
    resb      8
    alignb    8
mc_writeexe.importtable:
    resb      144048
    alignb    8
mc_writeexe.nimports:
    resb      8
    alignb    8
mc_writeexe.exporttable:
    resb      16000
    alignb    8
mc_writeexe.nexports:
    resb      8
    alignb    8
mc_writeexe.dllfilename:
    resb      8
    alignb    8
mc_writeexe.isdll:
    resb      8
    alignb    8
mc_writeexe.dlltable:
    resb      2400
    alignb    8
mc_writeexe.ndlls:
    resb      8
    alignb    8
mc_writeexe.datastart:
    resb      8
    alignb    8
mc_writeexe.dataptr:
    resb      8
    alignb    8
mc_writeexe.userentrypoint:
    resb      8
    alignb    8
mc_writeexe.exportdirvirtaddr:
    resb      8
    alignb    8
mc_writeexe.exportdirvirtsize:
    resb      8
    alignb    8
mc_writeexe.exportdiroffset:
    resb      8
    alignb    8
mc_writeexe.blockdirvirtaddr:
    resb      8
    alignb    8
mc_writeexe.blockdirvirtsize:
    resb      8
    alignb    8
mc_writeexe.blockdiroffset:
    resb      8
    segment .data
mc_writeexe.writedosstub.stubdata:
    dq  0x300905A4D
    dq  0xFFFF00000004
    dq  0xB8
    dq  0x40
    dq  0
    dq  0
    dq  0
    dq  0x8000000000
    dq  0xCD09B4000EBA1F0E
    dq  0x685421CD4C01B821
    dq  0x72676F7270207369
    dq  0x6F6E6E6163206D61
    dq  0x6E75722065622074
    dq  0x20534F44206E6920
    dq  0xA0D0D2E65646F6D
    dq  0x24
;ENDDATA
    segment .bss
    alignb    8
mc_writeobj.symtaboffset:
    resb      8
    alignb    8
mc_writeobj.datastart:
    resb      8
    alignb    8
mc_writeobj.dataptr:
    resb      8
    alignb    8
mc_writeobj.symboltable:
    resb      234018
    alignb    8
mc_writeobj.nsymbols:
    resb      8
    segment .data
    align     8
mc_writeobj.stoffset:
    dq  0
    segment .bss
    alignb    8
mc_writeobj.stringtable:
    resb      40000
    alignb    8
mc_writeobj.stringlengths:
    resb      40000
    segment .data
    align     8
mc_writeobj.nextstringoffset:
    dq  0
    align     8
mc_writeobj.nstrings:
    dq  0
    segment .bss
    alignb    8
mc_writeobj.writerelocs.s:
    resb      10
    alignb    8
mc_writeobj.makesymbol.r:
    resb      18
    alignb    8
mc_writeobj.strtoaux.r:
    resb      18
    alignb    8
mc_writeobj.sectiontoaux.r:
    resb      18
mc_writeobj.getqualname.str:
    resb      256
    segment .data
    align     8
mx_decls.mcxdirnames:
mcxdirnames:
    dq  L5413
    dq  L5414
    dq  L5415
    dq  L5416
    dq  L5417
    dq  L5418
    dq  L5419
    dq  L5420
    dq  L5421
    dq  L5422
    dq  L5423
    dq  L5424
    dq  L5425
    dq  L5426
    align     8
mx_decls.mcxrelocnames:
mcxrelocnames:
    dq  L5427
    dq  L5428
    dq  L5429
    dq  L5430
    dq  L5431
    dq  L5432
    segment .bss
    alignb    8
mx_decls.dllnametable:
    resb      160
    alignb    8
mx_decls.dllinsttable:
    resb      160
    alignb    8
mx_decls.ndlllibs:
    resb      8
    alignb    8
mx_decls.libnametable:
    resb      160
    alignb    8
mx_decls.libtable:
    resb      160
mx_decls.librelocated:
    resb      20
mx_decls.libinitdone:
    resb      20
    alignb    8
mx_decls.nlibs:
    resb      8
    alignb    8
mx_decls.symbolnametable:
    resb      24000
mx_decls.symboldefined:
    resb      3000
    alignb    8
mx_decls.symboladdress:
    resb      24000
    alignb    2
mx_decls.symbollibindex:
    resb      6000
mx_decls.symboldllindex:
    resb      3000
    alignb    8
mx_decls.nsymbols:
    resb      8
    segment .data
    align     8
mx_decls.nsymimports:
nsymimports:
    dq  0
    align     8
mx_decls.nsymexports:
nsymexports:
    dq  0
    align     8
mx_lib.rsegmentnames:
    dq  L5433
    dq  L5434
    dq  L5435
    dq  L5436
    dq  L5437
    dq  L5438
    segment .bss
    alignb    8
mx_write.dest:
    resb      8
    alignb    8
mx_write.entrypoint:
    resb      8
    segment .text
;Proc start
msys.start:
;>>
    %define msys.start.nargs -8
    %define msys.start.nargs64 -16
    %define msys.start.args -24
    %define msys.start.res -32
    %define msys.start.j -40
    %define msys.start.i -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    sub       rsp,	8
    lea       rax,	[msys.start.startupinfo]
    push      rax
    lea       rcx,	[rbp + msys.start.nargs]
    lea       rdx,	[rbp + msys.start.args]
    lea       r8,	[msys.envstrings]
    xor       r9d,	r9d
    sub       rsp,	32
    call      __getmainargs
    add       rsp,	48
    movsxd    rax,	eax
    mov       [rbp + msys.start.res],	rax
    movsxd    rax,	dword [rbp + msys.start.nargs]
    mov       [msys.nsysparams],	rax
    mov       rax,	[msys.nsysparams]
    cmp       rax,	128
    jle       L3
    lea       rcx,	[rel L5439]
    call      printf
    mov       rcx,	50
    call      exit
L3:
L2:
    movsxd    rax,	dword [rbp + msys.start.nargs]
    mov       [rbp + msys.start.nargs64],	rax
    mov       rax,	1
    mov       [rbp + msys.start.i],	rax
    mov       rax,	[rbp + msys.start.nargs64]
    cmp       rax,	1
    jl        L6
L4:
    mov       rax,	[rbp + msys.start.args]
    mov       r10,	[rbp + msys.start.i]
    mov       r11,	[rax + r10*8-8]
    lea       rax,	[msys.sysparams]
    mov       r10,	[rbp + msys.start.i]
    mov       [rax + r10*8-8],	r11
L5:
    mov       rax,	[rbp + msys.start.i]
    inc       rax
    mov       [rbp + msys.start.i],	rax
    cmp       rax,	[rbp + msys.start.nargs64]
    jle       L4
L6:
    mov       rax,	[msys.$cmdskip]
    add       rax,	1
    mov       r10,	[msys.nsysparams]
    sub       r10,	rax
    mov       [msys.ncmdparams],	r10
    lea       rax,	[msys.sysparams]
    mov       r10,	[msys.$cmdskip]
    lea       rax,	[rax + r10*8]
    mov       [msys.cmdparams],	rax
    mov       rax,	1
    mov       [rbp + msys.start.j],	rax
    xor       eax,	eax
    mov       [msys.nenvstrings],	rax
    jmp       L8
L7:
    inc       qword [msys.nenvstrings]
    inc       qword [rbp + msys.start.j]
L8:
    mov       rax,	[msys.envstrings]
    mov       r10,	[rbp + msys.start.j]
    mov       r11,	[rax + r10*8-8]
    test      r11,	r11
    jnz       L7
L9:
L1:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc pushio
msys.pushio:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[msys.niostack]
    cmp       rax,	10
    jl        L12
    lea       rcx,	[rel L5440]
    call      printf
    mov       rcx,	53
    call      exit
L12:
L11:
    inc       qword [msys.niostack]
    mov       rax,	[msys.outchan]
    lea       r10,	[msys.outchan_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[msys.outdev]
    lea       r10,	[msys.outdev_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[msys.fmtstr]
    lea       r10,	[msys.fmtstr_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[msys.needgap]
    lea       r10,	[msys.needgap_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    mov       [msys.needgap],	rax
    xor       eax,	eax
    mov       [msys.fmtstr],	rax
    xor       eax,	eax
    mov       [msys.outchan],	rax
L10:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_startfile
msys.m$print_startfile:
;>>
    %define msys.m$print_startfile.dev 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      msys.pushio
    mov       rax,	[rbp + msys.m$print_startfile.dev]
    mov       [msys.outchan],	rax
    mov       rax,	[rbp + msys.m$print_startfile.dev]
    test      rax,	rax
    jz        L15
    mov       rax,	2
    mov       [msys.outdev],	rax
    jmp       L14
L15:
    mov       rax,	1
    mov       [msys.outdev],	rax
L14:
    call      msys.resetprintbuffer
L13:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_startstr
msys.m$print_startstr:
;>>
    %define msys.m$print_startstr.s 16
    %define msys.m$print_startstr.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      msys.pushio
    mov       rax,	[rbp + msys.m$print_startstr.s]
    lea       r10,	[msys.ptr_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[msys.ptr_stack]
    mov       r10,	[msys.niostack]
    lea       rax,	[rax + r10*8-8]
    mov       [rbp + msys.m$print_startstr.p],	rax
    mov       rax,	[rbp + msys.m$print_startstr.p]
    mov       [msys.outchan],	rax
    mov       rax,	3
    mov       [msys.outdev],	rax
L16:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc m$print_startptr
msys.m$print_startptr:
;>>
    %define msys.m$print_startptr.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      msys.pushio
    mov       rax,	[rbp + msys.m$print_startptr.p]
    mov       [msys.outchan],	rax
    mov       rax,	3
    mov       [msys.outdev],	rax
L17:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_startcon
msys.m$print_startcon:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      msys.pushio
    mov       rax,	1
    mov       [msys.outdev],	rax
    call      msys.resetprintbuffer
L18:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_setfmt
msys.m$print_setfmt:
;>>
    %define msys.m$print_setfmt.format 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + msys.m$print_setfmt.format]
    mov       [msys.fmtstr],	rax
L19:
;---------------
    pop       rbp
    ret       
;End 
;Proc m$print_end
msys.m$print_end:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    mov       rax,	[msys.niostack]
    cmp       rax,	1
    jnz       L22
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jz        L23
    cmp       rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
L21:
    mov       rax,	[msys.niostack]
    cmp       rax,	0
    jnz       L25
    jmp       L20
L25:
L24:
    lea       rax,	[msys.outchan_stack]
    mov       r10,	[msys.niostack]
    mov       r11,	[rax + r10*8-8]
    mov       [msys.outchan],	r11
    lea       rax,	[msys.outdev_stack]
    mov       r10,	[msys.niostack]
    mov       r11,	[rax + r10*8-8]
    mov       [msys.outdev],	r11
    lea       rax,	[msys.fmtstr_stack]
    mov       r10,	[msys.niostack]
    mov       r11,	[rax + r10*8-8]
    mov       [msys.fmtstr],	r11
    lea       rax,	[msys.needgap_stack]
    mov       r10,	[msys.niostack]
    movzx     r11,	byte [rax + r10-1]
    mov       [msys.needgap],	r11
    dec       qword [msys.niostack]
L20:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_ptr
msys.m$print_ptr:
;>>
    %define msys.m$print_ptr.a 16
    %define msys.m$print_ptr.fmtstyle 24
    %define msys.m$print_ptr.s -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + msys.m$print_ptr.fmtstyle]
    cmp       rax,	0
    jnz       L28
    lea       rax,	[rel L5441]
    mov       [rbp + msys.m$print_ptr.fmtstyle],	rax
L28:
L27:
    mov       rcx,	[rbp + msys.m$print_ptr.a]
    mov       rdx,	[rbp + msys.m$print_ptr.fmtstyle]
    call      msys.m$print_u64
L26:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc m$print_ptr_nf
msys.m$print_ptr_nf:
;>>
    %define msys.m$print_ptr_nf.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + msys.m$print_ptr_nf.a]
    xor       edx,	edx
    call      msys.m$print_ptr
L29:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_i64
msys.m$print_i64:
;>>
    %define msys.m$print_i64.a 16
    %define msys.m$print_i64.fmtstyle 24
    %define msys.m$print_i64.s -40
    %define msys.m$print_i64.fmt -56
    %define msys.m$print_i64.n -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_i64.fmtstyle]
    cmp       rax,	0
    jnz       L32
    mov       rax,	[rbp + msys.m$print_i64.a]
    cmp       rax,	0
    jl        L34
    mov       rcx,	[rbp + msys.m$print_i64.a]
    lea       rdx,	[rbp + msys.m$print_i64.s]
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    mov       [rbp + msys.m$print_i64.n],	rax
    jmp       L33
L34:
    mov       rax,	[rbp + msys.m$print_i64.a]
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L35
    lea       rax,	[msys.defaultfmt]
    lea       r10,	[rbp + msys.m$print_i64.fmt]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    jmp       L36
L35:
    mov       al,	45
    mov       [rbp + msys.m$print_i64.s],	al
    lea       rax,	[rbp + msys.m$print_i64.s+1]
    mov       r10,	[rbp + msys.m$print_i64.a]
    neg       r10
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    add       rax,	1
    mov       [rbp + msys.m$print_i64.n],	rax
L33:
    lea       rcx,	[rbp + msys.m$print_i64.s]
    mov       rdx,	[rbp + msys.m$print_i64.n]
    call      msys.printstr_n
    jmp       L31
L32:
    mov       rcx,	[rbp + msys.m$print_i64.fmtstyle]
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     rax,	byte [rbp + msys.m$print_i64.fmt+14]
    cmp       rax,	86
    jnz       L38
    mov       rax,	[rbp + msys.m$print_i64.a]
    mov       [msys.fmtparam],	rax
    xor       eax,	eax
    mov       [msys.needgap],	rax
    jmp       L37
L38:
;dofmt:
L36:
    mov       rcx,	[rbp + msys.m$print_i64.a]
    lea       rdx,	[rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       rax,	1
    mov       [msys.needgap],	rax
L30:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc m$print_i64_nf
msys.m$print_i64_nf:
;>>
    %define msys.m$print_i64_nf.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + msys.m$print_i64_nf.a]
    xor       edx,	edx
    call      msys.m$print_i64
L39:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_bool
msys.m$print_bool:
;>>
    %define msys.m$print_bool.a 16
    %define msys.m$print_bool.fmtstyle 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + msys.m$print_bool.a]
    test      rax,	rax
    jz        L42
    lea       rcx,	[rel L5442]
    mov       rdx,	[rbp + msys.m$print_bool.fmtstyle]
    call      msys.m$print_str
    jmp       L41
L42:
    lea       rcx,	[rel L5443]
    mov       rdx,	[rbp + msys.m$print_bool.fmtstyle]
    call      msys.m$print_str
L41:
L40:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_u64
msys.m$print_u64:
;>>
    %define msys.m$print_u64.a 16
    %define msys.m$print_u64.fmtstyle 24
    %define msys.m$print_u64.s -40
    %define msys.m$print_u64.fmt -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_u64.fmtstyle]
    cmp       rax,	0
    jnz       L45
    lea       rcx,	[rbp + msys.m$print_u64.s]
    lea       rdx,	[rel L5444]
    mov       r8,	[rbp + msys.m$print_u64.a]
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       rcx,	[rbp + msys.m$print_u64.fmtstyle]
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       rcx,	[rbp + msys.m$print_u64.a]
    lea       rdx,	[rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       rax,	1
    mov       [msys.needgap],	rax
L43:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc m$print_r64
msys.m$print_r64:
;>>
    %define msys.m$print_r64.x 16
    %define msys.m$print_r64.fmtstyle 24
    %define msys.m$print_r64.s -360
    %define msys.m$print_r64.fmt -376
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	416
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_r64.fmtstyle]
    cmp       rax,	0
    jnz       L48
    lea       rcx,	[rbp + msys.m$print_r64.s]
    lea       rdx,	[rel L5445]
    movq      XMM2,	[rbp + msys.m$print_r64.x]
    movq      r8,	XMM2
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       rcx,	[rbp + msys.m$print_r64.fmtstyle]
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      XMM0,	[rbp + msys.m$print_r64.x]
    lea       rdx,	[rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       rax,	1
    mov       [msys.needgap],	rax
L46:
;---------------
    add       rsp,	416
    pop       rbp
    ret       
;End 
;Proc m$print_r32
msys.m$print_r32:
;>>
    %define msys.m$print_r32.x 16
    %define msys.m$print_r32.fmtstyle 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    movd      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    movd      XMM4,	[rbp + msys.m$print_r32.x]
    cvtss2sd  XMM4,	XMM4
    movq      XMM0,	XMM4
    mov       rdx,	[rbp + msys.m$print_r32.fmtstyle]
    call      msys.m$print_r64
L49:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_c8
msys.m$print_c8:
;>>
    %define msys.m$print_c8.a 16
    %define msys.m$print_c8.fmtstyle 24
    %define msys.m$print_c8.s -16
    %define msys.m$print_c8.fmt -32
    %define msys.m$print_c8.n -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_c8.a]
    mov       [rbp + msys.m$print_c8.s],	rax
    xor       eax,	eax
    mov       [rbp + msys.m$print_c8.s+8],	al
    lea       rcx,	[rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       [rbp + msys.m$print_c8.n],	rax
    lea       rcx,	[rbp + msys.m$print_c8.s]
    mov       rdx,	[rbp + msys.m$print_c8.n]
    call      msys.printstr_n
    mov       rax,	1
    mov       [msys.needgap],	rax
L50:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc m$print_str
msys.m$print_str:
;>>
    %define msys.m$print_str.s 16
    %define msys.m$print_str.fmtstyle 24
    %define msys.m$print_str.fmt -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_str.s]
    cmp       rax,	0
    jnz       L53
    lea       rcx,	[rel L5446]
    call      msys.printstr
    jmp       L51
L53:
L52:
    mov       rax,	[rbp + msys.m$print_str.fmtstyle]
    cmp       rax,	0
    jnz       L55
    mov       rcx,	[rbp + msys.m$print_str.s]
    call      msys.printstr
    jmp       L54
L55:
    mov       rcx,	[rbp + msys.m$print_str.fmtstyle]
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       rcx,	[rbp + msys.m$print_str.s]
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L54:
    mov       rax,	1
    mov       [msys.needgap],	rax
L51:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc m$print_strn
msys.m$print_strn:
;>>
    %define msys.m$print_strn.s 16
    %define msys.m$print_strn.length 24
    %define msys.m$print_strn.fmtstyle 32
    %define msys.m$print_strn.fmt -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_strn.s]
    cmp       rax,	0
    jnz       L58
    lea       rcx,	[rel L5446]
    call      msys.printstr
    jmp       L56
L58:
L57:
    mov       rax,	[rbp + msys.m$print_strn.fmtstyle]
    cmp       rax,	0
    jnz       L60
    mov       rcx,	[rbp + msys.m$print_strn.s]
    mov       rdx,	[rbp + msys.m$print_strn.length]
    call      msys.printstr_n
    jmp       L59
L60:
    mov       rcx,	[rbp + msys.m$print_strn.fmtstyle]
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       rcx,	[rbp + msys.m$print_strn.s]
    mov       rdx,	[rbp + msys.m$print_strn.length]
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L59:
    mov       rax,	1
    mov       [msys.needgap],	rax
L56:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc m$print_str_nf
msys.m$print_str_nf:
;>>
    %define msys.m$print_str_nf.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + msys.m$print_str_nf.s]
    xor       edx,	edx
    call      msys.m$print_str
L61:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_strsl
msys.m$print_strsl:
;>>
    %define msys.m$print_strsl.s 16
    %define msys.m$print_strsl.fmtstyle 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    mov       rax,	[rbp + msys.m$print_strsl.fmtstyle]
    cmp       rax,	0
    jnz       L64
    mov       rax,	[rbp + msys.m$print_strsl.s]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + msys.m$print_strsl.s]
    mov       r11,	[rax]
    mov       rcx,	r11
    mov       rdx,	r10
    call      msys.printstr_n
    jmp       L63
L64:
    lea       rcx,	[rel L5447]
    call      mlib.abortprogram
L63:
    mov       rax,	1
    mov       [msys.needgap],	rax
L62:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_newline
msys.m$print_newline:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    lea       rcx,	[rel L5448]
    call      msys.printstr
L65:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$print_nogap
msys.m$print_nogap:
;>>
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
L66:
;---------------
    ret       
;End 
;Proc m$print_space
msys.m$print_space:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    lea       rcx,	[rel L5449]
    call      msys.printstr
L67:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc printstr
msys.printstr:
;>>
    %define msys.printstr.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + msys.printstr.s]
    call      strlen
    mov       rcx,	[rbp + msys.printstr.s]
    mov       rdx,	rax
    call      msys.printstr_n
L68:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc printstr_n
msys.printstr_n:
;>>
    %define msys.printstr_n.s 16
    %define msys.printstr_n.n 24
    %define msys.printstr_n.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + msys.printstr_n.s]
    mov       rdx,	[rbp + msys.printstr_n.n]
    xor       r8d,	r8d
    call      msys.dumpstr
L69:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc printstrn_app
msys.printstrn_app:
;>>
    %define msys.printstrn_app.s 16
    %define msys.printstrn_app.length 24
    %define msys.printstrn_app.f 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + msys.printstrn_app.length]
    test      rax,	rax
    jz        L72
    mov       rax,	[rbp + msys.printstrn_app.f]
    cmp       rax,	0
    jnz       L74
    lea       rcx,	[rel L5450]
    mov       rdx,	[rbp + msys.printstrn_app.length]
    mov       r8,	[rbp + msys.printstrn_app.s]
    call      printf
    jmp       L73
L74:
    mov       rcx,	[rbp + msys.printstrn_app.f]
    lea       rdx,	[rel L5450]
    mov       r8,	[rbp + msys.printstrn_app.length]
    mov       r9,	[rbp + msys.printstrn_app.s]
    call      fprintf
L73:
L72:
L71:
L70:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc printchar
msys.printchar:
;>>
    %define msys.printchar.ch 16
    %define msys.printchar.str -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       al,	[rbp + msys.printchar.ch]
    mov       [rbp + msys.printchar.str],	al
    xor       eax,	eax
    mov       [rbp + msys.printchar.str+1],	al
    lea       rcx,	[rbp + msys.printchar.str]
    mov       rdx,	1
    call      msys.printstr_n
L75:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc nextfmtchars
msys.nextfmtchars:
;>>
    %define msys.nextfmtchars.lastx 16
    %define msys.nextfmtchars.c -8
    %define msys.nextfmtchars.pstart -16
    %define msys.nextfmtchars.n -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[msys.fmtstr]
    test      rax,	rax
    jnz       L78
    mov       rax,	[msys.needgap]
    test      rax,	rax
    jz        L80
    mov       rcx,	32
    call      msys.printchar
L80:
L79:
    xor       eax,	eax
    mov       [msys.needgap],	rax
    jmp       L76
L78:
L77:
    mov       rax,	[msys.fmtstr]
    mov       [rbp + msys.nextfmtchars.pstart],	rax
    xor       eax,	eax
    mov       [rbp + msys.nextfmtchars.n],	rax
L81:
    mov       rax,	[msys.fmtstr]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.nextfmtchars.c],	r10b
    movzx     rax,	byte [rbp + msys.nextfmtchars.c]
    cmp       rax,	35
    jz        L84
    cmp       rax,	0
    jz        L85
    cmp       rax,	126
    jz        L86
    jmp       L87
L84:
    mov       rax,	[rbp + msys.nextfmtchars.lastx]
    test      rax,	rax
    jz        L89
    jmp       L90
L89:
L88:
    inc       qword [msys.fmtstr]
    mov       rax,	[rbp + msys.nextfmtchars.n]
    test      rax,	rax
    jz        L92
    mov       rcx,	[rbp + msys.nextfmtchars.pstart]
    mov       rdx,	[rbp + msys.nextfmtchars.n]
    call      msys.printstr_n
L92:
L91:
    jmp       L76
L85:
    mov       rax,	[rbp + msys.nextfmtchars.n]
    test      rax,	rax
    jz        L94
    mov       rcx,	[rbp + msys.nextfmtchars.pstart]
    mov       rdx,	[rbp + msys.nextfmtchars.n]
    call      msys.printstr_n
    jmp       L93
L94:
    mov       rax,	[rbp + msys.nextfmtchars.lastx]
    test      rax,	rax
    jnz       L95
    lea       rcx,	[rel L5451]
    mov       rdx,	1
    call      msys.printstr_n
L95:
L93:
    jmp       L76
L86:
    mov       rax,	[rbp + msys.nextfmtchars.n]
    test      rax,	rax
    jz        L97
    mov       rcx,	[rbp + msys.nextfmtchars.pstart]
    mov       rdx,	[rbp + msys.nextfmtchars.n]
    call      msys.printstr_n
    xor       eax,	eax
    mov       [rbp + msys.nextfmtchars.n],	rax
L97:
L96:
    inc       qword [msys.fmtstr]
    mov       rax,	[msys.fmtstr]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.nextfmtchars.c],	r10b
    movzx     rax,	byte [rbp + msys.nextfmtchars.c]
    test      rax,	rax
    jz        L99
    inc       qword [msys.fmtstr]
    movzx     rax,	byte [rbp + msys.nextfmtchars.c]
    mov       rcx,	rax
    call      msys.printchar
L99:
L98:
    mov       rax,	[msys.fmtstr]
    mov       [rbp + msys.nextfmtchars.pstart],	rax
    jmp       L83
L87:
;skip:
L90:
    inc       qword [rbp + msys.nextfmtchars.n]
    inc       qword [msys.fmtstr]
L83:
    jmp       L81
L82:
L76:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc strtofmt
msys.strtofmt:
;>>
    %define msys.strtofmt.s 16
    %define msys.strtofmt.slen 24
    %define msys.strtofmt.fmt 32
    %define msys.strtofmt.c -8
    %define msys.strtofmt.base -16
    %define msys.strtofmt.wset -24
    %define msys.strtofmt.n -32
    %define msys.strtofmt.str -136
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    lea       rax,	[msys.defaultfmt]
    mov       r10,	[rbp + msys.strtofmt.fmt]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rax,	[rbp + msys.strtofmt.s]
    cmp       rax,	0
    jnz       L102
    jmp       L100
L102:
L101:
    mov       rax,	[rbp + msys.strtofmt.slen]
    cmp       rax,	-1
    jnz       L104
    mov       rcx,	[rbp + msys.strtofmt.s]
    call      strlen
    mov       [rbp + msys.strtofmt.slen],	rax
L104:
L103:
    lea       rcx,	[rbp + msys.strtofmt.str]
    mov       rdx,	[rbp + msys.strtofmt.s]
    mov       r8,	[rbp + msys.strtofmt.slen]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.strtofmt.slen]
    mov       [rbp + r10 + msys.strtofmt.str],	al
    lea       rax,	[rbp + msys.strtofmt.str]
    mov       [rbp + msys.strtofmt.s],	rax
    xor       eax,	eax
    mov       [rbp + msys.strtofmt.wset],	al
    jmp       L106
L105:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.strtofmt.c],	r10
    inc       qword [rbp + msys.strtofmt.s]
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	65
    jnz       L109
    mov       al,	65
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+8],	al
    jmp       L108
L109:
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	97
    jnz       L110
    mov       al,	97
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+8],	al
    jmp       L108
L110:
    mov       rcx,	[rbp + msys.strtofmt.c]
    call      toupper
    movsxd    rax,	eax
    sub       rax,	66
    cmp       rax,	25
    jae       L113
    lea       r10,	[rel L112]
    jmp       [r10 + rax*8]
    segment .data
L112:
    dq  L114
    dq  L143
    dq  L142
    dq  L139
    dq  L140
    dq  L141
    dq  L115
    dq  L113
    dq  L125
    dq  L113
    dq  L113
    dq  L144
    dq  L147
    dq  L116
    dq  L132
    dq  L124
    dq  L113
    dq  L129
    dq  L135
    dq  L138
    dq  L145
    dq  L113
    dq  L117
    dq  L146
    dq  L128
    segment .text
L114:
    mov       al,	2
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+2],	al
    jmp       L111
L115:
    mov       al,	16
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+2],	al
    jmp       L111
L116:
    mov       al,	8
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+2],	al
    jmp       L111
L117:
    xor       eax,	eax
    mov       [rbp + msys.strtofmt.base],	rax
L118:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.strtofmt.c],	r10
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	48
    jl        L121
    cmp       rax,	57
    jg        L121
    mov       rax,	[rbp + msys.strtofmt.base]
    imul      rax,	10
    add       rax,	[rbp + msys.strtofmt.c]
    sub       rax,	48
    mov       [rbp + msys.strtofmt.base],	rax
    inc       qword [rbp + msys.strtofmt.s]
    jmp       L120
L121:
    jmp       L119
L120:
    jmp       L118
L119:
    mov       rax,	[rbp + msys.strtofmt.base]
    cmp       rax,	2
    jl        L123
    cmp       rax,	16
    jg        L123
    mov       al,	[rbp + msys.strtofmt.base]
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+2],	al
L123:
L122:
    jmp       L111
L124:
    mov       al,	34
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+3],	al
    jmp       L111
L125:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       rcx,	r10
    call      toupper
    movsxd    rax,	eax
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+9],	al
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L127
    inc       qword [rbp + msys.strtofmt.s]
L127:
L126:
    jmp       L111
L128:
    mov       al,	48
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+4],	al
    jmp       L111
L129:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + msys.strtofmt.fmt]
    mov       [rax+7],	r10b
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L131
    inc       qword [rbp + msys.strtofmt.s]
L131:
L130:
    jmp       L111
L132:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + msys.strtofmt.fmt]
    mov       [rax+4],	r10b
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L134
    inc       qword [rbp + msys.strtofmt.s]
L134:
L133:
    jmp       L111
L135:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + msys.strtofmt.fmt]
    mov       [rax+10],	r10b
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L137
    inc       qword [rbp + msys.strtofmt.s]
L137:
L136:
    jmp       L111
L138:
    mov       al,	87
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+11],	al
    jmp       L111
L139:
    mov       al,	101
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+5],	al
    jmp       L111
L140:
    mov       al,	102
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+5],	al
    jmp       L111
L141:
    mov       al,	103
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+5],	al
    jmp       L111
L142:
    mov       al,	68
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+13],	al
    jmp       L111
L143:
    mov       al,	67
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+12],	al
    jmp       L111
L144:
    mov       al,	77
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+12],	al
    jmp       L111
L145:
    mov       al,	86
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+14],	al
    jmp       L111
L146:
    mov       rax,	[rbp + msys.strtofmt.fmt]
    lea       rax,	[rax+15]
    or        byte [rax],	1
    jmp       L111
L147:
    mov       rax,	[rbp + msys.strtofmt.fmt]
    lea       rax,	[rax+15]
    or        byte [rax],	2
    jmp       L111
L113:
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	46
    jz        L149
    cmp       rax,	44
    jz        L150
    cmp       rax,	95
    jz        L150
    cmp       rax,	43
    jz        L151
    cmp       rax,	126
    jz        L152
    cmp       rax,	42
    jz        L153
    jmp       L154
L149:
    mov       al,	1
    mov       [rbp + msys.strtofmt.wset],	al
    jmp       L148
L150:
    mov       al,	[rbp + msys.strtofmt.c]
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+7],	al
    jmp       L148
L151:
    mov       al,	43
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+6],	al
    jmp       L148
L152:
    mov       al,	126
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+3],	al
    jmp       L148
L153:
    mov       rax,	[msys.fmtparam]
    mov       [rbp + msys.strtofmt.n],	rax
    jmp       L155
L154:
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	48
    jl        L157
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	57
    jg        L157
    mov       rax,	[rbp + msys.strtofmt.c]
    sub       rax,	48
    mov       [rbp + msys.strtofmt.n],	rax
L158:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.strtofmt.c],	r10
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L161
    jmp       L159
L161:
L160:
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	48
    jl        L163
    mov       rax,	[rbp + msys.strtofmt.c]
    cmp       rax,	57
    jg        L163
    inc       qword [rbp + msys.strtofmt.s]
    mov       rax,	[rbp + msys.strtofmt.n]
    imul      rax,	10
    add       rax,	[rbp + msys.strtofmt.c]
    sub       rax,	48
    mov       [rbp + msys.strtofmt.n],	rax
    jmp       L162
L163:
    jmp       L159
L162:
    jmp       L158
L159:
;gotwidth:
L155:
    movzx     rax,	byte [rbp + msys.strtofmt.wset]
    test      rax,	rax
    jnz       L165
    mov       al,	[rbp + msys.strtofmt.n]
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10],	al
    mov       al,	1
    mov       [rbp + msys.strtofmt.wset],	al
    jmp       L164
L165:
    mov       al,	[rbp + msys.strtofmt.n]
    mov       r10,	[rbp + msys.strtofmt.fmt]
    mov       [r10+1],	al
L164:
L157:
L156:
L148:
L111:
L108:
L106:
    mov       rax,	[rbp + msys.strtofmt.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L105
L107:
L100:
;---------------
    add       rsp,	176
    pop       rbp
    ret       
;End 
;Proc domultichar
msys.domultichar:
;>>
    %define msys.domultichar.p 16
    %define msys.domultichar.n 24
    %define msys.domultichar.dest 32
    %define msys.domultichar.fmt 40
    %define msys.domultichar.str -24
    %define msys.domultichar.q -32
    %define msys.domultichar.i -40
    %define msys.domultichar.nchars -48
    %define msys.domultichar.av_1 -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    lea       rax,	[rbp + msys.domultichar.str]
    mov       [rbp + msys.domultichar.q],	rax
    mov       rax,	[rbp + msys.domultichar.n]
    mov       [rbp + msys.domultichar.nchars],	rax
    mov       rax,	[rbp + msys.domultichar.n]
    mov       [rbp + msys.domultichar.av_1],	rax
    mov       rax,	[rbp + msys.domultichar.av_1]
    cmp       rax,	0
    jle       L169
L167:
    mov       rax,	[rbp + msys.domultichar.p]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L171
    jmp       L169
L171:
L170:
    mov       rax,	[rbp + msys.domultichar.p]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + msys.domultichar.q]
    mov       [rax],	r10b
    inc       qword [rbp + msys.domultichar.q]
    inc       qword [rbp + msys.domultichar.p]
L168:
    dec       qword [rbp + msys.domultichar.av_1]
    jnz       L167
L169:
    xor       eax,	eax
    mov       r10,	[rbp + msys.domultichar.q]
    mov       [r10],	al
    lea       rcx,	[rbp + msys.domultichar.str]
    call      strlen
    lea       rcx,	[rbp + msys.domultichar.str]
    mov       rdx,	[rbp + msys.domultichar.dest]
    mov       r8,	rax
    mov       r9,	[rbp + msys.domultichar.fmt]
    call      msys.expandstr
L166:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc expandstr
msys.expandstr:
;>>
    %define msys.expandstr.s 16
    %define msys.expandstr.t 24
    %define msys.expandstr.n 32
    %define msys.expandstr.fmt 40
    %define msys.expandstr.i -8
    %define msys.expandstr.w -16
    %define msys.expandstr.m -24
    %define msys.expandstr.av_1 -32
    %define msys.expandstr.av_2 -40
    %define msys.expandstr.av_3 -48
    %define msys.expandstr.av_4 -56
    %define msys.expandstr.av_5 -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.expandstr.w],	r10
    mov       rax,	[rbp + msys.expandstr.w]
    cmp       rax,	0
    jz        L175
    mov       rax,	[rbp + msys.expandstr.w]
    cmp       rax,	[rbp + msys.expandstr.n]
    jg        L174
L175:
    mov       rcx,	[rbp + msys.expandstr.t]
    mov       rdx,	[rbp + msys.expandstr.s]
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.t]
    mov       r11,	[rbp + msys.expandstr.n]
    mov       [r10 + r11],	al
    mov       rax,	[rbp + msys.expandstr.n]
    jmp       L172
L174:
L173:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+9]
    cmp       r10,	76
    jnz       L177
    mov       rcx,	[rbp + msys.expandstr.t]
    mov       rdx,	[rbp + msys.expandstr.s]
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       [rbp + msys.expandstr.t],	rax
    mov       rax,	1
    mov       [rbp + msys.expandstr.i],	rax
    mov       rax,	[rbp + msys.expandstr.w]
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_1],	rax
    mov       rax,	[rbp + msys.expandstr.av_1]
    cmp       rax,	1
    jl        L180
L178:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+4]
    mov       rax,	[rbp + msys.expandstr.t]
    mov       [rax],	r10b
    inc       qword [rbp + msys.expandstr.t]
L179:
    mov       rax,	[rbp + msys.expandstr.i]
    inc       rax
    mov       [rbp + msys.expandstr.i],	rax
    cmp       rax,	[rbp + msys.expandstr.av_1]
    jle       L178
L180:
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.t]
    mov       [r10],	al
    jmp       L176
L177:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+9]
    cmp       r10,	82
    jnz       L181
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+4]
    cmp       r10,	48
    jnz       L183
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+2]
    test      r10,	r10
    jz        L183
    mov       rax,	[rbp + msys.expandstr.s]
    movzx     r10,	byte [rax]
    cmp       r10,	45
    jz        L184
    mov       rax,	[rbp + msys.expandstr.s]
    movzx     r10,	byte [rax]
    cmp       r10,	43
    jnz       L183
L184:
    mov       rax,	[rbp + msys.expandstr.s]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + msys.expandstr.t]
    mov       [rax],	r10b
    inc       qword [rbp + msys.expandstr.t]
    mov       rax,	[rbp + msys.expandstr.w]
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_2],	rax
    mov       rax,	[rbp + msys.expandstr.av_2]
    cmp       rax,	0
    jle       L187
L185:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+4]
    mov       rax,	[rbp + msys.expandstr.t]
    mov       [rax],	r10b
    inc       qword [rbp + msys.expandstr.t]
L186:
    dec       qword [rbp + msys.expandstr.av_2]
    jnz       L185
L187:
    mov       rax,	[rbp + msys.expandstr.n]
    sub       rax,	1
    mov       r10,	[rbp + msys.expandstr.s]
    lea       r10,	[r10+1]
    mov       rcx,	[rbp + msys.expandstr.t]
    mov       rdx,	r10
    mov       r8,	rax
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.t]
    mov       r10,	[rbp + msys.expandstr.n]
    lea       rax,	[rax + r10]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L182
L183:
    mov       rax,	[rbp + msys.expandstr.w]
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_3],	rax
    mov       rax,	[rbp + msys.expandstr.av_3]
    cmp       rax,	0
    jle       L190
L188:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+4]
    mov       rax,	[rbp + msys.expandstr.t]
    mov       [rax],	r10b
    inc       qword [rbp + msys.expandstr.t]
L189:
    dec       qword [rbp + msys.expandstr.av_3]
    jnz       L188
L190:
    mov       rcx,	[rbp + msys.expandstr.t]
    mov       rdx,	[rbp + msys.expandstr.s]
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.t]
    mov       r11,	[rbp + msys.expandstr.n]
    mov       [r10 + r11],	al
L182:
    jmp       L176
L181:
    mov       rax,	[rbp + msys.expandstr.w]
    sub       rax,	[rbp + msys.expandstr.n]
    add       rax,	1
    sar       rax,	1
    mov       [rbp + msys.expandstr.m],	rax
    mov       rax,	[rbp + msys.expandstr.m]
    mov       [rbp + msys.expandstr.av_4],	rax
    mov       rax,	[rbp + msys.expandstr.av_4]
    cmp       rax,	0
    jle       L193
L191:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+4]
    mov       rax,	[rbp + msys.expandstr.t]
    mov       [rax],	r10b
    inc       qword [rbp + msys.expandstr.t]
L192:
    dec       qword [rbp + msys.expandstr.av_4]
    jnz       L191
L193:
    mov       rcx,	[rbp + msys.expandstr.t]
    mov       rdx,	[rbp + msys.expandstr.s]
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       [rbp + msys.expandstr.t],	rax
    mov       rax,	[rbp + msys.expandstr.w]
    sub       rax,	[rbp + msys.expandstr.n]
    sub       rax,	[rbp + msys.expandstr.m]
    mov       [rbp + msys.expandstr.av_5],	rax
    mov       rax,	[rbp + msys.expandstr.av_5]
    cmp       rax,	0
    jle       L196
L194:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     r10,	byte [rax+4]
    mov       rax,	[rbp + msys.expandstr.t]
    mov       [rax],	r10b
    inc       qword [rbp + msys.expandstr.t]
L195:
    dec       qword [rbp + msys.expandstr.av_5]
    jnz       L194
L196:
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.t]
    mov       [r10],	al
L176:
    mov       rax,	[rbp + msys.expandstr.w]
L172:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc u64tostr
msys.u64tostr:
;>>
    %define msys.u64tostr.aa 16
    %define msys.u64tostr.s 24
    %define msys.u64tostr.base 32
    %define msys.u64tostr.sep 40
    %define msys.u64tostr.t -360
    %define msys.u64tostr.dd -368
    %define msys.u64tostr.i -376
    %define msys.u64tostr.j -384
    %define msys.u64tostr.k -392
    %define msys.u64tostr.g -400
    %define msys.u64tostr.cc -408
    %define msys.u64tostr.dummy -416
    %define msys.u64tostr.s0 -424
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	432
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + msys.u64tostr.i],	rax
    xor       eax,	eax
    mov       [rbp + msys.u64tostr.k],	rax
    mov       rax,	[rbp + msys.u64tostr.base]
    cmp       rax,	10
    jnz       L199
    mov       rax,	3
    jmp       L198
L199:
    mov       rax,	4
L198:
    mov       [rbp + msys.u64tostr.g],	rax
L200:
    mov       rax,	[rbp + msys.u64tostr.aa]
    mov       r10,	[rbp + msys.u64tostr.base]
    xor       rdx,	rdx
    div       r10
    xchg      rax,	rdx
    mov       [rbp + msys.u64tostr.dd],	rax
    mov       rax,	[rbp + msys.u64tostr.aa]
    mov       r10,	[rbp + msys.u64tostr.base]
    xor       rdx,	rdx
    div       r10
    mov       [rbp + msys.u64tostr.aa],	rax
    lea       rax,	[msys.digits]
    mov       r10,	[rbp + msys.u64tostr.dd]
    movzx     r11,	byte [rax + r10]
    inc       qword [rbp + msys.u64tostr.i]
    mov       rax,	[rbp + msys.u64tostr.i]
    mov       [rbp + rax + msys.u64tostr.t],	r11b
    inc       qword [rbp + msys.u64tostr.k]
    mov       rax,	[rbp + msys.u64tostr.sep]
    test      rax,	rax
    jz        L204
    mov       rax,	[rbp + msys.u64tostr.aa]
    cmp       rax,	0
    jz        L204
    mov       rax,	[rbp + msys.u64tostr.k]
    cmp       rax,	[rbp + msys.u64tostr.g]
    jnz       L204
    inc       qword [rbp + msys.u64tostr.i]
    mov       rax,	[rbp + msys.u64tostr.i]
    mov       r10b,	[rbp + msys.u64tostr.sep]
    mov       [rbp + rax + msys.u64tostr.t],	r10b
    xor       eax,	eax
    mov       [rbp + msys.u64tostr.k],	rax
L204:
L203:
L201:
    mov       rax,	[rbp + msys.u64tostr.aa]
    cmp       rax,	0
    jnz       L200
L202:
    mov       rax,	[rbp + msys.u64tostr.i]
    mov       [rbp + msys.u64tostr.j],	rax
    mov       rax,	[rbp + msys.u64tostr.s]
    mov       [rbp + msys.u64tostr.s0],	rax
    jmp       L206
L205:
    mov       rax,	[rbp + msys.u64tostr.i]
    dec       qword [rbp + msys.u64tostr.i]
    movzx     r10,	byte [rbp + rax + msys.u64tostr.t]
    mov       rax,	[rbp + msys.u64tostr.s]
    mov       [rax],	r10b
    inc       qword [rbp + msys.u64tostr.s]
L206:
    mov       rax,	[rbp + msys.u64tostr.i]
    test      rax,	rax
    jnz       L205
L207:
    xor       eax,	eax
    mov       r10,	[rbp + msys.u64tostr.s]
    mov       [r10],	al
    mov       rax,	[rbp + msys.u64tostr.j]
L197:
;---------------
    add       rsp,	432
    pop       rbp
    ret       
;End 
;Proc i64tostrfmt
msys.i64tostrfmt:
;>>
    %define msys.i64tostrfmt.aa 16
    %define msys.i64tostrfmt.s 24
    %define msys.i64tostrfmt.fmt 32
    %define msys.i64tostrfmt.str -360
    %define msys.i64tostrfmt.i -368
    %define msys.i64tostrfmt.j -376
    %define msys.i64tostrfmt.k -384
    %define msys.i64tostrfmt.n -392
    %define msys.i64tostrfmt.w -400
    %define msys.i64tostrfmt.usigned -408
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	448
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       eax,	eax
    mov       [rbp + msys.i64tostrfmt.usigned],	rax
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+11]
    test      r10,	r10
    jz        L210
    mov       rax,	1
    mov       [rbp + msys.i64tostrfmt.usigned],	rax
L210:
L209:
    mov       rax,	[rbp + msys.i64tostrfmt.aa]
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L212
    mov       rax,	[rbp + msys.i64tostrfmt.usigned]
    test      rax,	rax
    jnz       L212
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+7]
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r11,	byte [rax+2]
    lea       rax,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	rax
    mov       rdx,	r11
    mov       r8,	r10
    call      msys.i64mintostr
    add       rax,	1
    mov       [rbp + msys.i64tostrfmt.n],	rax
    jmp       L211
L212:
    mov       rax,	[rbp + msys.i64tostrfmt.usigned]
    test      rax,	rax
    jnz       L216
    mov       rax,	[rbp + msys.i64tostrfmt.aa]
    cmp       rax,	0
    jl        L215
L216:
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+6]
    test      r10,	r10
    jz        L214
L215:
    mov       rax,	[rbp + msys.i64tostrfmt.aa]
    cmp       rax,	0
    jge       L218
    mov       rax,	[rbp + msys.i64tostrfmt.aa]
    neg       rax
    mov       [rbp + msys.i64tostrfmt.aa],	rax
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    jmp       L217
L218:
    mov       al,	43
    mov       [rbp + msys.i64tostrfmt.str],	al
L217:
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+7]
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r11,	byte [rax+2]
    lea       rax,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	[rbp + msys.i64tostrfmt.aa]
    mov       rdx,	rax
    mov       r8,	r11
    mov       r9,	r10
    call      msys.u64tostr
    add       rax,	1
    mov       [rbp + msys.i64tostrfmt.n],	rax
    jmp       L213
L214:
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+7]
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r11,	byte [rax+2]
    mov       rcx,	[rbp + msys.i64tostrfmt.aa]
    lea       rdx,	[rbp + msys.i64tostrfmt.str]
    mov       r8,	r11
    mov       r9,	r10
    call      msys.u64tostr
    mov       [rbp + msys.i64tostrfmt.n],	rax
L213:
L211:
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jz        L220
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + msys.i64tostrfmt.n]
    mov       [rbp + rax + msys.i64tostrfmt.str],	r10b
    inc       qword [rbp + msys.i64tostrfmt.n]
    mov       rax,	[rbp + msys.i64tostrfmt.n]
    xor       r10d,	r10d
    mov       [rbp + rax + msys.i64tostrfmt.str],	r10b
L220:
L219:
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+2]
    cmp       r10,	10
    jg        L223
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jz        L222
L223:
    mov       rax,	[rbp + msys.i64tostrfmt.fmt]
    movzx     r10,	byte [rax+8]
    cmp       r10,	97
    jnz       L222
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L222:
L221:
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    mov       rdx,	[rbp + msys.i64tostrfmt.s]
    mov       r8,	[rbp + msys.i64tostrfmt.n]
    mov       r9,	[rbp + msys.i64tostrfmt.fmt]
    call      msys.expandstr
L208:
;---------------
    add       rsp,	448
    pop       rbp
    ret       
;End 
;Proc u64tostrfmt
msys.u64tostrfmt:
;>>
    %define msys.u64tostrfmt.aa 16
    %define msys.u64tostrfmt.s 24
    %define msys.u64tostrfmt.fmt 32
    %define msys.u64tostrfmt.str -360
    %define msys.u64tostrfmt.i -368
    %define msys.u64tostrfmt.j -376
    %define msys.u64tostrfmt.k -384
    %define msys.u64tostrfmt.n -392
    %define msys.u64tostrfmt.w -400
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	432
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r10,	byte [rax+7]
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r11,	byte [rax+2]
    mov       rcx,	[rbp + msys.u64tostrfmt.aa]
    lea       rdx,	[rbp + msys.u64tostrfmt.str]
    mov       r8,	r11
    mov       r9,	r10
    call      msys.u64tostr
    mov       [rbp + msys.u64tostrfmt.n],	rax
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jz        L226
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + msys.u64tostrfmt.n]
    mov       [rbp + rax + msys.u64tostrfmt.str],	r10b
    inc       qword [rbp + msys.u64tostrfmt.n]
    mov       rax,	[rbp + msys.u64tostrfmt.n]
    xor       r10d,	r10d
    mov       [rbp + rax + msys.u64tostrfmt.str],	r10b
L226:
L225:
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r10,	byte [rax+2]
    cmp       r10,	10
    jg        L229
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jz        L228
    mov       rax,	[rbp + msys.u64tostrfmt.fmt]
    movzx     r10,	byte [rax+8]
    cmp       r10,	97
    jnz       L228
L229:
L228:
L227:
    lea       rcx,	[rbp + msys.u64tostrfmt.str]
    mov       rdx,	[rbp + msys.u64tostrfmt.s]
    mov       r8,	[rbp + msys.u64tostrfmt.n]
    mov       r9,	[rbp + msys.u64tostrfmt.fmt]
    call      msys.expandstr
L224:
;---------------
    add       rsp,	432
    pop       rbp
    ret       
;End 
;Proc i64mintostr
msys.i64mintostr:
;>>
    %define msys.i64mintostr.s 16
    %define msys.i64mintostr.base 24
    %define msys.i64mintostr.sep 32
    %define msys.i64mintostr.t -360
    %define msys.i64mintostr.i -368
    %define msys.i64mintostr.j -376
    %define msys.i64mintostr.k -384
    %define msys.i64mintostr.g -392
    %define msys.i64mintostr.neg -400
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	432
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + msys.i64mintostr.base]
    cmp       rax,	10
    jz        L232
    cmp       rax,	16
    jz        L233
    cmp       rax,	2
    jz        L234
    jmp       L235
L232:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rel L5452]
    call      strcpy
    mov       rax,	3
    mov       [rbp + msys.i64mintostr.j],	rax
    jmp       L231
L233:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rel L5453]
    call      strcpy
    mov       rax,	1
    mov       [rbp + msys.i64mintostr.j],	rax
    jmp       L231
L234:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rel L5454]
    call      strcpy
    mov       rax,	7
    mov       [rbp + msys.i64mintostr.j],	rax
    jmp       L231
L235:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rel L5455]
    call      strcpy
L231:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    call      strlen
    mov       [rbp + msys.i64mintostr.i],	rax
    mov       rax,	[rbp + msys.i64mintostr.i]
    add       [rbp + msys.i64mintostr.s],	rax
    mov       rax,	[rbp + msys.i64mintostr.sep]
    test      rax,	rax
    jz        L237
    mov       rax,	[rbp + msys.i64mintostr.j]
    add       [rbp + msys.i64mintostr.s],	rax
L237:
L236:
    xor       eax,	eax
    mov       r10,	[rbp + msys.i64mintostr.s]
    mov       [r10],	al
    xor       eax,	eax
    mov       [rbp + msys.i64mintostr.k],	rax
    mov       rax,	[rbp + msys.i64mintostr.base]
    cmp       rax,	10
    jnz       L239
    mov       rax,	3
    jmp       L238
L239:
    mov       rax,	4
L238:
    mov       [rbp + msys.i64mintostr.g],	rax
    jmp       L241
L240:
    dec       qword [rbp + msys.i64mintostr.s]
    mov       rax,	[rbp + msys.i64mintostr.i]
    dec       qword [rbp + msys.i64mintostr.i]
    movzx     r10,	byte [rbp + rax + msys.i64mintostr.t-1]
    mov       rax,	[rbp + msys.i64mintostr.s]
    mov       [rax],	r10b
    mov       rax,	[rbp + msys.i64mintostr.sep]
    test      rax,	rax
    jz        L244
    mov       rax,	[rbp + msys.i64mintostr.i]
    test      rax,	rax
    jz        L244
    inc       qword [rbp + msys.i64mintostr.k]
    mov       rax,	[rbp + msys.i64mintostr.k]
    cmp       rax,	[rbp + msys.i64mintostr.g]
    jnz       L244
    dec       qword [rbp + msys.i64mintostr.s]
    mov       al,	[rbp + msys.i64mintostr.sep]
    mov       r10,	[rbp + msys.i64mintostr.s]
    mov       [r10],	al
    xor       eax,	eax
    mov       [rbp + msys.i64mintostr.k],	rax
L244:
L243:
L241:
    mov       rax,	[rbp + msys.i64mintostr.i]
    test      rax,	rax
    jnz       L240
L242:
    mov       rcx,	[rbp + msys.i64mintostr.s]
    call      strlen
L230:
;---------------
    add       rsp,	432
    pop       rbp
    ret       
;End 
;Proc strtostrfmt
msys.strtostrfmt:
;>>
    %define msys.strtostrfmt.s 16
    %define msys.strtostrfmt.t 24
    %define msys.strtostrfmt.n 32
    %define msys.strtostrfmt.fmt 40
    %define msys.strtostrfmt.u -8
    %define msys.strtostrfmt.v -16
    %define msys.strtostrfmt.str -272
    %define msys.strtostrfmt.w -280
    %define msys.strtostrfmt.nheap -288
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	320
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + msys.strtostrfmt.nheap],	rax
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax+3]
    test      r10,	r10
    jnz       L248
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax+8]
    test      r10,	r10
    jz        L247
L248:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    cmp       rax,	256
    jge       L250
    lea       rax,	[rbp + msys.strtostrfmt.str]
    mov       [rbp + msys.strtostrfmt.u],	rax
    jmp       L249
L250:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rax,	3
    mov       [rbp + msys.strtostrfmt.nheap],	rax
    mov       rcx,	[rbp + msys.strtostrfmt.nheap]
    call      mlib.pcm_alloc
    mov       [rbp + msys.strtostrfmt.u],	rax
L249:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax+3]
    test      r10,	r10
    jz        L252
    mov       rax,	[rbp + msys.strtostrfmt.u]
    mov       [rbp + msys.strtostrfmt.v],	rax
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + msys.strtostrfmt.v]
    mov       [rax],	r10b
    inc       qword [rbp + msys.strtostrfmt.v]
    mov       rax,	[rbp + msys.strtostrfmt.n]
    test      rax,	rax
    jz        L254
    mov       rcx,	[rbp + msys.strtostrfmt.v]
    mov       rdx,	[rbp + msys.strtostrfmt.s]
    call      strcpy
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       [rbp + msys.strtostrfmt.v],	rax
L254:
L253:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + msys.strtostrfmt.v]
    mov       [rax],	r10b
    inc       qword [rbp + msys.strtostrfmt.v]
    xor       eax,	eax
    mov       r10,	[rbp + msys.strtostrfmt.v]
    mov       [r10],	al
    mov       rax,	2
    add       [rbp + msys.strtostrfmt.n],	rax
    jmp       L251
L252:
    mov       rcx,	[rbp + msys.strtostrfmt.u]
    mov       rdx,	[rbp + msys.strtostrfmt.s]
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L251:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax+8]
    cmp       r10,	97
    jz        L256
    cmp       r10,	65
    jz        L257
    jmp       L258
L256:
    mov       rcx,	[rbp + msys.strtostrfmt.u]
    call      mlib.convlcstring
    jmp       L255
L257:
    mov       rcx,	[rbp + msys.strtostrfmt.u]
    call      mlib.convucstring
L258:
L255:
    mov       rax,	[rbp + msys.strtostrfmt.u]
    mov       [rbp + msys.strtostrfmt.s],	rax
L247:
L246:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.strtostrfmt.w],	r10
    mov       rax,	[rbp + msys.strtostrfmt.w]
    cmp       rax,	[rbp + msys.strtostrfmt.n]
    jle       L260
    mov       rcx,	[rbp + msys.strtostrfmt.s]
    mov       rdx,	[rbp + msys.strtostrfmt.t]
    mov       r8,	[rbp + msys.strtostrfmt.n]
    mov       r9,	[rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [rbp + msys.strtostrfmt.n],	rax
    jmp       L259
L260:
    mov       rcx,	[rbp + msys.strtostrfmt.t]
    mov       rdx,	[rbp + msys.strtostrfmt.s]
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L259:
    mov       rax,	[rbp + msys.strtostrfmt.nheap]
    test      rax,	rax
    jz        L262
    mov       rcx,	[rbp + msys.strtostrfmt.u]
    mov       rdx,	[rbp + msys.strtostrfmt.nheap]
    call      mlib.pcm_free
L262:
L261:
    mov       rax,	[rbp + msys.strtostrfmt.n]
L245:
;---------------
    add       rsp,	320
    pop       rbp
    ret       
;End 
;Proc tostr_i64
msys.tostr_i64:
;>>
    %define msys.tostr_i64.a 16
    %define msys.tostr_i64.fmt 24
    %define msys.tostr_i64.str -360
    %define msys.tostr_i64.n -368
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + msys.tostr_i64.fmt]
    movzx     r10,	byte [rax+12]
    cmp       r10,	0
    jz        L265
    cmp       r10,	77
    jz        L266
    jmp       L267
L265:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    lea       rdx,	[rbp + msys.tostr_i64.str]
    mov       r8,	[rbp + msys.tostr_i64.fmt]
    call      msys.i64tostrfmt
    mov       [rbp + msys.tostr_i64.n],	rax
    jmp       L264
L266:
    lea       rcx,	[rbp + msys.tostr_i64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_i64.str]
    mov       r9,	[rbp + msys.tostr_i64.fmt]
    call      msys.domultichar
    mov       [rbp + msys.tostr_i64.n],	rax
    jmp       L264
L267:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L263
L264:
    lea       rcx,	[rbp + msys.tostr_i64.str]
    mov       rdx,	[rbp + msys.tostr_i64.n]
    call      msys.printstr_n
L263:
;---------------
    add       rsp,	400
    pop       rbp
    ret       
;End 
;Proc tostr_u64
msys.tostr_u64:
;>>
    %define msys.tostr_u64.a 16
    %define msys.tostr_u64.fmt 24
    %define msys.tostr_u64.str -360
    %define msys.tostr_u64.n -368
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + msys.tostr_u64.fmt]
    movzx     r10,	byte [rax+12]
    cmp       r10,	77
    jz        L270
    cmp       r10,	67
    jz        L271
    jmp       L272
L270:
    lea       rcx,	[rbp + msys.tostr_u64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_u64.str]
    mov       r9,	[rbp + msys.tostr_u64.fmt]
    call      msys.domultichar
    mov       [rbp + msys.tostr_u64.n],	rax
    jmp       L269
L271:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L268
L272:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    lea       rdx,	[rbp + msys.tostr_u64.str]
    mov       r8,	[rbp + msys.tostr_u64.fmt]
    call      msys.u64tostrfmt
    mov       [rbp + msys.tostr_u64.n],	rax
L269:
    lea       rcx,	[rbp + msys.tostr_u64.str]
    mov       rdx,	[rbp + msys.tostr_u64.n]
    call      msys.printstr_n
L268:
;---------------
    add       rsp,	400
    pop       rbp
    ret       
;End 
;Proc tostr_r64
msys.tostr_r64:
;>>
    %define msys.tostr_r64.x 16
    %define msys.tostr_r64.fmt 24
    %define msys.tostr_r64.str -360
    %define msys.tostr_r64.str2 -720
    %define msys.tostr_r64.cfmt -736
    %define msys.tostr_r64.n -744
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	784
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    mov       al,	37
    mov       [rbp + msys.tostr_r64.cfmt],	al
    mov       rax,	[rbp + msys.tostr_r64.fmt]
    movsx     r10,	byte [rax+1]
    test      r10,	r10
    jz        L275
    mov       al,	46
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    mov       al,	42
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    mov       rax,	[rbp + msys.tostr_r64.fmt]
    movzx     r10,	byte [rax+5]
    mov       [rbp + msys.tostr_r64.cfmt+3],	r10b
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+4],	al
    mov       rax,	[rbp + msys.tostr_r64.fmt]
    movsx     r10,	byte [rax+1]
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    mov       r8,	r10
    movq      XMM3,	[rbp + msys.tostr_r64.x]
    movq      r9,	XMM3
    call      sprintf
    jmp       L274
L275:
    mov       rax,	[rbp + msys.tostr_r64.fmt]
    movzx     r10,	byte [rax+5]
    mov       [rbp + msys.tostr_r64.cfmt+1],	r10b
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    movq      XMM2,	[rbp + msys.tostr_r64.x]
    movq      r8,	XMM2
    call      sprintf
L274:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    call      strlen
    mov       [rbp + msys.tostr_r64.n],	rax
    mov       rax,	[rbp + msys.tostr_r64.fmt]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + msys.tostr_r64.n]
    cmp       rax,	r10
    jge       L277
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    mov       r8,	[rbp + msys.tostr_r64.n]
    mov       r9,	[rbp + msys.tostr_r64.fmt]
    call      msys.expandstr
    mov       [rbp + msys.tostr_r64.n],	rax
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    call      strcpy
L277:
L276:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    mov       rdx,	[rbp + msys.tostr_r64.n]
    call      msys.printstr_n
L273:
;---------------
    add       rsp,	784
    pop       rbp
    ret       
;End 
;Proc tostr_str
msys.tostr_str:
;>>
    %define msys.tostr_str.s 16
    %define msys.tostr_str.oldlen 24
    %define msys.tostr_str.fmt 32
    %define msys.tostr_str.newlen -8
    %define msys.tostr_str.n -16
    %define msys.tostr_str.t -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + msys.tostr_str.oldlen]
    cmp       rax,	-1
    jnz       L280
    mov       rcx,	[rbp + msys.tostr_str.s]
    call      strlen
    mov       [rbp + msys.tostr_str.oldlen],	rax
L280:
L279:
    mov       rax,	[rbp + msys.tostr_str.oldlen]
    mov       [rbp + msys.tostr_str.newlen],	rax
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movzx     r10,	byte [rax+3]
    test      r10,	r10
    jnz       L283
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movzx     r10,	byte [rax]
    cmp       r10,	[rbp + msys.tostr_str.newlen]
    jg        L283
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movzx     r10,	byte [rax+8]
    test      r10,	r10
    jnz       L283
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movsx     r10,	byte [rax+1]
    test      r10,	r10
    jz        L282
L283:
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movzx     r10,	byte [rax+3]
    test      r10,	r10
    jz        L285
    mov       rax,	2
    add       [rbp + msys.tostr_str.newlen],	rax
L285:
L284:
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movzx     r10,	byte [rax]
    cmp       r10,	[rbp + msys.tostr_str.newlen]
    jle       L287
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.tostr_str.newlen],	r10
L287:
L286:
    mov       rax,	[rbp + msys.tostr_str.newlen]
    add       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + msys.tostr_str.t],	rax
    mov       rcx,	[rbp + msys.tostr_str.s]
    mov       rdx,	[rbp + msys.tostr_str.t]
    mov       r8,	[rbp + msys.tostr_str.oldlen]
    mov       r9,	[rbp + msys.tostr_str.fmt]
    call      msys.strtostrfmt
    mov       [rbp + msys.tostr_str.n],	rax
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movsx     r10,	byte [rax+1]
    test      r10,	r10
    jz        L289
    mov       rax,	[rbp + msys.tostr_str.fmt]
    movsx     r10,	byte [rax+1]
    cmp       [rbp + msys.tostr_str.n],	r10
    jle       L5456
    mov       [rbp + msys.tostr_str.n],	r10
L5456:
L289:
L288:
    mov       rcx,	[rbp + msys.tostr_str.t]
    mov       rdx,	[rbp + msys.tostr_str.n]
    call      msys.printstr_n
    mov       rax,	[rbp + msys.tostr_str.newlen]
    add       rax,	1
    mov       rcx,	[rbp + msys.tostr_str.t]
    mov       rdx,	rax
    call      mlib.pcm_free
    jmp       L281
L282:
    mov       rcx,	[rbp + msys.tostr_str.s]
    mov       rdx,	[rbp + msys.tostr_str.oldlen]
    call      msys.printstr_n
L281:
L278:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc getfmt
msys.getfmt:
;>>
    %define msys.getfmt.fmtstyle 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + msys.getfmt.fmtstyle]
    test      rax,	rax
    jz        L292
    mov       rcx,	[rbp + msys.getfmt.fmtstyle]
    mov       rdx,	-1
    lea       r8,	[msys.getfmt.fmt]
    call      msys.strtofmt
    lea       rax,	[msys.getfmt.fmt]
    jmp       L291
L292:
    lea       rax,	[msys.defaultfmt]
L291:
L290:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc strint
msys.strint:
;>>
    %define msys.strint.a 16
    %define msys.strint.fmtstyle 24
    %define msys.strint.fmt -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[msys.strint.str]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + msys.strint.fmtstyle]
    call      msys.getfmt
;DUPLOP
    mov       r10,	rax
    mov       [rbp + msys.strint.fmt],	r10
    mov       rcx,	[rbp + msys.strint.a]
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       rcx,	[msys.strint.str]
    mov       rdx,	[rbp + msys.strint.fmt]
    call      msys.getstr
L293:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getstrint
msys.getstrint:
;>>
    %define msys.getstrint.a 16
    %define msys.getstrint.dest 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + msys.getstrint.dest]
    call      msys.m$print_startstr
    xor       ecx,	ecx
    call      msys.getfmt
    mov       rcx,	[rbp + msys.getstrint.a]
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
L294:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc strword
msys.strword:
;>>
    %define msys.strword.a 16
    %define msys.strword.fmtstyle 24
    %define msys.strword.fmt -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[msys.strword.str]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + msys.strword.fmtstyle]
    call      msys.getfmt
;DUPLOP
    mov       r10,	rax
    mov       [rbp + msys.strword.fmt],	r10
    mov       rcx,	[rbp + msys.strword.a]
    mov       rdx,	rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       rcx,	[msys.strword.str]
    mov       rdx,	[rbp + msys.strword.fmt]
    call      msys.getstr
L295:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc strreal
msys.strreal:
;>>
    %define msys.strreal.a 16
    %define msys.strreal.fmtstyle 24
    %define msys.strreal.fmt -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[msys.strreal.str]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + msys.strreal.fmtstyle]
    call      msys.getfmt
;DUPLOP
    mov       r10,	rax
    mov       [rbp + msys.strreal.fmt],	r10
    movq      XMM0,	[rbp + msys.strreal.a]
    mov       rdx,	rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       rcx,	[msys.strreal.str]
    mov       rdx,	[rbp + msys.strreal.fmt]
    call      msys.getstr
L296:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getstr
msys.getstr:
;>>
    %define msys.getstr.s 16
    %define msys.getstr.fmt 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + msys.getstr.fmt]
    movzx     r10,	byte [rax+13]
    test      r10,	r10
    jz        L299
    mov       rcx,	[rbp + msys.getstr.s]
    call      mlib.pcm_copyheapstring
    jmp       L298
L299:
    mov       rax,	[rbp + msys.getstr.s]
L298:
L297:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc initreadbuffer
msys.initreadbuffer:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[msys.rd_buffer]
    test      rax,	rax
    jz        L302
    jmp       L300
L302:
L301:
    mov       rcx,	16384
    call      mlib.pcm_alloc
    mov       [msys.rd_buffer],	rax
    xor       eax,	eax
    mov       r10,	[msys.rd_buffer]
    mov       [r10],	al
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_lastpos],	rax
    mov       [msys.rd_pos],	rax
L300:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$read_conline
msys.m$read_conline:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      msys.initreadbuffer
    xor       ecx,	ecx
    mov       rdx,	[msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[msys.rd_buffer]
    call      strlen
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
L303:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$read_fileline
msys.m$read_fileline:
;>>
    %define msys.m$read_fileline.f 16
    %define msys.m$read_fileline.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      msys.initreadbuffer
    mov       rax,	[rbp + msys.m$read_fileline.f]
    cmp       rax,	1
    jnz       L306
    lea       rcx,	[rel L5457]
    call      mlib.abortprogram
    jmp       L304
L306:
L305:
    mov       rcx,	[rbp + msys.m$read_fileline.f]
    mov       rdx,	[msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[msys.rd_buffer]
    call      strlen
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
L304:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc m$read_strline
msys.m$read_strline:
;>>
    %define msys.m$read_strline.s 16
    %define msys.m$read_strline.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      msys.initreadbuffer
    mov       rcx,	[rbp + msys.m$read_strline.s]
    call      strlen
    mov       [rbp + msys.m$read_strline.n],	rax
    mov       rax,	[rbp + msys.m$read_strline.n]
    cmp       rax,	16384
    jge       L309
    mov       rcx,	[msys.rd_buffer]
    mov       rdx,	[rbp + msys.m$read_strline.s]
    call      strcpy
    jmp       L308
L309:
    mov       rcx,	[msys.rd_buffer]
    mov       rdx,	[rbp + msys.m$read_strline.s]
    mov       r8,	16383
    call      memcpy
    mov       rax,	[msys.rd_buffer]
    lea       rax,	[rax+16384]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
L308:
    mov       rax,	[rbp + msys.m$read_strline.n]
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
L307:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc readitem
msys.readitem:
;>>
    %define msys.readitem.itemlength 16
    %define msys.readitem.p -8
    %define msys.readitem.s -16
    %define msys.readitem.itemstr -24
    %define msys.readitem.quotechar -32
    %define msys.readitem.c -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[msys.rd_buffer]
    test      rax,	rax
    jnz       L312
    call      msys.initreadbuffer
L312:
L311:
    mov       rax,	[msys.rd_pos]
    mov       [rbp + msys.readitem.s],	rax
    jmp       L314
L313:
    inc       qword [rbp + msys.readitem.s]
L314:
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    cmp       r10,	32
    jz        L313
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    cmp       r10,	9
    jz        L313
L315:
    mov       rax,	[rbp + msys.readitem.s]
    mov       [rbp + msys.readitem.itemstr],	rax
    mov       rax,	[rbp + msys.readitem.s]
    mov       [msys.rd_pos],	rax
    mov       [msys.rd_lastpos],	rax
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L317
    xor       eax,	eax
    mov       [msys.termchar],	rax
    xor       eax,	eax
    mov       r10,	[rbp + msys.readitem.itemlength]
    mov       [r10],	rax
    mov       rax,	[rbp + msys.readitem.s]
    jmp       L310
L317:
L316:
    xor       eax,	eax
    mov       [rbp + msys.readitem.quotechar],	al
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    cmp       r10,	34
    jnz       L319
    mov       al,	34
    mov       [rbp + msys.readitem.quotechar],	al
    inc       qword [rbp + msys.readitem.s]
    jmp       L318
L319:
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    cmp       r10,	39
    jnz       L320
    mov       al,	39
    mov       [rbp + msys.readitem.quotechar],	al
    inc       qword [rbp + msys.readitem.s]
L320:
L318:
    mov       rax,	[rbp + msys.readitem.s]
    mov       [rbp + msys.readitem.itemstr],	rax
    mov       [rbp + msys.readitem.p],	rax
    jmp       L322
L321:
    mov       rax,	[rbp + msys.readitem.s]
    inc       qword [rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.readitem.c],	r10b
    movzx     rax,	byte [rbp + msys.readitem.c]
    cmp       rax,	32
    jz        L325
    cmp       rax,	9
    jz        L325
    cmp       rax,	44
    jz        L325
    cmp       rax,	61
    jz        L325
    jmp       L326
L325:
    movzx     rax,	byte [rbp + msys.readitem.quotechar]
    test      rax,	rax
    jnz       L329
    mov       rax,	[rbp + msys.readitem.p]
    cmp       rax,	[rbp + msys.readitem.s]
    jnz       L328
L329:
    jmp       L330
L328:
L327:
    movzx     rax,	byte [rbp + msys.readitem.c]
    mov       [msys.termchar],	rax
    jmp       L323
L326:
;normalchar:
L330:
    movzx     rax,	byte [rbp + msys.readitem.c]
    movzx     r10,	byte [rbp + msys.readitem.quotechar]
    cmp       rax,	r10
    jnz       L332
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    movzx     rax,	byte [rbp + msys.readitem.quotechar]
    cmp       r10,	rax
    jnz       L334
    movzx     rax,	byte [rbp + msys.readitem.c]
    mov       r10,	[rbp + msys.readitem.p]
    mov       [r10],	al
    inc       qword [rbp + msys.readitem.s]
    inc       qword [rbp + msys.readitem.p]
    jmp       L333
L334:
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    mov       [msys.termchar],	r10
    mov       rax,	[msys.termchar]
    cmp       rax,	44
    jz        L337
    cmp       rax,	61
    jnz       L336
L337:
    inc       qword [rbp + msys.readitem.s]
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    mov       [msys.termchar],	r10
L336:
L335:
    jmp       L323
L333:
    jmp       L331
L332:
    movzx     rax,	byte [rbp + msys.readitem.c]
    mov       r10,	[rbp + msys.readitem.p]
    mov       [r10],	al
    inc       qword [rbp + msys.readitem.p]
L331:
L324:
L322:
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L321
L323:
    mov       rax,	[rbp + msys.readitem.s]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L339
    xor       eax,	eax
    mov       [msys.termchar],	rax
L339:
L338:
    mov       rax,	[rbp + msys.readitem.p]
    sub       rax,	[rbp + msys.readitem.itemstr]
    mov       r10,	[rbp + msys.readitem.itemlength]
    mov       [r10],	rax
    mov       rax,	[rbp + msys.readitem.s]
    mov       [msys.rd_pos],	rax
    mov       rax,	[rbp + msys.readitem.itemstr]
L310:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc strtoint
msys.strtoint:
;>>
    %define msys.strtoint.s 16
    %define msys.strtoint.length 24
    %define msys.strtoint.base 32
    %define msys.strtoint.signd -8
    %define msys.strtoint.aa -16
    %define msys.strtoint.c -24
    %define msys.strtoint.d -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    mov       rax,	[rbp + msys.strtoint.length]
    cmp       rax,	-1
    jnz       L342
    mov       rcx,	[rbp + msys.strtoint.s]
    call      strlen
    mov       [rbp + msys.strtoint.length],	rax
L342:
L341:
    xor       eax,	eax
    mov       [rbp + msys.strtoint.signd],	al
    mov       rax,	[rbp + msys.strtoint.length]
    test      rax,	rax
    jz        L344
    mov       rax,	[rbp + msys.strtoint.s]
    movzx     r10,	byte [rax]
    cmp       r10,	45
    jnz       L344
    mov       al,	1
    mov       [rbp + msys.strtoint.signd],	al
    inc       qword [rbp + msys.strtoint.s]
    dec       qword [rbp + msys.strtoint.length]
    jmp       L343
L344:
    mov       rax,	[rbp + msys.strtoint.length]
    test      rax,	rax
    jz        L345
    mov       rax,	[rbp + msys.strtoint.s]
    movzx     r10,	byte [rax]
    cmp       r10,	43
    jnz       L345
    inc       qword [rbp + msys.strtoint.s]
    dec       qword [rbp + msys.strtoint.length]
L345:
L343:
    xor       eax,	eax
    mov       [rbp + msys.strtoint.aa],	rax
    jmp       L347
L346:
    mov       rax,	[rbp + msys.strtoint.s]
    inc       qword [rbp + msys.strtoint.s]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.strtoint.c],	r10
    dec       qword [rbp + msys.strtoint.length]
    mov       rax,	[rbp + msys.strtoint.c]
    cmp       rax,	65
    jl        L350
    cmp       rax,	70
    jg        L350
    mov       rax,	[rbp + msys.strtoint.c]
    sub       rax,	65
    add       rax,	10
    mov       [rbp + msys.strtoint.d],	rax
    jmp       L349
L350:
    mov       rax,	[rbp + msys.strtoint.c]
    cmp       rax,	97
    jl        L351
    cmp       rax,	102
    jg        L351
    mov       rax,	[rbp + msys.strtoint.c]
    sub       rax,	97
    add       rax,	10
    mov       [rbp + msys.strtoint.d],	rax
    jmp       L349
L351:
    mov       rax,	[rbp + msys.strtoint.c]
    cmp       rax,	48
    jl        L352
    cmp       rax,	57
    jg        L352
    mov       rax,	[rbp + msys.strtoint.c]
    sub       rax,	48
    mov       [rbp + msys.strtoint.d],	rax
    jmp       L349
L352:
    mov       rax,	[rbp + msys.strtoint.c]
    cmp       rax,	95
    jz        L354
    cmp       rax,	39
    jnz       L353
L354:
    jmp       L347
L353:
    mov       rax,	1
    mov       [msys.itemerror],	rax
    jmp       L348
L349:
    mov       rax,	[rbp + msys.strtoint.d]
    cmp       rax,	[rbp + msys.strtoint.base]
    jb        L356
    mov       rax,	1
    mov       [msys.itemerror],	rax
    jmp       L348
L356:
L355:
    mov       rax,	[rbp + msys.strtoint.aa]
    imul      rax,	[rbp + msys.strtoint.base]
    add       rax,	[rbp + msys.strtoint.d]
    mov       [rbp + msys.strtoint.aa],	rax
L347:
    mov       rax,	[rbp + msys.strtoint.length]
    test      rax,	rax
    jnz       L346
L348:
    movzx     rax,	byte [rbp + msys.strtoint.signd]
    test      rax,	rax
    jz        L358
    mov       rax,	[rbp + msys.strtoint.aa]
    neg       rax
    jmp       L357
L358:
    mov       rax,	[rbp + msys.strtoint.aa]
L357:
L340:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc m$read_i64
msys.m$read_i64:
;>>
    %define msys.m$read_i64.fmt 16
    %define msys.m$read_i64.s -8
    %define msys.m$read_i64.length -16
    %define msys.m$read_i64.c -24
    %define msys.m$read_i64.aa -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + msys.m$read_i64.fmt]
    call      toupper
    movsxd    rax,	eax
    mov       [rbp + msys.m$read_i64.fmt],	rax
    mov       rax,	[rbp + msys.m$read_i64.fmt]
    cmp       rax,	67
    jz        L361
    cmp       rax,	84
    jz        L362
    cmp       rax,	69
    jz        L363
    jmp       L364
L361:
    mov       rax,	[msys.rd_pos]
    mov       [msys.rd_lastpos],	rax
    mov       rax,	[msys.rd_pos]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L366
    mov       rax,	[msys.rd_pos]
    inc       qword [msys.rd_pos]
    movzx     r10,	byte [rax]
    mov       rax,	r10
    jmp       L359
L366:
    xor       eax,	eax
    jmp       L359
L365:
    jmp       L360
L362:
    mov       rax,	[msys.termchar]
    jmp       L359
L363:
    mov       rax,	[msys.itemerror]
    jmp       L359
L364:
L360:
    lea       rcx,	[rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       [rbp + msys.m$read_i64.s],	rax
    mov       rax,	[rbp + msys.m$read_i64.fmt]
    cmp       rax,	0
    jz        L368
    cmp       rax,	73
    jz        L368
    cmp       rax,	66
    jz        L369
    cmp       rax,	72
    jz        L370
    jmp       L371
L368:
    mov       rcx,	[rbp + msys.m$read_i64.s]
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	10
    call      msys.strtoint
    jmp       L359
L369:
    mov       rcx,	[rbp + msys.m$read_i64.s]
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	2
    call      msys.strtoint
    jmp       L359
L370:
    mov       rcx,	[rbp + msys.m$read_i64.s]
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	16
    call      msys.strtoint
    jmp       L359
L371:
L367:
    xor       eax,	eax
L359:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc m$read_r64
msys.m$read_r64:
;>>
    %define msys.m$read_r64.fmt 16
    %define msys.m$read_r64.str -512
    %define msys.m$read_r64.s -520
    %define msys.m$read_r64.length -528
    %define msys.m$read_r64.numlength -536
    %define msys.m$read_r64.x -544
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	576
;---------------
    lea       rcx,	[rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       [rbp + msys.m$read_r64.s],	rax
    mov       rax,	[rbp + msys.m$read_r64.length]
    cmp       rax,	0
    jz        L375
    mov       rax,	[rbp + msys.m$read_r64.length]
    cmp       rax,	512
    jl        L374
L375:
    movq      XMM0,	[rel L5458]
    jmp       L372
L374:
L373:
    lea       rcx,	[rbp + msys.m$read_r64.str]
    mov       rdx,	[rbp + msys.m$read_r64.s]
    mov       r8,	[rbp + msys.m$read_r64.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_r64.length]
    mov       [rbp + r10 + msys.m$read_r64.str],	al
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    lea       rcx,	[rbp + msys.m$read_r64.str]
    lea       rdx,	[rel L5459]
    lea       r8,	[rbp + msys.m$read_r64.x]
    lea       r9,	[rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    rax,	eax
    cmp       rax,	0
    jz        L378
    movsxd    rax,	dword [rbp + msys.m$read_r64.numlength]
    cmp       rax,	[rbp + msys.m$read_r64.length]
    jz        L377
L378:
    movq      XMM4,	[rel L5460]
    movq      [rbp + msys.m$read_r64.x],	XMM4
    mov       rax,	1
    mov       [msys.itemerror],	rax
L377:
L376:
    movq      XMM0,	[rbp + msys.m$read_r64.x]
L372:
;---------------
    add       rsp,	576
    pop       rbp
    ret       
;End 
;Proc m$read_str
msys.m$read_str:
;>>
    %define msys.m$read_str.dest 16
    %define msys.m$read_str.destlen 24
    %define msys.m$read_str.fmt 32
    %define msys.m$read_str.s -8
    %define msys.m$read_str.length -16
    %define msys.m$read_str.numlength -24
    %define msys.m$read_str.x -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    mov       rax,	[rbp + msys.m$read_str.fmt]
    cmp       rax,	76
    jz        L382
    cmp       rax,	108
    jnz       L381
L382:
    mov       rax,	[msys.rd_pos]
    mov       [rbp + msys.m$read_str.s],	rax
    mov       rax,	[msys.rd_buffer]
    mov       r10,	[msys.rd_length]
    lea       rax,	[rax + r10]
    sub       rax,	[msys.rd_pos]
    mov       [rbp + msys.m$read_str.length],	rax
    jmp       L380
L381:
    lea       rcx,	[rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       [rbp + msys.m$read_str.s],	rax
    mov       rax,	[rbp + msys.m$read_str.fmt]
    cmp       rax,	78
    jz        L385
    cmp       rax,	110
    jnz       L384
L385:
    mov       rcx,	[rbp + msys.m$read_str.s]
    mov       rdx,	[rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L384:
L383:
L380:
    mov       rax,	[rbp + msys.m$read_str.destlen]
    cmp       rax,	0
    jle       L387
    mov       rax,	[rbp + msys.m$read_str.length]
    cmp       rax,	[rbp + msys.m$read_str.destlen]
    jl        L389
    mov       rax,	[rbp + msys.m$read_str.destlen]
    sub       rax,	1
    mov       [rbp + msys.m$read_str.length],	rax
    mov       rax,	1
    mov       [msys.itemerror],	rax
L389:
L388:
L387:
L386:
    mov       rcx,	[rbp + msys.m$read_str.dest]
    mov       rdx,	[rbp + msys.m$read_str.s]
    mov       r8,	[rbp + msys.m$read_str.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_str.dest]
    mov       r11,	[rbp + msys.m$read_str.length]
    mov       [r10 + r11],	al
L379:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc readstr
msys.readstr:
;>>
    %define msys.readstr.dest 16
    %define msys.readstr.fmt 24
    %define msys.readstr.destlen 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + msys.readstr.dest]
    mov       rdx,	[rbp + msys.readstr.destlen]
    mov       r8,	[rbp + msys.readstr.fmt]
    call      msys.m$read_str
L390:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc rereadln
msys.rereadln:
;>>
;---------------
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    mov       rax,	[msys.rd_pos]
    mov       [msys.rd_lastpos],	rax
L391:
;---------------
    ret       
;End 
;Proc reread
msys.reread:
;>>
;---------------
    mov       rax,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	rax
L392:
;---------------
    ret       
;End 
;Proc valint
msys.valint:
;>>
    %define msys.valint.s 16
    %define msys.valint.fmt 24
    %define msys.valint.old_pos -8
    %define msys.valint.old_lastpos -16
    %define msys.valint.aa -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      msys.initreadbuffer
    mov       rax,	[msys.rd_pos]
    mov       [rbp + msys.valint.old_pos],	rax
    mov       rax,	[msys.rd_lastpos]
    mov       [rbp + msys.valint.old_lastpos],	rax
    mov       rax,	[rbp + msys.valint.s]
    mov       [msys.rd_pos],	rax
    mov       rcx,	[rbp + msys.valint.fmt]
    call      msys.m$read_i64
    mov       [rbp + msys.valint.aa],	rax
    mov       rax,	[rbp + msys.valint.old_pos]
    mov       [msys.rd_pos],	rax
    mov       rax,	[rbp + msys.valint.old_lastpos]
    mov       [msys.rd_lastpos],	rax
    mov       rax,	[rbp + msys.valint.aa]
L393:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc valreal
msys.valreal:
;>>
    %define msys.valreal.s 16
    %define msys.valreal.old_pos -8
    %define msys.valreal.old_lastpos -16
    %define msys.valreal.x -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    call      msys.initreadbuffer
    mov       rax,	[msys.rd_pos]
    mov       [rbp + msys.valreal.old_pos],	rax
    mov       rax,	[msys.rd_lastpos]
    mov       [rbp + msys.valreal.old_lastpos],	rax
    mov       rax,	[rbp + msys.valreal.s]
    mov       [msys.rd_pos],	rax
    xor       ecx,	ecx
    call      msys.m$read_r64
    movq      [rbp + msys.valreal.x],	XMM0
    mov       rax,	[rbp + msys.valreal.old_pos]
    mov       [msys.rd_pos],	rax
    mov       rax,	[rbp + msys.valreal.old_lastpos]
    mov       [msys.rd_lastpos],	rax
    movq      XMM0,	[rbp + msys.valreal.x]
L394:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc mclunimpl
msys.mclunimpl:
;>>
    %define msys.mclunimpl.mess 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    lea       rcx,	[rel L5461]
    mov       rdx,	[rbp + msys.mclunimpl.mess]
    call      printf
    mov       rcx,	1
    call      exit
L395:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc dumpstr
msys.dumpstr:
;>>
    %define msys.dumpstr.s 16
    %define msys.dumpstr.n 24
    %define msys.dumpstr.fbuffer 32
    %define msys.dumpstr.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[msys.outdev]
    cmp       rax,	3
    jnz       L398
    mov       rax,	[msys.outchan]
    mov       [rbp + msys.dumpstr.p],	rax
    mov       rax,	[rbp + msys.dumpstr.n]
    test      rax,	rax
    jz        L400
    mov       rax,	[rbp + msys.dumpstr.p]
    mov       r10,	[rax]
    mov       rcx,	r10
    mov       rdx,	[rbp + msys.dumpstr.s]
    mov       r8,	[rbp + msys.dumpstr.n]
    call      memcpy
    mov       rax,	[rbp + msys.dumpstr.p]
    mov       r10,	[rbp + msys.dumpstr.n]
    add       [rax],	r10
L400:
L399:
    mov       rax,	[rbp + msys.dumpstr.p]
    mov       r10,	[rax]
    xor       eax,	eax
    mov       [r10],	al
    jmp       L396
L398:
L397:
    mov       rax,	[rbp + msys.dumpstr.n]
    cmp       rax,	0
    jnz       L402
    jmp       L396
L402:
L401:
    mov       rax,	[rbp + msys.dumpstr.fbuffer]
    test      rax,	rax
    jz        L404
    mov       rax,	[rbp + msys.dumpstr.n]
    cmp       rax,	2
    jl        L404
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jnz       L404
    dec       qword [msys.printptr]
    mov       rax,	[msys.printptr]
    movzx     r10,	byte [rax]
    cmp       r10,	10
    jnz       L406
    mov       rax,	[msys.printptr]
    sub       rax,	1
    movzx     r10,	byte [rax]
    cmp       r10,	13
    jnz       L408
    mov       rax,	[msys.printptr]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L407
L408:
    xor       eax,	eax
    mov       r10,	[msys.printptr]
    mov       [r10],	al
L407:
    lea       rcx,	[msys.printbuffer]
    call      puts
    jmp       L396
L406:
L405:
L404:
L403:
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jz        L410
    cmp       rax,	2
    jz        L411
    jmp       L412
L410:
    lea       rcx,	[rel L5462]
    mov       rdx,	[rbp + msys.dumpstr.n]
    mov       r8,	[rbp + msys.dumpstr.s]
    call      printf
    jmp       L409
L411:
    mov       rcx,	[msys.outchan]
    lea       rdx,	[rel L5462]
    mov       r8,	[rbp + msys.dumpstr.n]
    mov       r9,	[rbp + msys.dumpstr.s]
    call      fprintf
L412:
L409:
L396:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc dumpprintbuffer
msys.dumpprintbuffer:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[msys.printlen]
    test      rax,	rax
    jz        L415
    lea       rcx,	[msys.printbuffer]
    mov       rdx,	[msys.printlen]
    mov       r8,	1
    call      msys.dumpstr
L415:
L414:
    call      msys.resetprintbuffer
L413:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc resetprintbuffer
msys.resetprintbuffer:
;>>
;---------------
    lea       rax,	[msys.printbuffer]
    mov       [msys.printptr],	rax
    xor       eax,	eax
    mov       [msys.printlen],	rax
L416:
;---------------
    ret       
;End 
;Proc addtobuffer
msys.addtobuffer:
;>>
    %define msys.addtobuffer.s 16
    %define msys.addtobuffer.n 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[msys.printlen]
    add       rax,	[rbp + msys.addtobuffer.n]
    cmp       rax,	4088
    jl        L419
    call      msys.dumpprintbuffer
L419:
L418:
    mov       rax,	[rbp + msys.addtobuffer.n]
    cmp       rax,	4096
    jge       L421
    mov       rcx,	[msys.printptr]
    mov       rdx,	[rbp + msys.addtobuffer.s]
    mov       r8,	[rbp + msys.addtobuffer.n]
    call      memcpy
    mov       rax,	[rbp + msys.addtobuffer.n]
    add       [msys.printptr],	rax
    mov       rax,	[rbp + msys.addtobuffer.n]
    add       [msys.printlen],	rax
    jmp       L417
L421:
L420:
    mov       rcx,	[rbp + msys.addtobuffer.s]
    mov       rdx,	[rbp + msys.addtobuffer.n]
    xor       r8d,	r8d
    call      msys.dumpstr
L417:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$power_i64
msys.m$power_i64:
;>>
    %define msys.m$power_i64.a 16
    %define msys.m$power_i64.n 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + msys.m$power_i64.n]
    cmp       rax,	0
    jge       L424
    xor       eax,	eax
    jmp       L423
L424:
    mov       rax,	[rbp + msys.m$power_i64.n]
    cmp       rax,	0
    jnz       L425
    mov       rax,	1
    jmp       L423
L425:
    mov       rax,	[rbp + msys.m$power_i64.n]
    cmp       rax,	1
    jnz       L426
    mov       rax,	[rbp + msys.m$power_i64.a]
    jmp       L423
L426:
    mov       rax,	[rbp + msys.m$power_i64.n]
    and       rax,	1
    cmp       rax,	0
    jnz       L427
    mov       rax,	[rbp + msys.m$power_i64.n]
    sar       rax,	1
    mov       r10,	[rbp + msys.m$power_i64.a]
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    jmp       L423
L427:
    mov       rax,	[rbp + msys.m$power_i64.n]
    sub       rax,	1
    sar       rax,	1
    mov       r10,	[rbp + msys.m$power_i64.a]
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    imul      rax,	[rbp + msys.m$power_i64.a]
L423:
L422:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getutfsize
msys.getutfsize:
;>>
    %define msys.getutfsize.s 16
    %define msys.getutfsize.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + msys.getutfsize.s]
    inc       qword [rbp + msys.getutfsize.s]
    movzx     r10,	byte [rax]
    mov       [rbp + msys.getutfsize.a],	r10
    mov       rax,	[rbp + msys.getutfsize.a]
    cmp       rax,	0
    jnz       L430
    xor       eax,	eax
    jmp       L429
L430:
    mov       eax,	[rbp + msys.getutfsize.a]
    shr       eax,	7
    and       eax,	1
    cmp       rax,	0
    jnz       L431
    mov       rax,	1
    jmp       L429
L431:
    mov       rax,	[rbp + msys.getutfsize.a]
    shr       rax,	5
    and       rax,	7
    cmp       rax,	6
    jnz       L432
    mov       rax,	2
    jmp       L429
L432:
    mov       rax,	[rbp + msys.getutfsize.a]
    shr       rax,	4
    and       rax,	15
    cmp       rax,	14
    jnz       L433
    mov       rax,	3
    jmp       L429
L433:
    mov       rax,	[rbp + msys.getutfsize.a]
    shr       rax,	3
    and       rax,	31
    cmp       rax,	30
    jnz       L434
    mov       rax,	4
    jmp       L429
L434:
    mov       rax,	1
L429:
L428:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc fraction
msys.fraction:
;>>
    %define msys.fraction.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    movq      [rbp+16],	XMM0
;---------------
    movq      XMM0,	[rbp + msys.fraction.x]
    movq      XMM1,	[rel L5463]
    call      fmod
L435:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc m$sign_i64
msys.m$sign_i64:
;>>
    %define msys.m$sign_i64.a 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + msys.m$sign_i64.a]
    cmp       rax,	0
    jge       L438
    mov       rax,	-1
    jmp       L437
L438:
    mov       rax,	[rbp + msys.m$sign_i64.a]
    cmp       rax,	0
    jle       L440
    mov       rax,	1
    jmp       L439
L440:
    xor       eax,	eax
L439:
L437:
L436:
;---------------
    pop       rbp
    ret       
;End 
;Proc m$sign_r64
msys.m$sign_r64:
;>>
    %define msys.m$sign_r64.x 16
    push      rbp
    mov       rbp,	rsp
    movq      [rbp+16],	XMM0
;---------------
    movq      XMM4,	[rbp + msys.m$sign_r64.x]
    comisd    XMM4,	[rel L5464]
    jae       L443
    movq      XMM0,	[rel L5465]
    jmp       L441
L443:
L442:
    movq      XMM4,	[rbp + msys.m$sign_r64.x]
    comisd    XMM4,	[rel L5466]
    jbe       L445
    movq      XMM0,	[rel L5467]
    jmp       L441
L445:
L444:
    movq      XMM0,	[rel L5468]
L441:
;---------------
    pop       rbp
    ret       
;End 
;Proc pcm_alloc
mlib.pcm_alloc:
;>>
    %define mlib.pcm_alloc.n 16
    %define mlib.pcm_alloc.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mlib.pcm_setup]
    test      rax,	rax
    jnz       L448
    call      mlib.pcm_init
L448:
L447:
    mov       rax,	[rbp + mlib.pcm_alloc.n]
    cmp       rax,	2048
    jle       L450
    mov       rcx,	[rbp + mlib.pcm_alloc.n]
    call      mlib.pcm_getac
    mov       [mlib.alloccode],	rax
    lea       rax,	[mlib.allocupper]
    mov       r10,	[mlib.alloccode]
    mov       r11,	[rax + r10*8]
    mov       [mlib.allocbytes],	r11
    mov       rcx,	[mlib.allocbytes]
    call      mlib.allocmem
    mov       [rbp + mlib.pcm_alloc.p],	rax
    mov       rax,	[rbp + mlib.pcm_alloc.p]
    test      rax,	rax
    jnz       L452
    lea       rcx,	[rel L5469]
    call      mlib.abortprogram
L452:
L451:
    mov       rax,	[rbp + mlib.pcm_alloc.p]
    jmp       L446
L450:
L449:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	[rbp + mlib.pcm_alloc.n]
    movzx     r11,	byte [rax + r10]
    mov       [mlib.alloccode],	r11
    lea       rax,	[mlib.allocupper]
    mov       r10,	[mlib.alloccode]
    mov       r11,	[rax + r10*8]
    mov       [mlib.allocbytes],	r11
    mov       rax,	[mlib.allocbytes]
    add       [mlib.smallmemtotal],	rax
    lea       rax,	[mlib.freelist]
    mov       r10,	[mlib.alloccode]
    mov       r11,	[rax + r10*8]
    mov       [rbp + mlib.pcm_alloc.p],	r11
    test      r11,	r11
    jz        L454
    lea       rax,	[mlib.freelist]
    mov       r10,	[mlib.alloccode]
    mov       r11,	[rax + r10*8]
    mov       rax,	[r11]
    lea       r10,	[mlib.freelist]
    mov       r11,	[mlib.alloccode]
    mov       [r10 + r11*8],	rax
    mov       rax,	[rbp + mlib.pcm_alloc.p]
    jmp       L446
L454:
L453:
    mov       rax,	[mlib.pcheapptr]
    mov       [rbp + mlib.pcm_alloc.p],	rax
    mov       rax,	[mlib.allocbytes]
    add       [mlib.pcheapptr],	rax
    mov       rax,	[mlib.pcheapptr]
    cmp       rax,	[mlib.pcheapend]
    jb        L456
    mov       rcx,	[mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       [rbp + mlib.pcm_alloc.p],	rax
    mov       rax,	[rbp + mlib.pcm_alloc.p]
    jmp       L446
L456:
L455:
    mov       rax,	[rbp + mlib.pcm_alloc.p]
L446:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_free
mlib.pcm_free:
;>>
    %define mlib.pcm_free.p 16
    %define mlib.pcm_free.n 24
    %define mlib.pcm_free.acode -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.pcm_free.n]
    cmp       rax,	0
    jnz       L459
    jmp       L457
L459:
L458:
    mov       rax,	[rbp + mlib.pcm_free.n]
    cmp       rax,	2048
    jle       L461
    mov       rcx,	[rbp + mlib.pcm_free.p]
    call      free
    jmp       L457
L461:
L460:
    mov       rax,	[rbp + mlib.pcm_free.p]
    test      rax,	rax
    jz        L463
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	[rbp + mlib.pcm_free.n]
    movzx     r11,	byte [rax + r10]
    mov       [rbp + mlib.pcm_free.acode],	r11
    lea       rax,	[mlib.allocupper]
    mov       r10,	[rbp + mlib.pcm_free.acode]
    mov       r11,	[rax + r10*8]
    sub       [mlib.smallmemtotal],	r11
    lea       rax,	[mlib.freelist]
    mov       r10,	[rbp + mlib.pcm_free.acode]
    mov       r11,	[rax + r10*8]
    mov       rax,	[rbp + mlib.pcm_free.p]
    mov       [rax],	r11
    mov       rax,	[rbp + mlib.pcm_free.p]
    lea       r10,	[mlib.freelist]
    mov       r11,	[rbp + mlib.pcm_free.acode]
    mov       [r10 + r11*8],	rax
L463:
L462:
L457:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_freeac
mlib.pcm_freeac:
;>>
    %define mlib.pcm_freeac.p 16
    %define mlib.pcm_freeac.alloc 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mlib.allocupper]
    mov       r10,	[rbp + mlib.pcm_freeac.alloc]
    mov       r11,	[rax + r10*8]
    mov       rcx,	[rbp + mlib.pcm_freeac.p]
    mov       rdx,	r11
    call      mlib.pcm_free
L464:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcm_clearmem
mlib.pcm_clearmem:
;>>
    %define mlib.pcm_clearmem.p 16
    %define mlib.pcm_clearmem.n 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.pcm_clearmem.p]
    xor       edx,	edx
    mov       r8,	[rbp + mlib.pcm_clearmem.n]
    call      memset
L465:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcm_init
mlib.pcm_init:
;>>
    %define mlib.pcm_init.j -8
    %define mlib.pcm_init.k -16
    %define mlib.pcm_init.k1 -24
    %define mlib.pcm_init.k2 -32
    %define mlib.pcm_init.size -40
    %define mlib.pcm_init.av_1 -48
    %define mlib.pcm_init.i -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    xor       eax,	eax
    mov       [mlib.alloccode],	rax
    movzx     rax,	byte [mlib.pcm_setup]
    test      rax,	rax
    jz        L468
    jmp       L466
L468:
L467:
    xor       ecx,	ecx
    call      mlib.pcm_newblock
    mov       rax,	1
    mov       [rbp + mlib.pcm_init.i],	rax
L469:
    mov       rax,	1
    mov       [rbp + mlib.pcm_init.j],	rax
    mov       rax,	16
    mov       [rbp + mlib.pcm_init.k],	rax
    jmp       L473
L472:
    mov       rax,	[rbp + mlib.pcm_init.k]
    shl       rax,	1
    mov       [rbp + mlib.pcm_init.k],	rax
    inc       qword [rbp + mlib.pcm_init.j]
L473:
    mov       rax,	[rbp + mlib.pcm_init.i]
    cmp       rax,	[rbp + mlib.pcm_init.k]
    jg        L472
L474:
    mov       al,	[rbp + mlib.pcm_init.j]
    lea       r10,	[mlib.sizeindextable]
    mov       r11,	[rbp + mlib.pcm_init.i]
    mov       [r10 + r11],	al
L470:
    mov       rax,	[rbp + mlib.pcm_init.i]
    inc       rax
    mov       [rbp + mlib.pcm_init.i],	rax
    cmp       rax,	2048
    jle       L469
L471:
    mov       rax,	16
    mov       [mlib.allocupper+8],	rax
    mov       rax,	16
    mov       [rbp + mlib.pcm_init.size],	rax
    mov       rax,	2
    mov       [rbp + mlib.pcm_init.i],	rax
L475:
    mov       rax,	[rbp + mlib.pcm_init.size]
    shl       rax,	1
    mov       [rbp + mlib.pcm_init.size],	rax
    mov       rax,	[rbp + mlib.pcm_init.size]
    lea       r10,	[mlib.allocupper]
    mov       r11,	[rbp + mlib.pcm_init.i]
    mov       [r10 + r11*8],	rax
    mov       rax,	[rbp + mlib.pcm_init.size]
    cmp       rax,	33554432
    jl        L479
    mov       rax,	[rbp + mlib.pcm_init.i]
    mov       [rbp + mlib.pcm_init.k],	rax
    jmp       L477
L479:
L478:
L476:
    mov       rax,	[rbp + mlib.pcm_init.i]
    inc       rax
    mov       [rbp + mlib.pcm_init.i],	rax
    cmp       rax,	27
    jle       L475
L477:
    mov       rax,	[rbp + mlib.pcm_init.k]
    add       rax,	1
    mov       [rbp + mlib.pcm_init.i],	rax
    mov       rax,	300
    mov       [rbp + mlib.pcm_init.av_1],	rax
    mov       rax,	[rbp + mlib.pcm_init.i]
    cmp       rax,	[rbp + mlib.pcm_init.av_1]
    jg        L482
L480:
    mov       rax,	33554432
    add       [rbp + mlib.pcm_init.size],	rax
    mov       rax,	[rbp + mlib.pcm_init.size]
    mov       r10,	8589934592
    cmp       rax,	r10
    jge       L484
    mov       rax,	[rbp + mlib.pcm_init.size]
    lea       r10,	[mlib.allocupper]
    mov       r11,	[rbp + mlib.pcm_init.i]
    mov       [r10 + r11*8],	rax
    mov       rax,	[rbp + mlib.pcm_init.size]
    mov       [mlib.maxmemory],	rax
    jmp       L483
L484:
    mov       rax,	[rbp + mlib.pcm_init.i]
    sub       rax,	1
    mov       [mlib.maxalloccode],	rax
    jmp       L482
L483:
L481:
    mov       rax,	[rbp + mlib.pcm_init.i]
    inc       rax
    mov       [rbp + mlib.pcm_init.i],	rax
    cmp       rax,	[rbp + mlib.pcm_init.av_1]
    jle       L480
L482:
    mov       al,	1
    mov       [mlib.pcm_setup],	al
L466:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc pcm_getac
mlib.pcm_getac:
;>>
    %define mlib.pcm_getac.size 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.pcm_getac.size]
    cmp       rax,	2048
    jg        L487
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	[rbp + mlib.pcm_getac.size]
    movzx     r11,	byte [rax + r10]
    mov       rax,	r11
    jmp       L485
L487:
L486:
    mov       rax,	[rbp + mlib.pcm_getac.size]
    add       rax,	255
    sar       rax,	8
    mov       [rbp + mlib.pcm_getac.size],	rax
    mov       rax,	[rbp + mlib.pcm_getac.size]
    cmp       rax,	2048
    jg        L489
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	[rbp + mlib.pcm_getac.size]
    movzx     r11,	byte [rax + r10]
    add       r11,	8
    mov       rax,	r11
    jmp       L485
L489:
L488:
    mov       rax,	[rbp + mlib.pcm_getac.size]
    add       rax,	63
    sar       rax,	6
    mov       [rbp + mlib.pcm_getac.size],	rax
    mov       rax,	[rbp + mlib.pcm_getac.size]
    cmp       rax,	2048
    jg        L491
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	[rbp + mlib.pcm_getac.size]
    movzx     r11,	byte [rax + r10]
    add       r11,	14
    mov       rax,	r11
    jmp       L485
L491:
L490:
    mov       rax,	[rbp + mlib.pcm_getac.size]
    sub       rax,	2048
    add       rax,	2047
    sar       rax,	11
    add       rax,	22
    mov       [rbp + mlib.pcm_getac.size],	rax
    mov       rax,	[rbp + mlib.pcm_getac.size]
L485:
;---------------
    pop       rbp
    ret       
;End 
;Proc pcm_newblock
mlib.pcm_newblock:
;>>
    %define mlib.pcm_newblock.itemsize 16
    %define mlib.pcm_newblock.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	2097152
    add       [mlib.pcm_newblock.totalheapsize],	rax
    xor       eax,	eax
    mov       [mlib.alloccode],	rax
    mov       rcx,	2097152
    call      mlib.allocmem
    mov       [rbp + mlib.pcm_newblock.p],	rax
    mov       rax,	[rbp + mlib.pcm_newblock.p]
    cmp       rax,	0
    jnz       L494
    lea       rcx,	[rel L5470]
    call      mlib.abortprogram
L494:
L493:
    mov       rcx,	[rbp + mlib.pcm_newblock.p]
    xor       edx,	edx
    mov       r8,	2097152
    call      memset
    mov       rax,	[rbp + mlib.pcm_newblock.p]
    mov       [mlib.pcheapptr],	rax
    mov       rax,	[rbp + mlib.pcm_newblock.p]
    lea       rax,	[rax+2097152]
    mov       [mlib.pcheapend],	rax
    mov       rax,	[mlib.pcheapstart]
    cmp       rax,	0
    jnz       L496
    mov       rax,	[rbp + mlib.pcm_newblock.p]
    mov       [mlib.pcheapstart],	rax
L496:
L495:
    mov       rax,	[rbp + mlib.pcm_newblock.itemsize]
    add       [mlib.pcheapptr],	rax
    mov       rax,	[rbp + mlib.pcm_newblock.p]
L492:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_round
mlib.pcm_round:
;>>
    %define mlib.pcm_round.n 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.pcm_round.n]
    cmp       rax,	2048
    jle       L499
    mov       rax,	[rbp + mlib.pcm_round.n]
    jmp       L498
L499:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	[rbp + mlib.pcm_round.n]
    movzx     r11,	byte [rax + r10]
    lea       rax,	[mlib.pcm_round.allocbytes]
    movsxd    r10,	dword [rax + r11*4]
    mov       rax,	r10
L498:
L497:
;---------------
    pop       rbp
    ret       
;End 
;Proc pcm_allocz
mlib.pcm_allocz:
;>>
    %define mlib.pcm_allocz.n 16
    %define mlib.pcm_allocz.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.pcm_allocz.n]
    call      mlib.pcm_alloc
    mov       [rbp + mlib.pcm_allocz.p],	rax
    mov       rcx,	[rbp + mlib.pcm_allocz.p]
    xor       edx,	edx
    mov       r8,	[rbp + mlib.pcm_allocz.n]
    call      memset
    mov       rax,	[rbp + mlib.pcm_allocz.p]
L500:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_copyheapstring
mlib.pcm_copyheapstring:
;>>
    %define mlib.pcm_copyheapstring.s 16
    %define mlib.pcm_copyheapstring.q -8
    %define mlib.pcm_copyheapstring.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.pcm_copyheapstring.s]
    cmp       rax,	0
    jnz       L503
    xor       eax,	eax
    jmp       L501
L503:
L502:
    mov       rcx,	[rbp + mlib.pcm_copyheapstring.s]
    call      strlen
    add       rax,	1
    mov       [rbp + mlib.pcm_copyheapstring.n],	rax
    mov       rcx,	[rbp + mlib.pcm_copyheapstring.n]
    call      mlib.pcm_alloc
    mov       [rbp + mlib.pcm_copyheapstring.q],	rax
    mov       rcx,	[rbp + mlib.pcm_copyheapstring.q]
    mov       rdx,	[rbp + mlib.pcm_copyheapstring.s]
    mov       r8,	[rbp + mlib.pcm_copyheapstring.n]
    call      memcpy
    mov       rax,	[rbp + mlib.pcm_copyheapstring.q]
L501:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_copyheapstringn
mlib.pcm_copyheapstringn:
;>>
    %define mlib.pcm_copyheapstringn.s 16
    %define mlib.pcm_copyheapstringn.n 24
    %define mlib.pcm_copyheapstringn.q -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.pcm_copyheapstringn.s]
    cmp       rax,	0
    jnz       L506
    xor       eax,	eax
    jmp       L504
L506:
L505:
    mov       rax,	[rbp + mlib.pcm_copyheapstringn.n]
    add       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mlib.pcm_copyheapstringn.q],	rax
    mov       rcx,	[rbp + mlib.pcm_copyheapstringn.q]
    mov       rdx,	[rbp + mlib.pcm_copyheapstringn.s]
    mov       r8,	[rbp + mlib.pcm_copyheapstringn.n]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + mlib.pcm_copyheapstringn.q]
    mov       r11,	[rbp + mlib.pcm_copyheapstringn.n]
    mov       [r10 + r11],	al
    mov       rax,	[rbp + mlib.pcm_copyheapstringn.q]
L504:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_copyheapblock
mlib.pcm_copyheapblock:
;>>
    %define mlib.pcm_copyheapblock.s 16
    %define mlib.pcm_copyheapblock.length 24
    %define mlib.pcm_copyheapblock.q -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.pcm_copyheapblock.length]
    cmp       rax,	0
    jnz       L509
    xor       eax,	eax
    jmp       L507
L509:
L508:
    mov       rcx,	[rbp + mlib.pcm_copyheapblock.length]
    call      mlib.pcm_alloc
    mov       [rbp + mlib.pcm_copyheapblock.q],	rax
    mov       rcx,	[rbp + mlib.pcm_copyheapblock.q]
    mov       rdx,	[rbp + mlib.pcm_copyheapblock.s]
    mov       r8,	[rbp + mlib.pcm_copyheapblock.length]
    call      memcpy
    mov       rax,	[rbp + mlib.pcm_copyheapblock.q]
L507:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc allocmem
mlib.allocmem:
;>>
    %define mlib.allocmem.n 16
    %define mlib.allocmem.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.allocmem.n]
    call      malloc
    mov       [rbp + mlib.allocmem.p],	rax
    mov       rax,	[rbp + mlib.allocmem.p]
    test      rax,	rax
    jz        L512
    mov       rax,	[rbp + mlib.allocmem.p]
    jmp       L510
L512:
L511:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mlib.allocmem.n]
    call      msys.m$print_i64_nf
    mov       rcx,	[mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5471]
    call      mlib.abortprogram
    xor       eax,	eax
L510:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc reallocmem
mlib.reallocmem:
;>>
    %define mlib.reallocmem.p 16
    %define mlib.reallocmem.n 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.reallocmem.p]
    mov       rdx,	[rbp + mlib.reallocmem.n]
    call      realloc
    mov       [rbp + mlib.reallocmem.p],	rax
    mov       rax,	[rbp + mlib.reallocmem.p]
    test      rax,	rax
    jz        L515
    mov       rax,	[rbp + mlib.reallocmem.p]
    jmp       L513
L515:
L514:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mlib.reallocmem.n]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5472]
    call      mlib.abortprogram
    xor       eax,	eax
L513:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc abortprogram
mlib.abortprogram:
;>>
    %define mlib.abortprogram.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mlib.abortprogram.s]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L5473]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	5
    call      exit
L516:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getfilesize
mlib.getfilesize:
;>>
    %define mlib.getfilesize.handlex 16
    %define mlib.getfilesize.p -8
    %define mlib.getfilesize.size -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.getfilesize.handlex]
    call      ftell
    movsxd    rax,	eax
    mov       [rbp + mlib.getfilesize.p],	eax
    mov       rcx,	[rbp + mlib.getfilesize.handlex]
    xor       edx,	edx
    mov       r8,	2
    call      fseek
    mov       rcx,	[rbp + mlib.getfilesize.handlex]
    call      ftell
    movsxd    rax,	eax
    mov       [rbp + mlib.getfilesize.size],	eax
    mov       eax,	[rbp + mlib.getfilesize.p]
    mov       rcx,	[rbp + mlib.getfilesize.handlex]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      fseek
    mov       eax,	[rbp + mlib.getfilesize.size]
L517:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc readrandom
mlib.readrandom:
;>>
    %define mlib.readrandom.handlex 16
    %define mlib.readrandom.mem 24
    %define mlib.readrandom.offset 32
    %define mlib.readrandom.size 40
    %define mlib.readrandom.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	[rbp + mlib.readrandom.handlex]
    mov       rdx,	[rbp + mlib.readrandom.offset]
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	[rbp + mlib.readrandom.mem]
    mov       rdx,	1
    mov       r8,	[rbp + mlib.readrandom.size]
    mov       r9,	[rbp + mlib.readrandom.handlex]
    call      fread
    mov       [rbp + mlib.readrandom.a],	rax
L518:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc writerandom
mlib.writerandom:
;>>
    %define mlib.writerandom.handlex 16
    %define mlib.writerandom.mem 24
    %define mlib.writerandom.offset 32
    %define mlib.writerandom.size 40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	[rbp + mlib.writerandom.handlex]
    mov       rdx,	[rbp + mlib.writerandom.offset]
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	[rbp + mlib.writerandom.mem]
    mov       rdx,	1
    mov       r8,	[rbp + mlib.writerandom.size]
    mov       r9,	[rbp + mlib.writerandom.handlex]
    call      fwrite
L519:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc setfilepos
mlib.setfilepos:
;>>
    %define mlib.setfilepos.file 16
    %define mlib.setfilepos.offset 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.setfilepos.file]
    mov       rdx,	[rbp + mlib.setfilepos.offset]
    xor       r8d,	r8d
    call      fseek
    movsxd    rax,	eax
L520:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getfilepos
mlib.getfilepos:
;>>
    %define mlib.getfilepos.file 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.getfilepos.file]
    call      ftell
    movsxd    rax,	eax
L521:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc readfile
mlib.readfile:
;>>
    %define mlib.readfile.filename 16
    %define mlib.readfile.f -8
    %define mlib.readfile.size -16
    %define mlib.readfile.m -24
    %define mlib.readfile.p -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.readfile.filename]
    lea       rdx,	[rel L5474]
    call      fopen
    mov       [rbp + mlib.readfile.f],	rax
    mov       rax,	[rbp + mlib.readfile.f]
    cmp       rax,	0
    jnz       L524
    xor       eax,	eax
    jmp       L522
L524:
L523:
    mov       rcx,	[rbp + mlib.readfile.f]
    call      mlib.getfilesize
    mov       [rbp + mlib.readfile.size],	rax
    mov       [mlib.rfsize],	rax
    mov       rax,	[rbp + mlib.readfile.size]
    add       rax,	2
    mov       rcx,	rax
    call      malloc
    mov       [rbp + mlib.readfile.m],	rax
    mov       rax,	[rbp + mlib.readfile.m]
    cmp       rax,	0
    jnz       L526
    xor       eax,	eax
    jmp       L522
L526:
L525:
    mov       rcx,	[rbp + mlib.readfile.f]
    mov       rdx,	[rbp + mlib.readfile.m]
    xor       r8d,	r8d
    mov       r9,	[rbp + mlib.readfile.size]
    call      mlib.readrandom
    mov       rax,	[rbp + mlib.readfile.m]
    mov       r10,	[rbp + mlib.readfile.size]
    lea       rax,	[rax + r10]
    mov       [rbp + mlib.readfile.p],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mlib.readfile.p]
    mov       [r10],	ax
    mov       rcx,	[rbp + mlib.readfile.f]
    call      fclose
    mov       rax,	[rbp + mlib.readfile.m]
L522:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc writefile
mlib.writefile:
;>>
    %define mlib.writefile.filename 16
    %define mlib.writefile.data 24
    %define mlib.writefile.size 32
    %define mlib.writefile.f -8
    %define mlib.writefile.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.writefile.filename]
    lea       rdx,	[rel L5475]
    call      fopen
    mov       [rbp + mlib.writefile.f],	rax
    mov       rax,	[rbp + mlib.writefile.f]
    cmp       rax,	0
    jnz       L529
    xor       eax,	eax
    jmp       L527
L529:
L528:
    mov       rcx,	[rbp + mlib.writefile.f]
    mov       rdx,	[rbp + mlib.writefile.data]
    xor       r8d,	r8d
    mov       r9,	[rbp + mlib.writefile.size]
    call      mlib.writerandom
    mov       [rbp + mlib.writefile.n],	rax
    mov       rcx,	[rbp + mlib.writefile.f]
    call      fclose
    mov       rax,	[rbp + mlib.writefile.n]
L527:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc checkfile
mlib.checkfile:
;>>
    %define mlib.checkfile.file 16
    %define mlib.checkfile.f -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.checkfile.file]
    lea       rdx,	[rel L5476]
    call      fopen
    mov       [rbp + mlib.checkfile.f],	rax
    test      rax,	rax
    jz        L532
    mov       rcx,	[rbp + mlib.checkfile.f]
    call      fclose
    mov       rax,	1
    jmp       L530
L532:
L531:
    xor       eax,	eax
L530:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc readlinen
mlib.readlinen:
;>>
    %define mlib.readlinen.handlex 16
    %define mlib.readlinen.buffer 24
    %define mlib.readlinen.size 32
    %define mlib.readlinen.ch -8
    %define mlib.readlinen.p -16
    %define mlib.readlinen.n -24
    %define mlib.readlinen.buff -128
    %define mlib.readlinen.crseen -136
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mlib.readlinen.handlex]
    cmp       rax,	0
    jnz       L535
    call      mwindows.os_getstdin
    mov       [rbp + mlib.readlinen.handlex],	rax
L535:
L534:
    mov       rax,	[rbp + mlib.readlinen.handlex]
    cmp       rax,	0
    jnz       L537
    xor       eax,	eax
    mov       [rbp + mlib.readlinen.n],	rax
    mov       rax,	[rbp + mlib.readlinen.buffer]
    mov       [rbp + mlib.readlinen.p],	rax
L538:
    call      getchar
    movsxd    rax,	eax
    mov       [rbp + mlib.readlinen.ch],	rax
    mov       rax,	[rbp + mlib.readlinen.ch]
    cmp       rax,	13
    jz        L542
    mov       rax,	[rbp + mlib.readlinen.ch]
    cmp       rax,	10
    jz        L542
    mov       rax,	[rbp + mlib.readlinen.ch]
    cmp       rax,	-1
    jnz       L541
L542:
    xor       eax,	eax
    mov       r10,	[rbp + mlib.readlinen.p]
    mov       [r10],	al
    jmp       L533
L541:
L540:
    mov       rax,	[rbp + mlib.readlinen.p]
    inc       qword [rbp + mlib.readlinen.p]
    mov       r10b,	[rbp + mlib.readlinen.ch]
    mov       [rax],	r10b
    inc       qword [rbp + mlib.readlinen.n]
    mov       rax,	[rbp + mlib.readlinen.size]
    sub       rax,	2
    mov       r10,	[rbp + mlib.readlinen.n]
    cmp       r10,	rax
    jl        L544
    xor       eax,	eax
    mov       r10,	[rbp + mlib.readlinen.p]
    mov       [r10],	al
    jmp       L533
L544:
L543:
    jmp       L538
L539:
L537:
L536:
    xor       eax,	eax
    mov       r10,	[rbp + mlib.readlinen.buffer]
    mov       [r10],	al
    mov       rax,	[rbp + mlib.readlinen.size]
    sub       rax,	2
    mov       rcx,	[rbp + mlib.readlinen.buffer]
    mov       rdx,	rax
    mov       r8,	[rbp + mlib.readlinen.handlex]
    call      fgets
    cmp       rax,	0
    jnz       L546
    jmp       L533
L546:
L545:
    mov       rcx,	[rbp + mlib.readlinen.buffer]
    call      strlen
    mov       [rbp + mlib.readlinen.n],	rax
    mov       rax,	[rbp + mlib.readlinen.n]
    cmp       rax,	0
    jnz       L548
    jmp       L533
L548:
L547:
    mov       rax,	[rbp + mlib.readlinen.buffer]
    mov       r10,	[rbp + mlib.readlinen.n]
    lea       rax,	[rax + r10]
    sub       rax,	1
    mov       [rbp + mlib.readlinen.p],	rax
    xor       eax,	eax
    mov       [rbp + mlib.readlinen.crseen],	al
    jmp       L550
L549:
    mov       rax,	[rbp + mlib.readlinen.p]
    movzx     r10,	byte [rax]
    cmp       r10,	13
    jz        L554
    mov       rax,	[rbp + mlib.readlinen.p]
    movzx     r10,	byte [rax]
    cmp       r10,	10
    jnz       L553
L554:
    mov       al,	1
    mov       [rbp + mlib.readlinen.crseen],	al
L553:
L552:
    mov       rax,	[rbp + mlib.readlinen.p]
    dec       qword [rbp + mlib.readlinen.p]
    xor       r10d,	r10d
    mov       [rax],	r10b
L550:
    mov       rax,	[rbp + mlib.readlinen.p]
    cmp       rax,	[rbp + mlib.readlinen.buffer]
    jb        L555
    mov       rax,	[rbp + mlib.readlinen.p]
    movzx     r10,	byte [rax]
    cmp       r10,	13
    jz        L549
    mov       rax,	[rbp + mlib.readlinen.p]
    movzx     r10,	byte [rax]
    cmp       r10,	10
    jz        L549
L555:
L551:
    movzx     rax,	byte [rbp + mlib.readlinen.crseen]
    test      rax,	rax
    jnz       L557
    mov       rax,	[rbp + mlib.readlinen.n]
    add       rax,	4
    cmp       rax,	[rbp + mlib.readlinen.size]
    jle       L557
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mlib.readlinen.size]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + mlib.readlinen.n]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5477]
    call      mlib.abortprogram
L557:
L556:
L533:
;---------------
    add       rsp,	176
    pop       rbp
    ret       
;End 
;Proc iconvlcn
mlib.iconvlcn:
;>>
    %define mlib.iconvlcn.s 16
    %define mlib.iconvlcn.n 24
    %define mlib.iconvlcn.av_1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.iconvlcn.n]
    mov       [rbp + mlib.iconvlcn.av_1],	rax
    mov       rax,	[rbp + mlib.iconvlcn.av_1]
    cmp       rax,	0
    jle       L561
L559:
    mov       rax,	[rbp + mlib.iconvlcn.s]
    movzx     r10,	byte [rax]
    mov       rcx,	r10
    call      tolower
    movsxd    rax,	eax
    mov       r10,	[rbp + mlib.iconvlcn.s]
    mov       [r10],	al
    inc       qword [rbp + mlib.iconvlcn.s]
L560:
    dec       qword [rbp + mlib.iconvlcn.av_1]
    jnz       L559
L561:
L558:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc iconvucn
mlib.iconvucn:
;>>
    %define mlib.iconvucn.s 16
    %define mlib.iconvucn.n 24
    %define mlib.iconvucn.av_1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.iconvucn.n]
    mov       [rbp + mlib.iconvucn.av_1],	rax
    mov       rax,	[rbp + mlib.iconvucn.av_1]
    cmp       rax,	0
    jle       L565
L563:
    mov       rax,	[rbp + mlib.iconvucn.s]
    movzx     r10,	byte [rax]
    mov       rcx,	r10
    call      toupper
    movsxd    rax,	eax
    mov       r10,	[rbp + mlib.iconvucn.s]
    mov       [r10],	al
    inc       qword [rbp + mlib.iconvucn.s]
L564:
    dec       qword [rbp + mlib.iconvucn.av_1]
    jnz       L563
L565:
L562:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc convlcstring
mlib.convlcstring:
;>>
    %define mlib.convlcstring.s 16
    %define mlib.convlcstring.s0 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.convlcstring.s]
    mov       [rbp + mlib.convlcstring.s0],	rax
    jmp       L568
L567:
    mov       rax,	[rbp + mlib.convlcstring.s]
    movzx     r10,	byte [rax]
    mov       rcx,	r10
    call      tolower
    movsxd    rax,	eax
    mov       r10,	[rbp + mlib.convlcstring.s]
    mov       [r10],	al
    inc       qword [rbp + mlib.convlcstring.s]
L568:
    mov       rax,	[rbp + mlib.convlcstring.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L567
L569:
    mov       rax,	[rbp + mlib.convlcstring.s0]
L566:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc convucstring
mlib.convucstring:
;>>
    %define mlib.convucstring.s 16
    %define mlib.convucstring.s0 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.convucstring.s]
    mov       [rbp + mlib.convucstring.s0],	rax
    jmp       L572
L571:
    mov       rax,	[rbp + mlib.convucstring.s]
    movzx     r10,	byte [rax]
    mov       rcx,	r10
    call      toupper
    movsxd    rax,	eax
    mov       r10,	[rbp + mlib.convucstring.s]
    mov       [r10],	al
    inc       qword [rbp + mlib.convucstring.s]
L572:
    mov       rax,	[rbp + mlib.convucstring.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L571
L573:
    mov       rax,	[rbp + mlib.convucstring.s0]
L570:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc changeext
mlib.changeext:
;>>
    %define mlib.changeext.s 16
    %define mlib.changeext.newext 24
    %define mlib.changeext.newext2 -32
    %define mlib.changeext.sext -40
    %define mlib.changeext.n -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mlib.changeext.newfile]
    mov       rcx,	rax
    mov       rdx,	[rbp + mlib.changeext.s]
    call      strcpy
    mov       rax,	[rbp + mlib.changeext.newext]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jz        L576
    cmp       r10,	46
    jz        L577
    jmp       L578
L576:
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2],	al
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2+1],	al
    jmp       L575
L577:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	[rbp + mlib.changeext.newext]
    call      strcpy
    jmp       L575
L578:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    lea       rdx,	[rel L5478]
    call      strcpy
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	[rbp + mlib.changeext.newext]
    call      strcat
L575:
    mov       rcx,	[rbp + mlib.changeext.s]
    mov       rdx,	1
    call      mlib.extractext
    mov       [rbp + mlib.changeext.sext],	rax
    mov       rax,	[rbp + mlib.changeext.sext]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jz        L580
    cmp       r10,	46
    jz        L581
    jmp       L582
L580:
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L579
L581:
    lea       rax,	[rbp + mlib.changeext.newext2+1]
    lea       r10,	[mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L579
L582:
    mov       rax,	[rbp + mlib.changeext.sext]
    sub       rax,	[rbp + mlib.changeext.s]
    sub       rax,	2
    mov       [rbp + mlib.changeext.n],	rax
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[mlib.changeext.newfile]
    mov       r11,	[rbp + mlib.changeext.n]
    lea       r10,	[r10 + r11]
    lea       r10,	[r10+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
L579:
    lea       rax,	[mlib.changeext.newfile]
L574:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc extractext
mlib.extractext:
;>>
    %define mlib.extractext.s 16
    %define mlib.extractext.period 24
    %define mlib.extractext.t -8
    %define mlib.extractext.u -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.extractext.s]
    call      mlib.extractfile
    mov       [rbp + mlib.extractext.t],	rax
    mov       rax,	[rbp + mlib.extractext.t]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L585
    lea       rax,	[rel L5479]
    jmp       L583
L585:
L584:
    mov       rcx,	[rbp + mlib.extractext.t]
    call      strlen
    mov       r10,	[rbp + mlib.extractext.t]
    lea       r10,	[r10 + rax]
    sub       r10,	1
    mov       [rbp + mlib.extractext.u],	r10
    jmp       L587
L586:
    mov       rax,	[rbp + mlib.extractext.u]
    movzx     r10,	byte [rax]
    cmp       r10,	46
    jnz       L590
    mov       rax,	[rbp + mlib.extractext.u]
    movzx     r10,	byte [rax+1]
    cmp       r10,	0
    jnz       L592
    mov       rax,	[rbp + mlib.extractext.period]
    test      rax,	rax
    jz        L594
    lea       rax,	[rel L5480]
    jmp       L593
L594:
    lea       rax,	[rel L5481]
L593:
    jmp       L583
L592:
L591:
    mov       rax,	[rbp + mlib.extractext.u]
    lea       rax,	[rax+1]
    jmp       L583
L590:
L589:
    dec       qword [rbp + mlib.extractext.u]
L587:
    mov       rax,	[rbp + mlib.extractext.u]
    cmp       rax,	[rbp + mlib.extractext.t]
    jae       L586
L588:
    lea       rax,	[rel L5481]
L583:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc extractpath
mlib.extractpath:
;>>
    %define mlib.extractpath.s 16
    %define mlib.extractpath.t -8
    %define mlib.extractpath.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.extractpath.s]
    call      strlen
    mov       r10,	[rbp + mlib.extractpath.s]
    lea       r10,	[r10 + rax]
    sub       r10,	1
    mov       [rbp + mlib.extractpath.t],	r10
    jmp       L597
L596:
    mov       rax,	[rbp + mlib.extractpath.t]
    movzx     r10,	byte [rax]
    cmp       r10,	92
    jz        L600
    cmp       r10,	47
    jz        L600
    cmp       r10,	58
    jz        L600
    jmp       L601
L600:
    mov       rax,	[rbp + mlib.extractpath.t]
    sub       rax,	[rbp + mlib.extractpath.s]
    add       rax,	1
    mov       [rbp + mlib.extractpath.n],	rax
    lea       rcx,	[mlib.extractpath.str]
    mov       rdx,	[rbp + mlib.extractpath.s]
    mov       r8,	[rbp + mlib.extractpath.n]
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractpath.str]
    mov       r11,	[rbp + mlib.extractpath.n]
    mov       [r10 + r11],	al
    lea       rax,	[mlib.extractpath.str]
    jmp       L595
L601:
L599:
    dec       qword [rbp + mlib.extractpath.t]
L597:
    mov       rax,	[rbp + mlib.extractpath.t]
    cmp       rax,	[rbp + mlib.extractpath.s]
    jae       L596
L598:
    lea       rax,	[rel L5481]
L595:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc extractfile
mlib.extractfile:
;>>
    %define mlib.extractfile.s 16
    %define mlib.extractfile.t -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.extractfile.s]
    call      mlib.extractpath
    mov       [rbp + mlib.extractfile.t],	rax
    mov       rax,	[rbp + mlib.extractfile.t]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L604
    mov       rax,	[rbp + mlib.extractfile.s]
    jmp       L602
L604:
L603:
    mov       rcx,	[rbp + mlib.extractfile.t]
    call      strlen
    mov       r10,	[rbp + mlib.extractfile.s]
    lea       r10,	[r10 + rax]
    mov       rax,	r10
L602:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc extractbasefile
mlib.extractbasefile:
;>>
    %define mlib.extractbasefile.s 16
    %define mlib.extractbasefile.f -8
    %define mlib.extractbasefile.e -16
    %define mlib.extractbasefile.n -24
    %define mlib.extractbasefile.flen -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.extractbasefile.s]
    call      mlib.extractfile
    mov       [rbp + mlib.extractbasefile.f],	rax
    mov       rcx,	[rbp + mlib.extractbasefile.f]
    call      strlen
    mov       [rbp + mlib.extractbasefile.flen],	rax
    mov       rax,	[rbp + mlib.extractbasefile.flen]
    cmp       rax,	0
    jnz       L607
    lea       rax,	[rel L5481]
    jmp       L605
L607:
L606:
    mov       rcx,	[rbp + mlib.extractbasefile.f]
    xor       edx,	edx
    call      mlib.extractext
    mov       [rbp + mlib.extractbasefile.e],	rax
    mov       rax,	[rbp + mlib.extractbasefile.e]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L609
    mov       rcx,	[rbp + mlib.extractbasefile.e]
    call      strlen
    mov       r10,	[rbp + mlib.extractbasefile.flen]
    sub       r10,	rax
    sub       r10,	1
    mov       [rbp + mlib.extractbasefile.n],	r10
    lea       rcx,	[mlib.extractbasefile.str]
    mov       rdx,	[rbp + mlib.extractbasefile.f]
    mov       r8,	[rbp + mlib.extractbasefile.n]
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractbasefile.str]
    mov       r11,	[rbp + mlib.extractbasefile.n]
    mov       [r10 + r11],	al
    lea       rax,	[mlib.extractbasefile.str]
    jmp       L605
L609:
L608:
    mov       rax,	[rbp + mlib.extractbasefile.f]
    mov       r10,	[rbp + mlib.extractbasefile.flen]
    lea       rax,	[rax + r10]
    sub       rax,	1
    movzx     r10,	byte [rax]
    cmp       r10,	46
    jnz       L611
    mov       rax,	[rbp + mlib.extractbasefile.flen]
    sub       rax,	1
    lea       rcx,	[mlib.extractbasefile.str]
    mov       rdx,	[rbp + mlib.extractbasefile.f]
    mov       r8,	rax
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractbasefile.str]
    mov       r11,	[rbp + mlib.extractbasefile.flen]
    mov       [r10 + r11-1],	al
    lea       rax,	[mlib.extractbasefile.str]
    jmp       L605
L611:
L610:
    mov       rax,	[rbp + mlib.extractbasefile.f]
L605:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc addext
mlib.addext:
;>>
    %define mlib.addext.s 16
    %define mlib.addext.newext 24
    %define mlib.addext.sext -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.addext.s]
    mov       rdx,	1
    call      mlib.extractext
    mov       [rbp + mlib.addext.sext],	rax
    mov       rax,	[rbp + mlib.addext.sext]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L614
    mov       rcx,	[rbp + mlib.addext.s]
    mov       rdx,	[rbp + mlib.addext.newext]
    call      mlib.changeext
    jmp       L612
L614:
L613:
    mov       rax,	[rbp + mlib.addext.s]
L612:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_alloc32
mlib.pcm_alloc32:
;>>
    %define mlib.pcm_alloc32.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	32
    mov       [mlib.allocbytes],	rax
    mov       rax,	32
    add       [mlib.smallmemtotal],	rax
    mov       rax,	[mlib.freelist+16]
    mov       [rbp + mlib.pcm_alloc32.p],	rax
    test      rax,	rax
    jz        L617
    mov       rax,	[mlib.freelist+16]
    mov       r10,	[rax]
    mov       [mlib.freelist+16],	r10
    mov       rax,	[rbp + mlib.pcm_alloc32.p]
    jmp       L615
L617:
L616:
    mov       rcx,	32
    call      mlib.pcm_alloc
L615:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcm_free32
mlib.pcm_free32:
;>>
    %define mlib.pcm_free32.p 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	32
    sub       [mlib.smallmemtotal],	rax
    mov       rax,	[mlib.freelist+16]
    mov       r10,	[rbp + mlib.pcm_free32.p]
    mov       [r10],	rax
    mov       rax,	[rbp + mlib.pcm_free32.p]
    mov       [mlib.freelist+16],	rax
L618:
;---------------
    pop       rbp
    ret       
;End 
;Proc outbyte
mlib.outbyte:
;>>
    %define mlib.outbyte.f 16
    %define mlib.outbyte.x 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outbyte.x]
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	[rbp + mlib.outbyte.f]
    call      fwrite
L619:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc outword16
mlib.outword16:
;>>
    %define mlib.outword16.f 16
    %define mlib.outword16.x 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outword16.x]
    mov       rdx,	2
    mov       r8,	1
    mov       r9,	[rbp + mlib.outword16.f]
    call      fwrite
L620:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc outword32
mlib.outword32:
;>>
    %define mlib.outword32.f 16
    %define mlib.outword32.x 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outword32.x]
    mov       rdx,	4
    mov       r8,	1
    mov       r9,	[rbp + mlib.outword32.f]
    call      fwrite
L621:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc outword64
mlib.outword64:
;>>
    %define mlib.outword64.f 16
    %define mlib.outword64.x 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outword64.x]
    mov       rdx,	8
    mov       r8,	1
    mov       r9,	[rbp + mlib.outword64.f]
    call      fwrite
L622:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc outstring
mlib.outstring:
;>>
    %define mlib.outstring.f 16
    %define mlib.outstring.s 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.outstring.s]
    call      strlen
    add       rax,	1
    mov       rcx,	[rbp + mlib.outstring.s]
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[rbp + mlib.outstring.f]
    call      fwrite
L623:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc outblock
mlib.outblock:
;>>
    %define mlib.outblock.f 16
    %define mlib.outblock.p 24
    %define mlib.outblock.n 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.outblock.p]
    mov       rdx,	[rbp + mlib.outblock.n]
    mov       r8,	1
    mov       r9,	[rbp + mlib.outblock.f]
    call      fwrite
L624:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc myeof
mlib.myeof:
;>>
    %define mlib.myeof.f 16
    %define mlib.myeof.c -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.myeof.f]
    call      fgetc
    movsxd    rax,	eax
    mov       [rbp + mlib.myeof.c],	rax
    mov       rax,	[rbp + mlib.myeof.c]
    cmp       rax,	-1
    jnz       L627
    mov       rax,	1
    jmp       L625
L627:
L626:
    mov       rcx,	[rbp + mlib.myeof.c]
    mov       rdx,	[rbp + mlib.myeof.f]
    call      ungetc
    xor       eax,	eax
L625:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc strbuffer_add
mlib.strbuffer_add:
;>>
    %define mlib.strbuffer_add.dest 16
    %define mlib.strbuffer_add.s 24
    %define mlib.strbuffer_add.n 32
    %define mlib.strbuffer_add.newlen -8
    %define mlib.strbuffer_add.oldlen -16
    %define mlib.strbuffer_add.newptr -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mlib.strbuffer_add.n]
    cmp       rax,	-1
    jnz       L630
    mov       rcx,	[rbp + mlib.strbuffer_add.s]
    call      strlen
    mov       [rbp + mlib.strbuffer_add.n],	rax
L630:
L629:
    mov       rax,	[rbp + mlib.strbuffer_add.dest]
    movsxd    r10,	dword [rax+8]
    mov       [rbp + mlib.strbuffer_add.oldlen],	r10
    mov       rax,	[rbp + mlib.strbuffer_add.oldlen]
    cmp       rax,	0
    jnz       L632
    mov       rax,	[rbp + mlib.strbuffer_add.n]
    add       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    mov       [r10],	rax
    mov       eax,	[mlib.allocbytes]
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    mov       [r10+12],	eax
    mov       eax,	[rbp + mlib.strbuffer_add.n]
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    mov       [r10+8],	eax
    mov       rax,	[rbp + mlib.strbuffer_add.dest]
    mov       r10,	[rax]
    mov       rcx,	r10
    mov       rdx,	[rbp + mlib.strbuffer_add.s]
    mov       r8,	[rbp + mlib.strbuffer_add.n]
    call      memcpy
    mov       rax,	[rbp + mlib.strbuffer_add.dest]
    mov       r10,	[rax]
    xor       eax,	eax
    mov       r11,	[rbp + mlib.strbuffer_add.n]
    mov       [r10 + r11],	al
    jmp       L628
L632:
L631:
    mov       rax,	[rbp + mlib.strbuffer_add.oldlen]
    add       rax,	[rbp + mlib.strbuffer_add.n]
    mov       [rbp + mlib.strbuffer_add.newlen],	rax
    mov       rax,	[rbp + mlib.strbuffer_add.newlen]
    add       rax,	1
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    movsxd    r11,	dword [r10+12]
    cmp       rax,	r11
    jle       L634
    mov       rax,	[rbp + mlib.strbuffer_add.newlen]
    add       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mlib.strbuffer_add.newptr],	rax
    mov       rax,	[rbp + mlib.strbuffer_add.dest]
    mov       r10,	[rax]
    mov       rcx,	[rbp + mlib.strbuffer_add.newptr]
    mov       rdx,	r10
    mov       r8,	[rbp + mlib.strbuffer_add.oldlen]
    call      memcpy
    mov       rax,	[rbp + mlib.strbuffer_add.newptr]
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    mov       [r10],	rax
    mov       eax,	[mlib.allocbytes]
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    mov       [r10+12],	eax
L634:
L633:
    mov       rax,	[rbp + mlib.strbuffer_add.dest]
    mov       r10,	[rax]
    mov       rax,	[rbp + mlib.strbuffer_add.oldlen]
    lea       r10,	[r10 + rax]
    mov       rcx,	r10
    mov       rdx,	[rbp + mlib.strbuffer_add.s]
    mov       r8,	[rbp + mlib.strbuffer_add.n]
    call      memcpy
    mov       rax,	[rbp + mlib.strbuffer_add.dest]
    mov       r10,	[rax]
    xor       eax,	eax
    mov       r11,	[rbp + mlib.strbuffer_add.newlen]
    mov       [r10 + r11],	al
    mov       eax,	[rbp + mlib.strbuffer_add.newlen]
    mov       r10,	[rbp + mlib.strbuffer_add.dest]
    mov       [r10+8],	eax
L628:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc gs_init
mlib.gs_init:
;>>
    %define mlib.gs_init.dest 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.gs_init.dest]
    mov       rdx,	16
    call      mlib.pcm_clearmem
L635:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_free
mlib.gs_free:
;>>
    %define mlib.gs_free.dest 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.gs_free.dest]
    movsxd    r10,	dword [rax+12]
    test      r10,	r10
    jz        L638
    mov       rax,	[rbp + mlib.gs_free.dest]
    movsxd    r10,	dword [rax+12]
    mov       rax,	[rbp + mlib.gs_free.dest]
    mov       r11,	[rax]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mlib.pcm_free
L638:
L637:
L636:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_str
mlib.gs_str:
;>>
    %define mlib.gs_str.dest 16
    %define mlib.gs_str.s 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.gs_str.dest]
    mov       rdx,	[rbp + mlib.gs_str.s]
    mov       r8,	-1
    call      mlib.strbuffer_add
L639:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_char
mlib.gs_char:
;>>
    %define mlib.gs_char.dest 16
    %define mlib.gs_char.c 24
    %define mlib.gs_char.s -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       al,	[rbp + mlib.gs_char.c]
    mov       [rbp + mlib.gs_char.s],	al
    xor       eax,	eax
    mov       [rbp + mlib.gs_char.s+1],	al
    mov       rcx,	[rbp + mlib.gs_char.dest]
    lea       rdx,	[rbp + mlib.gs_char.s]
    mov       r8,	1
    call      mlib.strbuffer_add
L640:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc gs_strn
mlib.gs_strn:
;>>
    %define mlib.gs_strn.dest 16
    %define mlib.gs_strn.s 24
    %define mlib.gs_strn.length 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.gs_strn.dest]
    mov       rdx,	[rbp + mlib.gs_strn.s]
    mov       r8,	[rbp + mlib.gs_strn.length]
    call      mlib.strbuffer_add
L641:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_strvar
mlib.gs_strvar:
;>>
    %define mlib.gs_strvar.dest 16
    %define mlib.gs_strvar.s 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.gs_strvar.s]
    mov       r10,	[rax]
    mov       rcx,	[rbp + mlib.gs_strvar.dest]
    mov       rdx,	r10
    mov       r8,	-1
    call      mlib.strbuffer_add
L642:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_strint
mlib.gs_strint:
;>>
    %define mlib.gs_strint.dest 16
    %define mlib.gs_strint.a 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.gs_strint.a]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rbp + mlib.gs_strint.dest]
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
L643:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_strln
mlib.gs_strln:
;>>
    %define mlib.gs_strln.dest 16
    %define mlib.gs_strln.s 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.gs_strln.dest]
    mov       rdx,	[rbp + mlib.gs_strln.s]
    call      mlib.gs_str
    mov       rcx,	[rbp + mlib.gs_strln.dest]
    call      mlib.gs_line
L644:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_strsp
mlib.gs_strsp:
;>>
    %define mlib.gs_strsp.dest 16
    %define mlib.gs_strsp.s 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.gs_strsp.dest]
    mov       rdx,	[rbp + mlib.gs_strsp.s]
    call      mlib.gs_str
    mov       rcx,	[rbp + mlib.gs_strsp.dest]
    lea       rdx,	[rel L5482]
    call      mlib.gs_str
L645:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_line
mlib.gs_line:
;>>
    %define mlib.gs_line.dest 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mlib.gs_line.dest]
    lea       rdx,	[rel L5483]
    mov       r8,	-1
    call      mlib.strbuffer_add
L646:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_getcol
mlib.gs_getcol:
;>>
    %define mlib.gs_getcol.dest 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.gs_getcol.dest]
    movsxd    r10,	dword [rax+8]
    mov       rax,	r10
L647:
;---------------
    pop       rbp
    ret       
;End 
;Proc gs_leftstr
mlib.gs_leftstr:
;>>
    %define mlib.gs_leftstr.dest 16
    %define mlib.gs_leftstr.s 24
    %define mlib.gs_leftstr.w 32
    %define mlib.gs_leftstr.padch 40
    %define mlib.gs_leftstr.col -8
    %define mlib.gs_leftstr.i -16
    %define mlib.gs_leftstr.n -24
    %define mlib.gs_leftstr.slen -32
    %define mlib.gs_leftstr.str -2592
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2624
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mlib.gs_leftstr.dest]
    movsxd    r10,	dword [rax+8]
    mov       [rbp + mlib.gs_leftstr.col],	r10
    lea       rcx,	[rbp + mlib.gs_leftstr.str]
    mov       rdx,	[rbp + mlib.gs_leftstr.s]
    call      strcpy
    mov       rcx,	[rbp + mlib.gs_leftstr.s]
    call      strlen
    mov       [rbp + mlib.gs_leftstr.slen],	rax
    mov       rax,	[rbp + mlib.gs_leftstr.w]
    sub       rax,	[rbp + mlib.gs_leftstr.slen]
    mov       [rbp + mlib.gs_leftstr.n],	rax
    mov       rax,	[rbp + mlib.gs_leftstr.n]
    cmp       rax,	0
    jle       L650
    mov       rax,	1
    mov       [rbp + mlib.gs_leftstr.i],	rax
    mov       rax,	[rbp + mlib.gs_leftstr.n]
    cmp       rax,	1
    jl        L653
L651:
    mov       rax,	[rbp + mlib.gs_leftstr.slen]
    add       rax,	[rbp + mlib.gs_leftstr.i]
    mov       r10b,	[rbp + mlib.gs_leftstr.padch]
    mov       [rbp + rax + mlib.gs_leftstr.str-1],	r10b
L652:
    mov       rax,	[rbp + mlib.gs_leftstr.i]
    inc       rax
    mov       [rbp + mlib.gs_leftstr.i],	rax
    cmp       rax,	[rbp + mlib.gs_leftstr.n]
    jle       L651
L653:
    mov       rax,	[rbp + mlib.gs_leftstr.slen]
    add       rax,	[rbp + mlib.gs_leftstr.n]
    xor       r10d,	r10d
    mov       [rbp + rax + mlib.gs_leftstr.str],	r10b
L650:
L649:
    mov       rcx,	[rbp + mlib.gs_leftstr.dest]
    lea       rdx,	[rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
L648:
;---------------
    add       rsp,	2624
    pop       rbp
    ret       
;End 
;Proc gs_leftint
mlib.gs_leftint:
;>>
    %define mlib.gs_leftint.dest 16
    %define mlib.gs_leftint.a 24
    %define mlib.gs_leftint.w 32
    %define mlib.gs_leftint.padch 40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	[rbp + mlib.gs_leftint.a]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rbp + mlib.gs_leftint.dest]
    mov       rdx,	rax
    mov       r8,	[rbp + mlib.gs_leftint.w]
    mov       r9,	[rbp + mlib.gs_leftint.padch]
    call      mlib.gs_leftstr
L654:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gs_padto
mlib.gs_padto:
;>>
    %define mlib.gs_padto.dest 16
    %define mlib.gs_padto.col 24
    %define mlib.gs_padto.ch 32
    %define mlib.gs_padto.n -8
    %define mlib.gs_padto.str -2568
    %define mlib.gs_padto.i -2576
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2608
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mlib.gs_padto.dest]
    movsxd    r10,	dword [rax+8]
    mov       rax,	[rbp + mlib.gs_padto.col]
    sub       rax,	r10
    mov       [rbp + mlib.gs_padto.n],	rax
    mov       rax,	[rbp + mlib.gs_padto.n]
    cmp       rax,	0
    jg        L657
    jmp       L655
L657:
L656:
    mov       rax,	1
    mov       [rbp + mlib.gs_padto.i],	rax
    mov       rax,	[rbp + mlib.gs_padto.n]
    cmp       rax,	1
    jl        L660
L658:
    mov       al,	[rbp + mlib.gs_padto.ch]
    mov       r10,	[rbp + mlib.gs_padto.i]
    mov       [rbp + r10 + mlib.gs_padto.str-1],	al
L659:
    mov       rax,	[rbp + mlib.gs_padto.i]
    inc       rax
    mov       [rbp + mlib.gs_padto.i],	rax
    cmp       rax,	[rbp + mlib.gs_padto.n]
    jle       L658
L660:
    xor       eax,	eax
    mov       r10,	[rbp + mlib.gs_padto.n]
    mov       [rbp + r10 + mlib.gs_padto.str],	al
    mov       rcx,	[rbp + mlib.gs_padto.dest]
    lea       rdx,	[rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L655:
;---------------
    add       rsp,	2608
    pop       rbp
    ret       
;End 
;Proc gs_println
mlib.gs_println:
;>>
    %define mlib.gs_println.dest 16
    %define mlib.gs_println.f 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.gs_println.dest]
    movsxd    r10,	dword [rax+8]
    cmp       r10,	0
    jnz       L663
    jmp       L661
L663:
L662:
    mov       rax,	[rbp + mlib.gs_println.dest]
    mov       r10,	[rax]
    mov       rax,	[rbp + mlib.gs_println.dest]
    movsxd    r11,	dword [rax+8]
    xor       eax,	eax
    mov       [r10 + r11],	al
    mov       rax,	[rbp + mlib.gs_println.f]
    cmp       rax,	0
    jnz       L665
    call      msys.m$print_startcon
    mov       rax,	[rbp + mlib.gs_println.dest]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rel L5484]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L664
L665:
    mov       rcx,	[rbp + mlib.gs_println.f]
    call      msys.m$print_startfile
    mov       rax,	[rbp + mlib.gs_println.dest]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rel L5484]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L664:
L661:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc nextcmdparamnew
mlib.nextcmdparamnew:
;>>
    %define mlib.nextcmdparamnew.paramno 16
    %define mlib.nextcmdparamnew.name 24
    %define mlib.nextcmdparamnew.value 32
    %define mlib.nextcmdparamnew.defext 40
    %define mlib.nextcmdparamnew.q -8
    %define mlib.nextcmdparamnew.item -16
    %define mlib.nextcmdparamnew.fileext -24
    %define mlib.nextcmdparamnew.rest -32
    %define mlib.nextcmdparamnew.length -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
;reenter:
L667:
    xor       eax,	eax
    mov       r10,	[rbp + mlib.nextcmdparamnew.value]
    mov       [r10],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mlib.nextcmdparamnew.name]
    mov       [r10],	rax
    mov       rax,	[mlib.nextcmdparamnew.infile]
    test      rax,	rax
    jz        L669
    lea       rcx,	[mlib.nextcmdparamnew.fileptr]
    lea       rdx,	[rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    cmp       rax,	0
    jnz       L671
    mov       rcx,	[mlib.nextcmdparamnew.filestart]
    call      free
    xor       eax,	eax
    mov       [mlib.nextcmdparamnew.infile],	rax
    jmp       L667
L671:
L670:
    jmp       L668
L669:
    mov       rax,	[rbp + mlib.nextcmdparamnew.paramno]
    mov       r10,	[rax]
    cmp       r10,	[msys.ncmdparams]
    jle       L673
    xor       eax,	eax
    jmp       L666
L673:
L672:
    mov       rax,	[rbp + mlib.nextcmdparamnew.paramno]
    mov       r10,	[rax]
    mov       rax,	[msys.cmdparams]
    mov       r11,	[rax + r10*8]
    mov       [rbp + mlib.nextcmdparamnew.item],	r11
    mov       rax,	[rbp + mlib.nextcmdparamnew.paramno]
    inc       qword [rax]
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       [rbp + mlib.nextcmdparamnew.length],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     r10,	byte [rax]
    cmp       r10,	64
    jnz       L675
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    lea       rax,	[rax+1]
    mov       rcx,	rax
    call      mlib.readfile
    mov       [mlib.nextcmdparamnew.fileptr],	rax
    mov       [mlib.nextcmdparamnew.filestart],	rax
    mov       rax,	[mlib.nextcmdparamnew.filestart]
    cmp       rax,	0
    jnz       L677
    call      msys.m$print_startcon
    lea       rcx,	[rel L5485]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	7
    call      exit
L677:
L676:
    mov       rax,	1
    mov       [mlib.nextcmdparamnew.infile],	rax
    jmp       L667
L675:
L674:
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     r10,	byte [rax]
    cmp       r10,	58
    jnz       L679
    mov       al,	1
    mov       [mlib.nextcmdparamnew.colonseen],	al
    mov       rax,	4
    jmp       L666
L679:
L678:
L668:
    xor       eax,	eax
    mov       r10,	[rbp + mlib.nextcmdparamnew.value]
    mov       [r10],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     r10,	byte [rax]
    cmp       r10,	45
    jnz       L681
    movzx     rax,	byte [mlib.nextcmdparamnew.colonseen]
    test      rax,	rax
    jz        L683
    xor       eax,	eax
    jmp       L682
L683:
    mov       rax,	1
L682:
    mov       r10,	[rbp + mlib.nextcmdparamnew.item]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mlib.nextcmdparamnew.name]
    mov       [rax],	r10
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	58
    call      strchr
    mov       [rbp + mlib.nextcmdparamnew.q],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.q]
    test      rax,	rax
    jnz       L685
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	61
    call      strchr
    mov       [rbp + mlib.nextcmdparamnew.q],	rax
L685:
L684:
    mov       rax,	[rbp + mlib.nextcmdparamnew.q]
    test      rax,	rax
    jz        L687
    mov       rax,	[rbp + mlib.nextcmdparamnew.q]
    lea       rax,	[rax+1]
    mov       r10,	[rbp + mlib.nextcmdparamnew.value]
    mov       [r10],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mlib.nextcmdparamnew.q]
    mov       [r10],	al
L687:
L686:
    movzx     rax,	byte [mlib.nextcmdparamnew.colonseen]
    test      rax,	rax
    jz        L689
    mov       rax,	5
    jmp       L688
L689:
    mov       rax,	1
L688:
    jmp       L666
L681:
L680:
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    xor       edx,	edx
    call      mlib.extractext
    mov       [rbp + mlib.nextcmdparamnew.fileext],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    mov       r10,	[rbp + mlib.nextcmdparamnew.name]
    mov       [r10],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.fileext]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L691
    mov       rax,	[rbp + mlib.nextcmdparamnew.name]
    mov       r10,	[rax]
    lea       rcx,	[mlib.nextcmdparamnew.str]
    mov       rdx,	r10
    call      strcpy
    mov       rax,	[rbp + mlib.nextcmdparamnew.defext]
    test      rax,	rax
    jz        L693
    movzx     rax,	byte [mlib.nextcmdparamnew.colonseen]
    test      rax,	rax
    jnz       L693
    lea       rcx,	[mlib.nextcmdparamnew.str]
    mov       rdx,	[rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       r10,	[rbp + mlib.nextcmdparamnew.name]
    mov       [r10],	rax
L693:
L692:
    jmp       L690
L691:
    mov       rcx,	[rbp + mlib.nextcmdparamnew.fileext]
    lea       rdx,	[rel L5486]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L695
    mov       rcx,	[rbp + mlib.nextcmdparamnew.fileext]
    lea       rdx,	[rel L5487]
    call      mlib.eqstring
    test      rax,	rax
    jz        L694
L695:
    movzx     rax,	byte [mlib.nextcmdparamnew.colonseen]
    test      rax,	rax
    jz        L697
    mov       rax,	5
    jmp       L696
L697:
    mov       rax,	3
L696:
    jmp       L666
L694:
L690:
    movzx     rax,	byte [mlib.nextcmdparamnew.colonseen]
    test      rax,	rax
    jz        L699
    mov       rax,	5
    jmp       L698
L699:
    mov       rax,	2
L698:
L666:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc readnextfileitem
mlib.readnextfileitem:
;>>
    %define mlib.readnextfileitem.fileptr 16
    %define mlib.readnextfileitem.item 24
    %define mlib.readnextfileitem.p -8
    %define mlib.readnextfileitem.pstart -16
    %define mlib.readnextfileitem.pend -24
    %define mlib.readnextfileitem.n -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.readnextfileitem.fileptr]
    mov       r10,	[rax]
    mov       [rbp + mlib.readnextfileitem.p],	r10
;reenter:
L701:
L702:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	32
    jz        L705
    cmp       r10,	9
    jz        L705
    cmp       r10,	13
    jz        L705
    cmp       r10,	10
    jz        L705
    cmp       r10,	26
    jz        L706
    cmp       r10,	0
    jz        L706
    jmp       L707
L705:
    inc       qword [rbp + mlib.readnextfileitem.p]
    jmp       L704
L706:
    xor       eax,	eax
    jmp       L700
L707:
    jmp       L703
L704:
    jmp       L702
L703:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	33
    jz        L709
    cmp       r10,	35
    jz        L709
    jmp       L710
L709:
    inc       qword [rbp + mlib.readnextfileitem.p]
L711:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    inc       qword [rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	10
    jz        L713
    cmp       r10,	26
    jz        L714
    cmp       r10,	0
    jz        L714
    jmp       L715
L713:
    jmp       L701
L714:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    sub       rax,	1
    mov       r10,	[rbp + mlib.readnextfileitem.fileptr]
    mov       [r10],	rax
    xor       eax,	eax
    jmp       L700
L715:
    jmp       L711
L712:
L710:
L708:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	34
    jz        L717
    jmp       L718
L717:
    inc       qword [rbp + mlib.readnextfileitem.p]
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    mov       [rbp + mlib.readnextfileitem.pstart],	rax
L719:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jz        L722
    cmp       r10,	26
    jz        L722
    cmp       r10,	34
    jz        L723
    jmp       L724
L722:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5488]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	8
    call      exit
    jmp       L721
L723:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    inc       qword [rbp + mlib.readnextfileitem.p]
    mov       [rbp + mlib.readnextfileitem.pend],	rax
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	44
    jnz       L726
    inc       qword [rbp + mlib.readnextfileitem.p]
L726:
L725:
    jmp       L720
L724:
L721:
    inc       qword [rbp + mlib.readnextfileitem.p]
    jmp       L719
L720:
    jmp       L716
L718:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    mov       [rbp + mlib.readnextfileitem.pstart],	rax
L727:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jz        L730
    cmp       r10,	26
    jz        L730
    cmp       r10,	32
    jz        L731
    cmp       r10,	9
    jz        L731
    cmp       r10,	44
    jz        L731
    cmp       r10,	13
    jz        L731
    cmp       r10,	10
    jz        L731
    jmp       L732
L730:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    mov       [rbp + mlib.readnextfileitem.pend],	rax
    jmp       L728
L731:
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    inc       qword [rbp + mlib.readnextfileitem.p]
    mov       [rbp + mlib.readnextfileitem.pend],	rax
    jmp       L728
L732:
L729:
    inc       qword [rbp + mlib.readnextfileitem.p]
    jmp       L727
L728:
L716:
    mov       rax,	[rbp + mlib.readnextfileitem.pend]
    sub       rax,	[rbp + mlib.readnextfileitem.pstart]
    mov       [rbp + mlib.readnextfileitem.n],	rax
    mov       rax,	[rbp + mlib.readnextfileitem.n]
    cmp       rax,	256
    jl        L734
    call      msys.m$print_startcon
    lea       rcx,	[rel L5489]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	9
    call      exit
L734:
L733:
    lea       rcx,	[mlib.readnextfileitem.str]
    mov       rdx,	[rbp + mlib.readnextfileitem.pstart]
    mov       r8,	[rbp + mlib.readnextfileitem.n]
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.readnextfileitem.str]
    mov       r11,	[rbp + mlib.readnextfileitem.n]
    mov       [r10 + r11],	al
    lea       rax,	[mlib.readnextfileitem.str]
    mov       r10,	[rbp + mlib.readnextfileitem.item]
    mov       [r10],	rax
    mov       rax,	[rbp + mlib.readnextfileitem.p]
    mov       r10,	[rbp + mlib.readnextfileitem.fileptr]
    mov       [r10],	rax
    mov       rax,	1
L700:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc ipadstr
mlib.ipadstr:
;>>
    %define mlib.ipadstr.s 16
    %define mlib.ipadstr.width 24
    %define mlib.ipadstr.padchar 32
    %define mlib.ipadstr.n -8
    %define mlib.ipadstr.av_1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.ipadstr.s]
    call      strlen
    mov       [rbp + mlib.ipadstr.n],	rax
    mov       rax,	[rbp + mlib.ipadstr.width]
    sub       rax,	[rbp + mlib.ipadstr.n]
    mov       [rbp + mlib.ipadstr.av_1],	rax
    mov       rax,	[rbp + mlib.ipadstr.av_1]
    cmp       rax,	0
    jle       L738
L736:
    mov       rcx,	[rbp + mlib.ipadstr.s]
    mov       rdx,	[rbp + mlib.ipadstr.padchar]
    call      strcat
L737:
    dec       qword [rbp + mlib.ipadstr.av_1]
    jnz       L736
L738:
L735:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc padstr
mlib.padstr:
;>>
    %define mlib.padstr.s 16
    %define mlib.padstr.width 24
    %define mlib.padstr.padchar 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    lea       rcx,	[mlib.padstr.str]
    mov       rdx,	[rbp + mlib.padstr.s]
    call      strcpy
    lea       rcx,	[mlib.padstr.str]
    mov       rdx,	[rbp + mlib.padstr.width]
    mov       r8,	[rbp + mlib.padstr.padchar]
    call      mlib.ipadstr
    lea       rax,	[mlib.padstr.str]
L739:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc chr
mlib.chr:
;>>
    %define mlib.chr.c 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       al,	[rbp + mlib.chr.c]
    mov       [mlib.chr.str],	al
    xor       eax,	eax
    mov       [mlib.chr.str+1],	al
    lea       rax,	[mlib.chr.str]
L740:
;---------------
    pop       rbp
    ret       
;End 
;Proc cmpstring
mlib.cmpstring:
;>>
    %define mlib.cmpstring.s 16
    %define mlib.cmpstring.t 24
    %define mlib.cmpstring.res -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.cmpstring.s]
    mov       rdx,	[rbp + mlib.cmpstring.t]
    call      strcmp
    movsxd    rax,	eax
    mov       [rbp + mlib.cmpstring.res],	rax
    cmp       rax,	0
    jge       L743
    mov       rax,	-1
    jmp       L742
L743:
    mov       rax,	[rbp + mlib.cmpstring.res]
    cmp       rax,	0
    jle       L744
    mov       rax,	1
    jmp       L742
L744:
    xor       eax,	eax
L742:
L741:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc cmpstringn
mlib.cmpstringn:
;>>
    %define mlib.cmpstringn.s 16
    %define mlib.cmpstringn.t 24
    %define mlib.cmpstringn.n 32
    %define mlib.cmpstringn.res -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.cmpstringn.s]
    mov       rdx,	[rbp + mlib.cmpstringn.t]
    mov       r8,	[rbp + mlib.cmpstringn.n]
    call      strncmp
    movsxd    rax,	eax
    mov       [rbp + mlib.cmpstringn.res],	rax
    cmp       rax,	0
    jge       L747
    mov       rax,	-1
    jmp       L746
L747:
    mov       rax,	[rbp + mlib.cmpstringn.res]
    cmp       rax,	0
    jle       L748
    mov       rax,	1
    jmp       L746
L748:
    xor       eax,	eax
L746:
L745:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc eqstring
mlib.eqstring:
;>>
    %define mlib.eqstring.s 16
    %define mlib.eqstring.t 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mlib.eqstring.s]
    mov       rdx,	[rbp + mlib.eqstring.t]
    call      strcmp
    movsxd    rax,	eax
    cmp       rax,	0
    setz      al
    movzx     eax,	al
L749:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc cmpbytes
mlib.cmpbytes:
;>>
    %define mlib.cmpbytes.p 16
    %define mlib.cmpbytes.q 24
    %define mlib.cmpbytes.n 32
    %define mlib.cmpbytes.res -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.cmpbytes.p]
    mov       rdx,	[rbp + mlib.cmpbytes.q]
    mov       r8,	[rbp + mlib.cmpbytes.n]
    call      memcmp
    movsxd    rax,	eax
    mov       [rbp + mlib.cmpbytes.res],	rax
    cmp       rax,	0
    jge       L752
    mov       rax,	-1
    jmp       L751
L752:
    mov       rax,	[rbp + mlib.cmpbytes.res]
    cmp       rax,	0
    jle       L753
    mov       rax,	1
    jmp       L751
L753:
    xor       eax,	eax
L751:
L750:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc eqbytes
mlib.eqbytes:
;>>
    %define mlib.eqbytes.p 16
    %define mlib.eqbytes.q 24
    %define mlib.eqbytes.n 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mlib.eqbytes.p]
    mov       rdx,	[rbp + mlib.eqbytes.q]
    mov       r8,	[rbp + mlib.eqbytes.n]
    call      memcmp
    movsxd    rax,	eax
    cmp       rax,	0
    setz      al
    movzx     eax,	al
L754:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mseed
mlib.mseed:
;>>
    %define mlib.mseed.a 16
    %define mlib.mseed.b 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.mseed.a]
    mov       [mlib.seed],	rax
    mov       rax,	[rbp + mlib.mseed.b]
    test      rax,	rax
    jz        L757
    mov       rax,	[rbp + mlib.mseed.b]
    mov       [mlib.seed+8],	rax
    jmp       L756
L757:
    lea       rax,	[mlib.seed]
    lea       rax,	[rax+8]
    mov       r10,	[rbp + mlib.mseed.a]
    xor       [rax],	r10
L756:
L755:
;---------------
    pop       rbp
    ret       
;End 
;Proc mrandom
mlib.mrandom:
;>>
    %define mlib.mrandom.x -8
    %define mlib.mrandom.y -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    mov       rax,	[mlib.seed]
    mov       [rbp + mlib.mrandom.x],	rax
    mov       rax,	[mlib.seed+8]
    mov       [rbp + mlib.mrandom.y],	rax
    mov       rax,	[rbp + mlib.mrandom.y]
    mov       [mlib.seed],	rax
    mov       rax,	[rbp + mlib.mrandom.x]
    shl       rax,	23
    xor       [rbp + mlib.mrandom.x],	rax
    mov       rax,	[rbp + mlib.mrandom.x]
    xor       rax,	[rbp + mlib.mrandom.y]
    mov       r10,	[rbp + mlib.mrandom.x]
    sar       r10,	17
    xor       rax,	r10
    mov       r10,	[rbp + mlib.mrandom.y]
    sar       r10,	26
    xor       rax,	r10
    mov       [mlib.seed+8],	rax
    mov       rax,	[mlib.seed+8]
    add       rax,	[rbp + mlib.mrandom.y]
L758:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc mrandomp
mlib.mrandomp:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mlib.mrandom
    mov       r10,	9223372036854775807
    and       rax,	r10
L759:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mrandomint
mlib.mrandomint:
;>>
    %define mlib.mrandomint.n 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      mlib.mrandomp
    mov       r10,	[rbp + mlib.mrandomint.n]
    cqo       
    idiv      r10
    xchg      rax,	rdx
L760:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mrandomrange
mlib.mrandomrange:
;>>
    %define mlib.mrandomrange.a 16
    %define mlib.mrandomrange.b 24
    %define mlib.mrandomrange.span -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.mrandomrange.b]
    sub       rax,	[rbp + mlib.mrandomrange.a]
    add       rax,	1
    mov       [rbp + mlib.mrandomrange.span],	rax
    mov       rax,	[rbp + mlib.mrandomrange.span]
    cmp       rax,	0
    jg        L763
    xor       eax,	eax
    jmp       L761
L763:
L762:
    call      mlib.mrandomp
    mov       r10,	[rbp + mlib.mrandomrange.span]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	[rbp + mlib.mrandomrange.a]
L761:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mrandomreal
mlib.mrandomreal:
;>>
    %define mlib.mrandomreal.x -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
L765:
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[rel L5490]
    movq      [rbp + mlib.mrandomreal.x],	XMM4
L766:
    movq      XMM4,	[rbp + mlib.mrandomreal.x]
    comisd    XMM4,	[rel L5491]
    jz        L765
L767:
    movq      XMM0,	[rbp + mlib.mrandomreal.x]
L764:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mrandomreal1
mlib.mrandomreal1:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mlib.mrandomp
    mov       r10,	9223372036854775807
    cqo       
    idiv      r10
    cvtsi2sd  XMM4,	rax
    movq      XMM0,	XMM4
L768:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc readline
mlib.readline:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      msys.m$read_conline
    mov       rax,	[msys.rd_buffer]
L769:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc roundtoblock
mlib.roundtoblock:
;>>
    %define mlib.roundtoblock.n 16
    %define mlib.roundtoblock.align 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mlib.roundtoblock.align]
    sub       rax,	1
    mov       r10,	[rbp + mlib.roundtoblock.n]
    and       r10,	rax
    cmp       r10,	0
    jnz       L772
    mov       rax,	[rbp + mlib.roundtoblock.n]
    jmp       L770
L772:
L771:
    mov       rax,	[rbp + mlib.roundtoblock.align]
    sub       rax,	1
    mov       r10,	[rbp + mlib.roundtoblock.n]
    and       r10,	rax
    mov       rax,	[rbp + mlib.roundtoblock.align]
    sub       rax,	r10
    mov       r10,	[rbp + mlib.roundtoblock.n]
    add       r10,	rax
    mov       rax,	r10
L770:
;---------------
    pop       rbp
    ret       
;End 
;Proc pcm_allocnfz
mlib.pcm_allocnfz:
;>>
    %define mlib.pcm_allocnfz.n 16
    %define mlib.pcm_allocnfz.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mlib.pcm_allocnfz.n]
    and       rax,	7
    test      rax,	rax
    jz        L775
    mov       rax,	[rbp + mlib.pcm_allocnfz.n]
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	[rbp + mlib.pcm_allocnfz.n]
    add       rax,	r10
    mov       [rbp + mlib.pcm_allocnfz.n],	rax
L775:
L774:
    mov       rax,	[mlib.pcheapptr]
    mov       [rbp + mlib.pcm_allocnfz.p],	rax
    mov       rax,	[rbp + mlib.pcm_allocnfz.n]
    add       [mlib.pcheapptr],	rax
    mov       rax,	[mlib.pcheapptr]
    cmp       rax,	[mlib.pcheapend]
    jb        L777
    mov       rcx,	[rbp + mlib.pcm_allocnfz.n]
    call      mlib.pcm_newblock
    mov       [rbp + mlib.pcm_allocnfz.p],	rax
L777:
L776:
    mov       rax,	[rbp + mlib.pcm_allocnfz.p]
L773:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc os_init
mwindows.os_init:
;>>
    %define mwindows.os_init.i -8
    %define mwindows.os_init.count -16
    %define mwindows.os_init.info -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       eax,	-11
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [mwindows.hconsole],	rax
    mov       eax,	-10
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [mwindows.hconsolein],	rax
    xor       eax,	eax
    mov       [mwindows.lastkey+8],	ax
    xor       eax,	eax
    mov       [mwindows.keypending],	rax
    xor       ecx,	ecx
    mov       rdx,	1
    call      SetConsoleCtrlHandler
    mov       rcx,	[mwindows.hconsole]
    mov       rdx,	3
    call      SetConsoleMode
    mov       rax,	1
    mov       [mwindows.init_flag],	rax
L778:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc os_execwait
mwindows.os_execwait:
;>>
    %define mwindows.os_execwait.cmdline 16
    %define mwindows.os_execwait.newconsole 24
    %define mwindows.os_execwait.workdir 32
    %define mwindows.os_execwait.exitcode -8
    %define mwindows.os_execwait.status -16
    %define mwindows.os_execwait.cflags -24
    %define mwindows.os_execwait.si -128
    %define mwindows.os_execwait.xpi -152
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       eax,	eax
    mov       [rbp + mwindows.os_execwait.cflags],	rax
    lea       rax,	[rbp + mwindows.os_execwait.si]
    xor       r10,	r10
    mov       r11,	13
L5492:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L5492
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       rax,	[rbp + mwindows.os_execwait.newconsole]
    cmp       rax,	0
    jz        L781
    cmp       rax,	1
    jz        L782
    cmp       rax,	2
    jz        L783
    jmp       L784
L781:
    mov       rax,	32
    mov       [rbp + mwindows.os_execwait.cflags],	rax
    jmp       L780
L782:
    mov       rax,	48
    mov       [rbp + mwindows.os_execwait.cflags],	rax
    jmp       L780
L783:
    mov       rax,	48
    mov       [rbp + mwindows.os_execwait.cflags],	rax
L784:
L780:
    mov       eax,	104
    mov       [rbp + mwindows.os_execwait.si],	eax
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execwait.si]
    push      rax
    push      0
    push      0
    mov       eax,	[rbp + mwindows.os_execwait.cflags]
    push      rax
    push      1
    xor       ecx,	ecx
    mov       rdx,	[rbp + mwindows.os_execwait.cmdline]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       [rbp + mwindows.os_execwait.status],	rax
    mov       rax,	[rbp + mwindows.os_execwait.status]
    cmp       rax,	0
    jnz       L786
    call      GetLastError
    mov       eax,	eax
    mov       [rbp + mwindows.os_execwait.status],	rax
    lea       rcx,	[rel L5493]
    mov       rdx,	[rbp + mwindows.os_execwait.status]
    call      printf
    mov       rax,	-1
    jmp       L779
L786:
L785:
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    mov       rdx,	4294967295
    call      WaitForSingleObject
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    lea       rdx,	[rbp + mwindows.os_execwait.exitcode]
    call      GetExitCodeProcess
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    call      CloseHandle
    mov       rax,	[rbp + mwindows.os_execwait.xpi+8]
    mov       rcx,	rax
    call      CloseHandle
    mov       eax,	[rbp + mwindows.os_execwait.exitcode]
L779:
;---------------
    add       rsp,	192
    pop       rbp
    ret       
;End 
;Proc os_execcmd
mwindows.os_execcmd:
;>>
    %define mwindows.os_execcmd.cmdline 16
    %define mwindows.os_execcmd.newconsole 24
    %define mwindows.os_execcmd.exitcode -8
    %define mwindows.os_execcmd.i -16
    %define mwindows.os_execcmd.j -24
    %define mwindows.os_execcmd.k -32
    %define mwindows.os_execcmd.si -136
    %define mwindows.os_execcmd.xpi -160
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    xor       r10,	r10
    mov       r11,	13
L5494:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L5494
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       eax,	104
    mov       [rbp + mwindows.os_execcmd.si],	eax
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    push      rax
    push      0
    push      0
    mov       rax,	[rbp + mwindows.os_execcmd.newconsole]
    test      rax,	rax
    jz        L789
    mov       rax,	16
    jmp       L788
L789:
    xor       eax,	eax
L788:
    mov       r10,	32
    or        r10,	rax
    push      r10
    push      1
    xor       ecx,	ecx
    mov       rdx,	[rbp + mwindows.os_execcmd.cmdline]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rax,	[rbp + mwindows.os_execcmd.xpi]
    mov       rcx,	rax
    call      CloseHandle
    mov       rax,	[rbp + mwindows.os_execcmd.xpi+8]
    mov       rcx,	rax
    call      CloseHandle
    mov       rax,	1
L787:
;---------------
    add       rsp,	192
    pop       rbp
    ret       
;End 
;Proc os_getch
mwindows.os_getch:
;>>
    %define mwindows.os_getch.k -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    call      mwindows.os_getchx
    and       rax,	255
    mov       [rbp + mwindows.os_getch.k],	rax
    mov       rax,	[rbp + mwindows.os_getch.k]
L790:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc os_kbhit
mwindows.os_kbhit:
;>>
    %define mwindows.os_kbhit.count -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mwindows.init_flag]
    test      rax,	rax
    jnz       L793
    call      mwindows.os_init
L793:
L792:
    mov       rcx,	[mwindows.hconsolein]
    lea       rdx,	[rbp + mwindows.os_kbhit.count]
    call      GetNumberOfConsoleInputEvents
    mov       eax,	[rbp + mwindows.os_kbhit.count]
    cmp       rax,	1
    setg      al
    movzx     eax,	al
L791:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc os_getdllinst
mwindows.os_getdllinst:
;>>
    %define mwindows.os_getdllinst.name 16
    %define mwindows.os_getdllinst.hinst -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mwindows.os_getdllinst.name]
    call      LoadLibraryA
    mov       [rbp + mwindows.os_getdllinst.hinst],	rax
    mov       rax,	[rbp + mwindows.os_getdllinst.hinst]
L794:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc os_getdllprocaddr
mwindows.os_getdllprocaddr:
;>>
    %define mwindows.os_getdllprocaddr.hinst 16
    %define mwindows.os_getdllprocaddr.name 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mwindows.os_getdllprocaddr.hinst]
    mov       rdx,	[rbp + mwindows.os_getdllprocaddr.name]
    call      GetProcAddress
L795:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_initwindows
mwindows.os_initwindows:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mwindows.os_init
    lea       rcx,	[rel L5495]
    call      mwindows.os_gxregisterclass
L796:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_gxregisterclass
mwindows.os_gxregisterclass:
;>>
    %define mwindows.os_gxregisterclass.classname 16
    %define mwindows.os_gxregisterclass.r -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mwindows.os_gxregisterclass.registered]
    test      rax,	rax
    jz        L799
    jmp       L797
L799:
L798:
    lea       rax,	[rbp + mwindows.os_gxregisterclass.r]
    xor       r10,	r10
    mov       r11,	10
L5496:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L5496
    mov       eax,	80
    mov       [rbp + mwindows.os_gxregisterclass.r],	eax
    mov       eax,	40
    mov       [rbp + mwindows.os_gxregisterclass.r+4],	eax
    lea       rax,	[mwindows.mainwndproc]
    mov       [rbp + mwindows.os_gxregisterclass.r+8],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+24],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+32],	rax
    xor       ecx,	ecx
    mov       rdx,	32512
    call      LoadCursorA
    mov       [rbp + mwindows.os_gxregisterclass.r+40],	rax
    mov       rax,	16
    mov       [rbp + mwindows.os_gxregisterclass.r+48],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+56],	rax
    mov       rax,	[rbp + mwindows.os_gxregisterclass.classname]
    mov       [rbp + mwindows.os_gxregisterclass.r+64],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+72],	rax
    lea       rcx,	[rbp + mwindows.os_gxregisterclass.r]
    call      RegisterClassExA
    mov       eax,	eax
    cmp       rax,	0
    jnz       L801
    call      GetLastError
    mov       eax,	eax
    lea       rcx,	[rel L5497]
    mov       rdx,	[rbp + mwindows.os_gxregisterclass.classname]
    mov       r8,	rax
    call      printf
    mov       rcx,	1
    call      exit
L801:
L800:
    mov       al,	1
    mov       [mwindows.os_gxregisterclass.registered],	al
L797:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc mainwndproc
mwindows.mainwndproc:
;>>
    %define mwindows.mainwndproc.hwnd 16
    %define mwindows.mainwndproc.message 24
    %define mwindows.mainwndproc.wparam 32
    %define mwindows.mainwndproc.lparam 40
    %define mwindows.mainwndproc.m -48
    %define mwindows.mainwndproc.i -56
    %define mwindows.mainwndproc.result -64
    %define mwindows.mainwndproc.l -72
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mwindows.mainwndproc.hwnd]
    mov       [rbp + mwindows.mainwndproc.m],	rax
    mov       eax,	[rbp + mwindows.mainwndproc.message]
    mov       [rbp + mwindows.mainwndproc.m+8],	eax
    mov       rax,	[rbp + mwindows.mainwndproc.wparam]
    mov       [rbp + mwindows.mainwndproc.m+16],	rax
    mov       rax,	[rbp + mwindows.mainwndproc.lparam]
    mov       [rbp + mwindows.mainwndproc.m+24],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+40],	eax
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+44],	eax
    mov       rax,	[mwindows.wndproc_callbackfn]
    test      rax,	rax
    jz        L804
    lea       rcx,	[rbp + mwindows.mainwndproc.m]
    mov       rax,	[mwindows.wndproc_callbackfn]
    call      rax
    mov       [rbp + mwindows.mainwndproc.result],	rax
    jmp       L803
L804:
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.result],	rax
L803:
    mov       eax,	[rbp + mwindows.mainwndproc.m+8]
    cmp       rax,	2
    jnz       L806
    xor       eax,	eax
    jmp       L802
L806:
L805:
    mov       rax,	[rbp + mwindows.mainwndproc.result]
    test      rax,	rax
    jnz       L808
    mov       eax,	[rbp + mwindows.mainwndproc.message]
    mov       rcx,	[rbp + mwindows.mainwndproc.hwnd]
    mov       rdx,	rax
    mov       r8,	[rbp + mwindows.mainwndproc.wparam]
    mov       r9,	[rbp + mwindows.mainwndproc.lparam]
    call      DefWindowProcA
    jmp       L807
L808:
    xor       eax,	eax
L807:
L802:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc os_setmesshandler
mwindows.os_setmesshandler:
;>>
    %define mwindows.os_setmesshandler.addr 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mwindows.os_setmesshandler.addr]
    mov       [mwindows.wndproc_callbackfn],	rax
L809:
;---------------
    pop       rbp
    ret       
;End 
;Proc os_getchx
mwindows.os_getchx:
;>>
    %define mwindows.os_getchx.count -8
    %define mwindows.os_getchx.charcode -16
    %define mwindows.os_getchx.keyshift -24
    %define mwindows.os_getchx.keycode -32
    %define mwindows.os_getchx.altdown -40
    %define mwindows.os_getchx.ctrldown -48
    %define mwindows.os_getchx.shiftdown -56
    %define mwindows.os_getchx.capslock -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    mov       rax,	[mwindows.init_flag]
    test      rax,	rax
    jnz       L812
    call      mwindows.os_init
L812:
L811:
    mov       rax,	[mwindows.keypending]
    test      rax,	rax
    jz        L814
    lea       rax,	[mwindows.pendkey]
    lea       r10,	[mwindows.lastkey]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11d,	[rax+16]
    mov       [r10+16],	r11d
    xor       eax,	eax
    mov       [mwindows.keypending],	rax
    jmp       L813
L814:
    movzx     rax,	word [mwindows.lastkey+8]
    cmp       rax,	0
    jnz       L816
L817:
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.count],	rax
    mov       rcx,	[mwindows.hconsolein]
    lea       rdx,	[mwindows.lastkey]
    mov       r8,	1
    lea       r9,	[rbp + mwindows.os_getchx.count]
    call      ReadConsoleInputA
L818:
    movzx     rax,	word [mwindows.lastkey]
    cmp       rax,	1
    jnz       L817
    mov       eax,	[mwindows.lastkey+4]
    cmp       rax,	1
    jnz       L817
L819:
L816:
L815:
L813:
    mov       eax,	[mwindows.lastkey+16]
    and       rax,	3
    test      rax,	rax
    jz        L821
    mov       rax,	1
    jmp       L820
L821:
    xor       eax,	eax
L820:
    mov       [rbp + mwindows.os_getchx.altdown],	rax
    mov       eax,	[mwindows.lastkey+16]
    and       rax,	12
    test      rax,	rax
    jz        L823
    mov       rax,	1
    jmp       L822
L823:
    xor       eax,	eax
L822:
    mov       [rbp + mwindows.os_getchx.ctrldown],	rax
    mov       eax,	[mwindows.lastkey+16]
    and       rax,	16
    test      rax,	rax
    jz        L825
    mov       rax,	1
    jmp       L824
L825:
    xor       eax,	eax
L824:
    mov       [rbp + mwindows.os_getchx.shiftdown],	rax
    mov       eax,	[mwindows.lastkey+16]
    and       rax,	128
    test      rax,	rax
    jz        L827
    mov       rax,	1
    jmp       L826
L827:
    xor       eax,	eax
L826:
    mov       [rbp + mwindows.os_getchx.capslock],	rax
    lea       rax,	[mwindows.lastkey]
    lea       rax,	[rax+8]
    dec       word [rax]
    movzx     rax,	byte [mwindows.lastkey+14]
    mov       [rbp + mwindows.os_getchx.charcode],	rax
    movzx     rax,	word [mwindows.lastkey+10]
    and       rax,	255
    mov       [rbp + mwindows.os_getchx.keycode],	rax
    mov       rax,	[rbp + mwindows.os_getchx.charcode]
    cmp       rax,	0
    jge       L829
    mov       rax,	[rbp + mwindows.os_getchx.charcode]
    cmp       rax,	-128
    jge       L831
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.charcode],	rax
    jmp       L830
L831:
    mov       rax,	256
    add       [rbp + mwindows.os_getchx.charcode],	rax
L830:
L829:
L828:
    mov       rax,	[rbp + mwindows.os_getchx.altdown]
    test      rax,	rax
    jz        L833
    mov       rax,	[rbp + mwindows.os_getchx.ctrldown]
    test      rax,	rax
    jz        L833
    mov       rax,	[rbp + mwindows.os_getchx.charcode]
    cmp       rax,	166
    jnz       L833
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.ctrldown],	rax
    mov       [rbp + mwindows.os_getchx.altdown],	rax
    jmp       L832
L833:
    mov       rax,	[rbp + mwindows.os_getchx.altdown]
    test      rax,	rax
    jnz       L836
    mov       rax,	[rbp + mwindows.os_getchx.ctrldown]
    test      rax,	rax
    jz        L835
L836:
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.charcode],	rax
    mov       rax,	[rbp + mwindows.os_getchx.keycode]
    cmp       rax,	65
    jl        L838
    mov       rax,	[rbp + mwindows.os_getchx.keycode]
    cmp       rax,	90
    jg        L838
    mov       rax,	[rbp + mwindows.os_getchx.keycode]
    sub       rax,	64
    mov       [rbp + mwindows.os_getchx.charcode],	rax
L838:
L837:
L835:
L834:
L832:
    mov       rax,	[rbp + mwindows.os_getchx.capslock]
    shl       rax,	3
    mov       r10,	[rbp + mwindows.os_getchx.altdown]
    shl       r10,	2
    or        rax,	r10
    mov       r10,	[rbp + mwindows.os_getchx.ctrldown]
    shl       r10,	1
    or        rax,	r10
    or        rax,	[rbp + mwindows.os_getchx.shiftdown]
    mov       [rbp + mwindows.os_getchx.keyshift],	rax
    mov       rax,	[rbp + mwindows.os_getchx.keyshift]
    shl       rax,	24
    mov       r10,	[rbp + mwindows.os_getchx.keycode]
    shl       r10,	16
    or        rax,	r10
    or        rax,	[rbp + mwindows.os_getchx.charcode]
L810:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc os_getos
mwindows.os_getos:
;>>
;---------------
    lea       rax,	[rel L5498]
L839:
;---------------
    ret       
;End 
;Proc os_gethostsize
mwindows.os_gethostsize:
;>>
;---------------
    mov       rax,	64
L840:
;---------------
    ret       
;End 
;Proc os_shellexec
mwindows.os_shellexec:
;>>
    %define mwindows.os_shellexec.opc 16
    %define mwindows.os_shellexec.file 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mwindows.os_shellexec.file]
    call      system
    movsxd    rax,	eax
L841:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_sleep
mwindows.os_sleep:
;>>
    %define mwindows.os_sleep.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mwindows.os_sleep.a]
    call      Sleep
L842:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_getstdin
mwindows.os_getstdin:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    lea       rcx,	[rel L5499]
    lea       rdx,	[rel L5500]
    call      fopen
L843:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_getstdout
mwindows.os_getstdout:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    lea       rcx,	[rel L5501]
    lea       rdx,	[rel L5502]
    call      fopen
L844:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_gethostname
mwindows.os_gethostname:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    xor       ecx,	ecx
    lea       rdx,	[mwindows.os_gethostname.name]
    mov       r8,	300
    call      GetModuleFileNameA
    lea       rax,	[mwindows.os_gethostname.name]
L845:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_getmpath
mwindows.os_getmpath:
;>>
;---------------
    lea       rax,	[rel L5503]
L846:
;---------------
    ret       
;End 
;Proc os_clock
mwindows.os_clock:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      clock
    movsxd    rax,	eax
L847:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_ticks
mwindows.os_ticks:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      GetTickCount64
L848:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_iswindows
mwindows.os_iswindows:
;>>
;---------------
    mov       rax,	1
L849:
;---------------
    ret       
;End 
;Proc os_getsystime
mwindows.os_getsystime:
;>>
    %define mwindows.os_getsystime.tm 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mwindows.os_getsystime.tm]
    call      GetLocalTime
L850:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc os_peek
mwindows.os_peek:
;>>
    %define mwindows.os_peek.ticks -8
    %define mwindows.os_peek.m -112
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
;---------------
    call      GetTickCount64
    mov       [rbp + mwindows.os_peek.ticks],	rax
    mov       rax,	[rbp + mwindows.os_peek.ticks]
    sub       rax,	[mwindows.os_peek.lastticks]
    cmp       rax,	1000
    jl        L853
    mov       rax,	[rbp + mwindows.os_peek.ticks]
    mov       [mwindows.os_peek.lastticks],	rax
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + mwindows.os_peek.m]
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      PeekMessageA
    add       rsp,	48
L853:
L852:
L851:
;---------------
    add       rsp,	144
    pop       rbp
    ret       
;End 
;Proc os_allocexecmem
mwindows.os_allocexecmem:
;>>
    %define mwindows.os_allocexecmem.n 16
    %define mwindows.os_allocexecmem.p -8
    %define mwindows.os_allocexecmem.oldprot -16
    %define mwindows.os_allocexecmem.status -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    xor       ecx,	ecx
    mov       rdx,	[rbp + mwindows.os_allocexecmem.n]
    mov       r8,	12288
    mov       r9,	1
    call      VirtualAlloc
    mov       [rbp + mwindows.os_allocexecmem.p],	rax
    mov       rax,	[rbp + mwindows.os_allocexecmem.p]
    cmp       rax,	0
    jnz       L856
    xor       eax,	eax
    jmp       L854
L856:
L855:
    mov       rcx,	[rbp + mwindows.os_allocexecmem.p]
    mov       rdx,	[rbp + mwindows.os_allocexecmem.n]
    mov       r8,	64
    lea       r9,	[rbp + mwindows.os_allocexecmem.oldprot]
    call      VirtualProtect
    mov       eax,	eax
    mov       [rbp + mwindows.os_allocexecmem.status],	rax
    mov       rax,	[rbp + mwindows.os_allocexecmem.status]
    cmp       rax,	0
    jnz       L858
    xor       eax,	eax
    jmp       L854
L858:
L857:
    mov       rax,	[rbp + mwindows.os_allocexecmem.p]
L854:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc dirlist
mwindows.dirlist:
;>>
    %define mwindows.dirlist.filespec 16
    %define mwindows.dirlist.dest 24
    %define mwindows.dirlist.capacity 32
    %define mwindows.dirlist.t 40
    %define mwindows.dirlist.hfind -8
    %define mwindows.dirlist.file -336
    %define mwindows.dirlist.nfiles -344
    %define mwindows.dirlist.path -648
    %define mwindows.dirlist.fullfilename -952
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	992
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mwindows.dirlist.nfiles],	rax
    mov       rcx,	[rbp + mwindows.dirlist.filespec]
    call      mlib.extractpath
    lea       rcx,	[rbp + mwindows.dirlist.path]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	[rbp + mwindows.dirlist.filespec]
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindFirstFileA
    mov       [rbp + mwindows.dirlist.hfind],	rax
    cmp       rax,	-1
    jz        L861
L862:
    mov       eax,	[rbp + mwindows.dirlist.file]
    and       rax,	16
    test      rax,	rax
    jz        L866
    mov       rax,	[rbp + mwindows.dirlist.t]
    and       rax,	2
    cmp       rax,	0
    jnz       L868
    jmp       L863
L868:
L867:
    jmp       L865
L866:
    mov       rax,	[rbp + mwindows.dirlist.t]
    and       rax,	1
    cmp       rax,	0
    jnz       L870
    jmp       L863
L870:
L869:
L865:
    mov       rax,	[rbp + mwindows.dirlist.nfiles]
    cmp       rax,	[rbp + mwindows.dirlist.capacity]
    jl        L872
    mov       rax,	-1
    mov       [rbp + mwindows.dirlist.nfiles],	rax
    jmp       L864
L872:
L871:
    mov       rax,	[rbp + mwindows.dirlist.t]
    and       rax,	4
    test      rax,	rax
    jz        L874
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    mov       rcx,	rax
    call      mlib.convlcstring
L874:
L873:
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    lea       rdx,	[rbp + mwindows.dirlist.path]
    call      strcpy
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    call      mlib.pcm_copyheapstring
    inc       qword [rbp + mwindows.dirlist.nfiles]
    mov       r10,	[rbp + mwindows.dirlist.nfiles]
    mov       r11,	[rbp + mwindows.dirlist.dest]
    mov       [r11 + r10*8-8],	rax
L863:
    mov       rcx,	[rbp + mwindows.dirlist.hfind]
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindNextFileA
    mov       eax,	eax
    test      rax,	rax
    jnz       L862
L864:
    mov       rcx,	[rbp + mwindows.dirlist.hfind]
    call      FindClose
L861:
L860:
    mov       rax,	[rbp + mwindows.dirlist.nfiles]
L859:
;---------------
    add       rsp,	992
    pop       rbp
    ret       
;End 
;Proc os_calldllfunction
mwindll.os_calldllfunction:
;>>
    %define mwindll.os_calldllfunction.fnaddr 16
    %define mwindll.os_calldllfunction.retcode 24
    %define mwindll.os_calldllfunction.nargs 32
    %define mwindll.os_calldllfunction.args 40
    %define mwindll.os_calldllfunction.argcodes 48
    %define mwindll.os_calldllfunction.a -8
    %define mwindll.os_calldllfunction.x -16
    %define mwindll.os_calldllfunction.nextra -24
    %define mwindll.os_calldllfunction.pushedbytes -32
    %define mwindll.os_calldllfunction.av_1 -40
    %define mwindll.os_calldllfunction.i -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    cmp       rax,	4
    jge       L877
    mov       rax,	4
    sub       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    jmp       L876
L877:
    mov       eax,	[rbp + mwindll.os_calldllfunction.nargs]
    and       eax,	1
    test      rax,	rax
    jz        L878
    mov       rax,	1
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
L878:
L876:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    add       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    imul      rax,	8
    mov       [rbp + mwindll.os_calldllfunction.pushedbytes],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    mov       [rbp + mwindll.os_calldllfunction.av_1],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.av_1]
    cmp       rax,	0
    jle       L881
L879:
    push      0
L880:
    dec       qword [rbp + mwindll.os_calldllfunction.av_1]
    jnz       L879
L881:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    cmp       rax,	1
    jl        L884
L882:
    mov       rax,	[rbp + mwindll.os_calldllfunction.args]
    mov       r10,	[rbp + mwindll.os_calldllfunction.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mwindll.os_calldllfunction.a],	r11
    push      qword [rbp + mwindll.os_calldllfunction.a]
L883:
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    dec       rax
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    cmp       rax,	1
    jge       L882
L884:
    mov       rcx,	[rsp]
    movq      XMM0,	[rsp]
    mov       rdx,	[rsp+8]
    movq      XMM1,	[rsp+8]
    mov       r8,	[rsp+16]
    movq      XMM2,	[rsp+16]
    mov       r9,	[rsp+24]
    movq      XMM3,	[rsp+24]
    mov       rax,	[rbp + mwindll.os_calldllfunction.retcode]
    cmp       rax,	73
    jnz       L886
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       rax,	[rbp + mwindll.os_calldllfunction.a]
    jmp       L885
L886:
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    movq      [rbp + mwindll.os_calldllfunction.x],	XMM0
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      XMM4,	[rbp + mwindll.os_calldllfunction.x]
    movq      rax,	XMM4
L885:
L875:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc pcl_start
pc_api.pcl_start:
pcl_start:
;>>
    %define pc_api.pcl_start.name 16
    %define pc_api.pcl_start.nunits 24
    %define pc_api.pcl_start.nn -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	305419777
    mov       [rbp + pc_api.pcl_start.nn],	rax
    movzx     rax,	byte [pc_decls.pcldone]
    test      rax,	rax
    jz        L889
    lea       rcx,	[rel L5504]
    call      pc_api.pclerror
L889:
L888:
    mov       rax,	[rbp + pc_api.pcl_start.name]
    test      rax,	rax
    jz        L891
    mov       rcx,	[rbp + pc_api.pcl_start.name]
    xor       edx,	edx
    call      pc_api.pc_makesymbol
    mov       [pc_decls.currprog],	rax
L891:
L890:
    mov       rax,	[pc_api.initpcalloc]
    mov       [pc_api.pcalloc],	rax
    mov       rax,	[rbp + pc_api.pcl_start.nunits]
    test      rax,	rax
    jz        L893
    mov       rax,	[rbp + pc_api.pcl_start.nunits]
    imul      rax,	9
    sar       rax,	3
    mov       [rbp + pc_api.pcl_start.nunits],	rax
    jmp       L895
L894:
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	1
    mov       [pc_api.pcalloc],	rax
L895:
    mov       rax,	[pc_api.pcalloc]
    cmp       rax,	[rbp + pc_api.pcl_start.nunits]
    jl        L894
L896:
L893:
L892:
    mov       rax,	[pc_api.pcalloc]
    imul      rax,	32
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [pc_api.pcstart],	rax
    mov       rax,	[pc_api.pcstart]
    mov       r10,	[pc_api.pcalloc]
    shl       r10,	5
    lea       rax,	[rax + r10]
    sub       rax,	256
    mov       [pc_api.pcend],	rax
    mov       rax,	[pc_api.pcstart]
    sub       rax,	32
    mov       [pc_api.pccurr],	rax
    xor       eax,	eax
    mov       [pc_api.pcfixed],	al
    xor       eax,	eax
    mov       [pc_api.pcseqno],	rax
    xor       eax,	eax
    mov       [pc_api.pcneedfntable],	rax
    xor       eax,	eax
    mov       [pc_decls.mmlabelno],	rax
    mov       rax,	[pc_decls.currprog]
L887:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcl_end
pc_api.pcl_end:
pcl_end:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[pc_api.pccurr]
    cmp       rax,	[pc_api.pccurr]
    jb        L899
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax]
    cmp       r10,	134
    jz        L899
    mov       rcx,	134
    xor       edx,	edx
    call      pc_api.pc_gen
L899:
L898:
    mov       al,	1
    mov       [pc_decls.pcldone],	al
L897:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_writepcl
pc_api.pcl_writepcl:
pcl_writepcl:
;>>
    %define pc_api.pcl_writepcl.filename 16
    %define pc_api.pcl_writepcl.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_diags.writeallpcl
    mov       [rbp + pc_api.pcl_writepcl.d],	rax
    mov       rax,	[rbp + pc_api.pcl_writepcl.filename]
    test      rax,	rax
    jz        L902
    movzx     rax,	byte [pc_decls.pverbose]
    test      rax,	rax
    jz        L904
    call      msys.m$print_startcon
    lea       rcx,	[rel L5505]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.pcl_writepcl.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L904:
L903:
    mov       rax,	[rbp + pc_api.pcl_writepcl.d]
    movsxd    r10,	dword [rax+8]
    mov       rax,	[rbp + pc_api.pcl_writepcl.d]
    mov       r11,	[rax]
    mov       rcx,	[rbp + pc_api.pcl_writepcl.filename]
    mov       rdx,	r11
    mov       r8,	r10
    call      mlib.writefile
    lea       rax,	[rel L5506]
    jmp       L901
L902:
    mov       rax,	[rbp + pc_api.pcl_writepcl.d]
    mov       r10,	[rax]
    mov       rax,	r10
L901:
L900:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcl_genmcl
pc_api.pcl_genmcl:
pcl_genmcl:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mc_genmcl.genmcl
L905:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_genss
pc_api.pcl_genss:
pcl_genss:
;>>
    %define pc_api.pcl_genss.obj 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      mc_genmcl.genmcl
    mov       rcx,	[rbp + pc_api.pcl_genss.obj]
    call      mc_genss.genss
L906:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_writeasm
pc_api.pcl_writeasm:
pcl_writeasm:
;>>
    %define pc_api.pcl_writeasm.filename 16
    %define pc_api.pcl_writeasm.atype 24
    %define pc_api.pcl_writeasm.asmstr -8
    %define pc_api.pcl_writeasm.f -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      mc_genmcl.genmcl
    call      mc_writenasm.getassemstr
    mov       [rbp + pc_api.pcl_writeasm.asmstr],	rax
    mov       rax,	[rbp + pc_api.pcl_writeasm.filename]
    test      rax,	rax
    jz        L909
    movzx     rax,	byte [pc_decls.pverbose]
    test      rax,	rax
    jz        L911
    call      msys.m$print_startcon
    lea       rcx,	[rel L5507]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.pcl_writeasm.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L911:
L910:
    mov       rcx,	[rbp + pc_api.pcl_writeasm.filename]
    lea       rdx,	[rel L5508]
    call      fopen
    mov       [rbp + pc_api.pcl_writeasm.f],	rax
    mov       rcx,	[rbp + pc_api.pcl_writeasm.asmstr]
    mov       rdx,	[rbp + pc_api.pcl_writeasm.f]
    call      mlib.gs_println
    mov       rcx,	[rbp + pc_api.pcl_writeasm.f]
    call      fclose
    mov       rcx,	[rbp + pc_api.pcl_writeasm.asmstr]
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L908
L909:
    mov       rax,	[rbp + pc_api.pcl_writeasm.asmstr]
    mov       r10,	[rax]
    mov       rax,	r10
L908:
L907:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcl_writeobj
pc_api.pcl_writeobj:
pcl_writeobj:
;>>
    %define pc_api.pcl_writeobj.filename 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       al,	2
    mov       [mc_decls.phighmem],	al
    call      mc_genmcl.genmcl
    mov       rcx,	1
    call      mc_genss.genss
    mov       rcx,	[rbp + pc_api.pcl_writeobj.filename]
    call      mc_writeobj.writecoff
L912:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_writedll
pc_api.pcl_writedll:
pcl_writedll:
;>>
    %define pc_api.pcl_writedll.filename 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       al,	2
    mov       [mc_decls.phighmem],	al
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    xor       ecx,	ecx
    mov       rdx,	[rbp + pc_api.pcl_writedll.filename]
    mov       r8,	1
    call      mc_writeexe.genexe
    mov       rcx,	[rbp + pc_api.pcl_writedll.filename]
    mov       rdx,	1
    call      mc_writeexe.writeexe
L913:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_writeexe
pc_api.pcl_writeexe:
pcl_writeexe:
;>>
    %define pc_api.pcl_writeexe.filename 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    xor       ecx,	ecx
    mov       rdx,	[rbp + pc_api.pcl_writeexe.filename]
    xor       r8d,	r8d
    call      mc_writeexe.genexe
    mov       rcx,	[rbp + pc_api.pcl_writeexe.filename]
    xor       edx,	edx
    call      mc_writeexe.writeexe
L914:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_writemx
pc_api.pcl_writemx:
pcl_writemx:
;>>
    %define pc_api.pcl_writemx.filename 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    mov       rcx,	[rbp + pc_api.pcl_writemx.filename]
    call      mx_write.writemcx
L915:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_exec
pc_api.pcl_exec:
pcl_exec:
;>>
    %define pc_api.pcl_exec.cmdskip 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    lea       rcx,	[rel L5509]
    mov       rdx,	[rbp + pc_api.pcl_exec.cmdskip]
    call      mx_run.runlibfile
L916:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_setflags
pc_api.pcl_setflags:
pcl_setflags:
;>>
    %define pc_api.pcl_setflags.highmem 16
    %define pc_api.pcl_setflags.verbose 24
    %define pc_api.pcl_setflags.shortnames 32
    %define pc_api.pcl_setflags.hostcmdskip 40
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + pc_api.pcl_setflags.highmem]
    cmp       rax,	0
    jl        L919
    mov       al,	[rbp + pc_api.pcl_setflags.highmem]
    mov       [mc_decls.phighmem],	al
L919:
L918:
    mov       rax,	[rbp + pc_api.pcl_setflags.verbose]
    cmp       rax,	0
    jl        L921
    mov       al,	[rbp + pc_api.pcl_setflags.verbose]
    mov       [pc_decls.pverbose],	al
L921:
L920:
    mov       rax,	[rbp + pc_api.pcl_setflags.shortnames]
    cmp       rax,	0
    jl        L923
    mov       al,	[rbp + pc_api.pcl_setflags.shortnames]
    mov       [mc_decls.fpshortnames],	al
L923:
L922:
    mov       rax,	[rbp + pc_api.pcl_setflags.hostcmdskip]
    cmp       rax,	0
    jl        L925
    mov       rax,	[rbp + pc_api.pcl_setflags.hostcmdskip]
    mov       [pc_decls.pcmdskip],	rax
L925:
L924:
L917:
;---------------
    pop       rbp
    ret       
;End 
;Proc extendpclblock
pc_api.extendpclblock:
;>>
    %define pc_api.extendpclblock.newpcalloc -8
    %define pc_api.extendpclblock.lengthused -16
    %define pc_api.extendpclblock.newpcstart -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rax,	[pc_api.pcalloc]
    imul      rax,	2
    mov       [rbp + pc_api.extendpclblock.newpcalloc],	rax
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    add       rax,	1
    mov       [rbp + pc_api.extendpclblock.lengthused],	rax
    mov       rax,	32
    imul      rax,	[rbp + pc_api.extendpclblock.newpcalloc]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + pc_api.extendpclblock.newpcstart],	rax
    mov       rax,	[rbp + pc_api.extendpclblock.lengthused]
    imul      rax,	32
    mov       rcx,	[rbp + pc_api.extendpclblock.newpcstart]
    mov       rdx,	[pc_api.pcstart]
    mov       r8,	rax
    call      memcpy
    mov       rax,	[rbp + pc_api.extendpclblock.newpcalloc]
    sub       rax,	[rbp + pc_api.extendpclblock.lengthused]
    imul      rax,	32
    mov       r10,	[rbp + pc_api.extendpclblock.newpcstart]
    mov       r11,	[rbp + pc_api.extendpclblock.lengthused]
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.pcm_clearmem
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    mov       r10,	[rbp + pc_api.extendpclblock.newpcstart]
    shl       rax,	5
    lea       r10,	[r10 + rax]
    mov       [pc_api.pccurr],	r10
    mov       rax,	[rbp + pc_api.extendpclblock.newpcstart]
    mov       r10,	[rbp + pc_api.extendpclblock.newpcalloc]
    shl       r10,	5
    lea       rax,	[rax + r10]
    sub       rax,	256
    mov       [pc_api.pcend],	rax
    mov       rax,	[pc_api.pcalloc]
    imul      rax,	32
    mov       rcx,	[pc_api.pcstart]
    mov       rdx,	rax
    call      mlib.pcm_free
    mov       rax,	[rbp + pc_api.extendpclblock.newpcstart]
    mov       [pc_api.pcstart],	rax
    mov       rax,	[rbp + pc_api.extendpclblock.newpcalloc]
    mov       [pc_api.pcalloc],	rax
L926:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc newpcl
pc_api.newpcl:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[pc_api.pccurr]
    cmp       rax,	[pc_api.pcend]
    jb        L929
    call      pc_api.extendpclblock
L929:
L928:
    add       qword [pc_api.pccurr],	32
    mov       eax,	[pc_decls.mmpos]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+24],	eax
    inc       qword [pc_api.pclseqno]
    mov       rax,	[pc_api.pclseqno]
    mov       r10,	[pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       edi,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       edi,	r11d
    or        edi,	eax
    mov       [r10],	edi
    mov       rax,	[pc_api.pccurr]
L927:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_gen
pc_api.pc_gen:
pc_gen:
;>>
    %define pc_api.pc_gen.opcode 16
    %define pc_api.pc_gen.p 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_api.pc_gen.opcode]
    cmp       rax,	2
    jz        L932
    cmp       rax,	5
    jz        L933
    jmp       L934
L932:
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax]
    cmp       r10,	56
    jnz       L936
    mov       al,	3
    mov       r10,	[pc_api.pccurr]
    mov       [r10],	al
    jmp       L930
L936:
L935:
    jmp       L931
L933:
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax]
    cmp       r10,	56
    jnz       L938
    mov       al,	6
    mov       r10,	[pc_api.pccurr]
    mov       [r10],	al
    jmp       L930
L938:
L937:
L934:
L931:
    mov       rax,	[rbp + pc_api.pc_gen.p]
    cmp       rax,	0
    jnz       L940
    call      pc_api.newpcl
    mov       [rbp + pc_api.pc_gen.p],	rax
L940:
L939:
    mov       al,	[rbp + pc_api.pc_gen.opcode]
    mov       r10,	[rbp + pc_api.pc_gen.p]
    mov       [r10],	al
L930:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_genix
pc_api.pc_genix:
pc_genix:
;>>
    %define pc_api.pc_genix.opcode 16
    %define pc_api.pc_genix.scale 24
    %define pc_api.pc_genix.offset 32
    %define pc_api.pc_genix.p -8
    %define pc_api.pc_genix.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       eax,	eax
    test      ax,	ax
    jz        L943
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax]
    cmp       r10,	1
    jnz       L943
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jnz       L943
    mov       rax,	[rbp + pc_api.pc_genix.opcode]
    cmp       rax,	57
    jnz       L945
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+8]
    neg       qword [rax]
    mov       rax,	56
    mov       [rbp + pc_api.pc_genix.opcode],	rax
L945:
L944:
    mov       rax,	[pc_api.pccurr]
    sub       rax,	32
    movzx     r10,	byte [rax]
    cmp       r10,	56
    jnz       L947
    mov       rax,	[pc_api.pccurr]
    sub       rax,	32
    mov       [rbp + pc_api.pc_genix.p],	rax
    mov       rax,	[pc_api.pccurr]
    mov       r10,	[rax+8]
    imul      r10,	[rbp + pc_api.pc_genix.scale]
    add       r10,	[rbp + pc_api.pc_genix.offset]
    mov       rax,	[rbp + pc_api.pc_genix.p]
    lea       rax,	[rax+20]
    add       [rax],	r10d
    mov       al,	[rbp + pc_api.pc_genix.opcode]
    mov       r10,	[rbp + pc_api.pc_genix.p]
    mov       [r10],	al
    mov       rax,	[pc_api.pccurr]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       rax,	[rbp + pc_api.pc_genix.p]
    mov       [pc_api.pccurr],	rax
    jmp       L941
L947:
L946:
L943:
L942:
    call      pc_api.newpcl
    mov       [rbp + pc_api.pc_genix.p],	rax
    mov       al,	[rbp + pc_api.pc_genix.opcode]
    mov       r10,	[rbp + pc_api.pc_genix.p]
    mov       [r10],	al
    mov       eax,	[rbp + pc_api.pc_genix.scale]
    mov       r10,	[rbp + pc_api.pc_genix.p]
    mov       [r10+16],	eax
    mov       eax,	[rbp + pc_api.pc_genix.offset]
    mov       r10,	[rbp + pc_api.pc_genix.p]
    mov       [r10+20],	eax
L941:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pc_genx
pc_api.pc_genx:
pc_genx:
;>>
    %define pc_api.pc_genx.opcode 16
    %define pc_api.pc_genx.x 24
    %define pc_api.pc_genx.p 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + pc_api.pc_genx.p]
    cmp       rax,	0
    jnz       L950
    call      pc_api.newpcl
    mov       [rbp + pc_api.pc_genx.p],	rax
L950:
L949:
    mov       al,	[rbp + pc_api.pc_genx.opcode]
    mov       r10,	[rbp + pc_api.pc_genx.p]
    mov       [r10],	al
    mov       eax,	[rbp + pc_api.pc_genx.x]
    mov       r10,	[rbp + pc_api.pc_genx.p]
    mov       [r10+16],	eax
L948:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_genxy
pc_api.pc_genxy:
pc_genxy:
;>>
    %define pc_api.pc_genxy.opcode 16
    %define pc_api.pc_genxy.x 24
    %define pc_api.pc_genxy.y 32
    %define pc_api.pc_genxy.p 40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + pc_api.pc_genxy.p]
    cmp       rax,	0
    jnz       L953
    call      pc_api.newpcl
    mov       [rbp + pc_api.pc_genxy.p],	rax
L953:
L952:
    mov       al,	[rbp + pc_api.pc_genxy.opcode]
    mov       r10,	[rbp + pc_api.pc_genxy.p]
    mov       [r10],	al
    mov       eax,	[rbp + pc_api.pc_genxy.x]
    mov       r10,	[rbp + pc_api.pc_genxy.p]
    mov       [r10+16],	eax
    mov       eax,	[rbp + pc_api.pc_genxy.y]
    mov       r10,	[rbp + pc_api.pc_genxy.p]
    mov       [r10+20],	eax
L951:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_gencond
pc_api.pc_gencond:
pc_gencond:
;>>
    %define pc_api.pc_gencond.opcode 16
    %define pc_api.pc_gencond.cond 24
    %define pc_api.pc_gencond.p 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + pc_api.pc_gencond.p]
    cmp       rax,	0
    jnz       L956
    call      pc_api.newpcl
    mov       [rbp + pc_api.pc_gencond.p],	rax
L956:
L955:
    mov       al,	[rbp + pc_api.pc_gencond.opcode]
    mov       r10,	[rbp + pc_api.pc_gencond.p]
    mov       [r10],	al
    mov       al,	[rbp + pc_api.pc_gencond.cond]
    mov       r10,	[rbp + pc_api.pc_gencond.p]
    mov       [r10+2],	al
L954:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genint
pc_api.genint:
genint:
;>>
    %define pc_api.genint.a 16
    %define pc_api.genint.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genint.p],	rax
    mov       rax,	[rbp + pc_api.genint.a]
    mov       r10,	[rbp + pc_api.genint.p]
    mov       [r10+8],	rax
    mov       al,	4
    mov       r10,	[rbp + pc_api.genint.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genint.p]
L957:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genreal
pc_api.genreal:
genreal:
;>>
    %define pc_api.genreal.x 16
    %define pc_api.genreal.mode 24
    %define pc_api.genreal.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genreal.p],	rax
    movq      XMM4,	[rbp + pc_api.genreal.x]
    mov       rax,	[rbp + pc_api.genreal.p]
    movq      [rax+8],	XMM4
    mov       rax,	[rbp + pc_api.genreal.mode]
    cmp       rax,	2
    jnz       L960
    mov       rax,	5
    jmp       L959
L960:
    mov       rax,	6
L959:
    mov       r10,	[rbp + pc_api.genreal.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genreal.p]
L958:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genrealimm
pc_api.genrealimm:
genrealimm:
;>>
    %define pc_api.genrealimm.x 16
    %define pc_api.genrealimm.mode 24
    %define pc_api.genrealimm.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genrealimm.p],	rax
    movq      XMM4,	[rbp + pc_api.genrealimm.x]
    mov       rax,	[rbp + pc_api.genrealimm.p]
    movq      [rax+8],	XMM4
    mov       rax,	[rbp + pc_api.genrealimm.mode]
    cmp       rax,	2
    jnz       L963
    mov       rax,	10
    jmp       L962
L963:
    mov       rax,	11
L962:
    mov       r10,	[rbp + pc_api.genrealimm.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genrealimm.p]
L961:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genstring
pc_api.genstring:
genstring:
;>>
    %define pc_api.genstring.s 16
    %define pc_api.genstring.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genstring.p],	rax
    mov       rcx,	[rbp + pc_api.genstring.s]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + pc_api.genstring.p]
    mov       [r10+8],	rax
    mov       al,	7
    mov       r10,	[rbp + pc_api.genstring.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genstring.p]
L964:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genpcstrimm
pc_api.genpcstrimm:
genpcstrimm:
;>>
    %define pc_api.genpcstrimm.s 16
    %define pc_api.genpcstrimm.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genpcstrimm.p],	rax
    mov       rcx,	[rbp + pc_api.genpcstrimm.s]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + pc_api.genpcstrimm.p]
    mov       [r10+8],	rax
    mov       al,	8
    mov       r10,	[rbp + pc_api.genpcstrimm.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genpcstrimm.p]
L965:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genlabel
pc_api.genlabel:
genlabel:
;>>
    %define pc_api.genlabel.a 16
    %define pc_api.genlabel.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genlabel.p],	rax
    mov       rax,	[rbp + pc_api.genlabel.a]
    mov       r10,	[rbp + pc_api.genlabel.p]
    mov       [r10+8],	rax
    mov       al,	3
    mov       r10,	[rbp + pc_api.genlabel.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genlabel.p]
L966:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genmem
pc_api.genmem:
genmem:
;>>
    %define pc_api.genmem.d 16
    %define pc_api.genmem.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genmem.p],	rax
    mov       rax,	[rbp + pc_api.genmem.d]
    mov       r10,	[rbp + pc_api.genmem.p]
    mov       [r10+8],	rax
    mov       al,	1
    mov       r10,	[rbp + pc_api.genmem.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genmem.p]
L967:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genmemaddr
pc_api.genmemaddr:
genmemaddr:
;>>
    %define pc_api.genmemaddr.d 16
    %define pc_api.genmemaddr.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genmemaddr.p],	rax
    mov       rax,	[rbp + pc_api.genmemaddr.d]
    mov       r10,	[rbp + pc_api.genmemaddr.p]
    mov       [r10+8],	rax
    mov       al,	2
    mov       r10,	[rbp + pc_api.genmemaddr.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genmemaddr.p]
L968:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc gendata
pc_api.gendata:
gendata:
;>>
    %define pc_api.gendata.s 16
    %define pc_api.gendata.length 24
    %define pc_api.gendata.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.gendata.p],	rax
    mov       rax,	[rbp + pc_api.gendata.s]
    mov       r10,	[rbp + pc_api.gendata.p]
    mov       [r10+8],	rax
    mov       al,	12
    mov       r10,	[rbp + pc_api.gendata.p]
    mov       [r10+1],	al
    mov       al,	11
    mov       r10,	[rbp + pc_api.gendata.p]
    mov       [r10+3],	al
    mov       eax,	[rbp + pc_api.gendata.length]
    mov       r10,	[rbp + pc_api.gendata.p]
    mov       [r10+4],	eax
    mov       rax,	[rbp + pc_api.gendata.p]
L969:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc gencomment
pc_api.gencomment:
gencomment:
;>>
    %define pc_api.gencomment.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_api.gencomment.s]
    call      pc_api.genpcstrimm
    mov       rcx,	133
    mov       rdx,	rax
    call      pc_api.pc_gen
L970:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genname
pc_api.genname:
genname:
;>>
    %define pc_api.genname.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_api.genname.s]
    xor       edx,	edx
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmem
L971:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gennameaddr
pc_api.gennameaddr:
gennameaddr:
;>>
    %define pc_api.gennameaddr.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_api.gennameaddr.s]
    xor       edx,	edx
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L972:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genassem
pc_api.genassem:
genassem:
;>>
    %define pc_api.genassem.code 16
    %define pc_api.genassem.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      pc_api.newpcl
    mov       [rbp + pc_api.genassem.p],	rax
    mov       rax,	[rbp + pc_api.genassem.code]
    mov       r10,	[rbp + pc_api.genassem.p]
    mov       [r10+8],	rax
    mov       al,	9
    mov       r10,	[rbp + pc_api.genassem.p]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_api.genassem.p]
L973:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc strpmode
pc_api.strpmode:
strpmode:
;>>
    %define pc_api.strpmode.mode 16
    %define pc_api.strpmode.size 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[pc_api.strpmode.str]
    lea       rdx,	[rel L5510]
    call      strcpy
    mov       rax,	[rbp + pc_api.strpmode.mode]
    cmp       rax,	11
    jz        L976
    cmp       rax,	0
    jz        L977
    jmp       L978
L976:
    lea       rcx,	[pc_api.strpmode.str]
    lea       rdx,	[rel L5511]
    call      strcpy
    mov       rcx,	[rbp + pc_api.strpmode.size]
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[pc_api.strpmode.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_api.strpmode.str]
    jmp       L975
L977:
    lea       rax,	[rel L5512]
    jmp       L975
L978:
    lea       rax,	[pc_tables.pstdnames]
    mov       r10,	[rbp + pc_api.strpmode.mode]
    mov       r11,	[rax + r10*8]
    mov       rax,	r11
L975:
L974:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_setmode
pc_api.pc_setmode:
pc_setmode:
;>>
    %define pc_api.pc_setmode.m 16
    %define pc_api.pc_setmode.size 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       al,	[rbp + pc_api.pc_setmode.m]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	[rbp + pc_api.pc_setmode.size]
    test      rax,	rax
    jz        L981
    mov       eax,	[rbp + pc_api.pc_setmode.size]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    jmp       L980
L981:
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psize]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[pc_api.pccurr]
    mov       [rax+4],	r11d
L980:
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax]
    lea       rax,	[pc_tables.pclhastype]
    movzx     r11,	byte [rax + r10]
    cmp       r11,	2
    jnz       L983
    mov       rax,	[pc_api.pccurr]
    movzx     r10,	byte [rax+3]
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       edi,	[rax]
    mov       r11,	-256
    and       edi,	r11d
    or        edi,	r10d
    mov       [rax],	edi
L983:
L982:
L979:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setmode2
pc_api.pc_setmode2:
pc_setmode2:
;>>
    %define pc_api.pc_setmode2.m 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	[rbp + pc_api.pc_setmode2.m]
    mov       edi,	[rax]
    mov       r11,	-256
    and       edi,	r11d
    or        edi,	r10d
    mov       [rax],	edi
L984:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setxy
pc_api.pc_setxy:
pc_setxy:
;>>
    %define pc_api.pc_setxy.x 16
    %define pc_api.pc_setxy.y 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       eax,	[rbp + pc_api.pc_setxy.x]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	[rbp + pc_api.pc_setxy.y]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
L985:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setscaleoff
pc_api.pc_setscaleoff:
pc_setscaleoff:
;>>
    %define pc_api.pc_setscaleoff.scale 16
    %define pc_api.pc_setscaleoff.offset 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       eax,	[rbp + pc_api.pc_setscaleoff.scale]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	[rbp + pc_api.pc_setscaleoff.offset]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
L986:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setoffset
pc_api.pc_setoffset:
pc_setoffset:
;>>
    %define pc_api.pc_setoffset.offset 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       eax,	[rbp + pc_api.pc_setoffset.offset]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
L987:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_addoffset
pc_api.pc_addoffset:
pc_addoffset:
;>>
    %define pc_api.pc_addoffset.offset 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+20]
    mov       r10d,	[rbp + pc_api.pc_addoffset.offset]
    add       [rax],	r10d
L988:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setincr
pc_api.pc_setincr:
pc_setincr:
;>>
    %define pc_api.pc_setincr.n 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       eax,	[rbp + pc_api.pc_setincr.n]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L989:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setnargs
pc_api.pc_setnargs:
pc_setnargs:
;>>
    %define pc_api.pc_setnargs.n 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       eax,	[rbp + pc_api.pc_setnargs.n]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L990:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setnvariadics
pc_api.pc_setnvariadics:
pc_setnvariadics:
;>>
    %define pc_api.pc_setnvariadics.n 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       eax,	[rbp + pc_api.pc_setnvariadics.n]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
L991:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_setalign
pc_api.pc_setalign:
pc_setalign:
;>>
    %define pc_api.pc_setalign.n 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       eax,	[rbp + pc_api.pc_setalign.n]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L992:
;---------------
    pop       rbp
    ret       
;End 
;Proc perror
pc_api.perror:
;>>
    %define pc_api.perror.mess 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_api.perror.mess]
    xor       edx,	edx
    call      pc_api.perror_s
L993:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc perror_s
pc_api.perror_s:
;>>
    %define pc_api.perror_s.mess 16
    %define pc_api.perror_s.param 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5513]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.perror_s.mess]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + pc_api.perror_s.param]
    test      rax,	rax
    jz        L996
    call      msys.m$print_startcon
    lea       rcx,	[rel L5514]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.perror_s.param]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L996:
L995:
    mov       rcx,	1
    call      exit
L994:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getbasename
pc_api.getbasename:
;>>
    %define pc_api.getbasename.s 16
    %define pc_api.getbasename.t -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_api.getbasename.s]
    call      strlen
    mov       r10,	[rbp + pc_api.getbasename.s]
    lea       r10,	[r10 + rax]
    sub       r10,	1
    mov       [rbp + pc_api.getbasename.t],	r10
    jmp       L999
L998:
    dec       qword [rbp + pc_api.getbasename.t]
L999:
    mov       rax,	[rbp + pc_api.getbasename.t]
    cmp       rax,	[rbp + pc_api.getbasename.s]
    jbe       L1001
    mov       rax,	[rbp + pc_api.getbasename.t]
    sub       rax,	1
    movzx     r10,	byte [rax]
    cmp       r10,	46
    jnz       L998
L1001:
L1000:
    mov       rax,	[rbp + pc_api.getbasename.t]
L997:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pclerror
pc_api.pclerror:
;>>
    %define pc_api.pclerror.mess 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5515]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.pclerror.mess]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L1002:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_addsymbol
pc_api.pc_addsymbol:
;>>
    %define pc_api.pc_addsymbol.d 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_decls.psymboltable]
    cmp       rax,	0
    jnz       L1005
    mov       rax,	[rbp + pc_api.pc_addsymbol.d]
    mov       [pc_decls.psymboltablex],	rax
    mov       [pc_decls.psymboltable],	rax
    jmp       L1004
L1005:
    mov       rax,	[rbp + pc_api.pc_addsymbol.d]
    mov       r10,	[pc_decls.psymboltablex]
    mov       [r10+8],	rax
    mov       rax,	[rbp + pc_api.pc_addsymbol.d]
    mov       [pc_decls.psymboltablex],	rax
L1004:
L1003:
;---------------
    pop       rbp
    ret       
;End 
;Proc pc_makesymbol
pc_api.pc_makesymbol:
pc_makesymbol:
;>>
    %define pc_api.pc_makesymbol.s 16
    %define pc_api.pc_makesymbol.id 24
    %define pc_api.pc_makesymbol.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	112
    call      mlib.pcm_allocnfz
    mov       [rbp + pc_api.pc_makesymbol.d],	rax
    mov       rcx,	[rbp + pc_api.pc_makesymbol.s]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + pc_api.pc_makesymbol.d]
    mov       [r10],	rax
    mov       rax,	[rbp + pc_api.pc_makesymbol.id]
    cmp       rax,	1
    jz        L1008
    cmp       rax,	7
    jz        L1009
    jmp       L1010
L1008:
    mov       al,	1
    mov       r10,	[rbp + pc_api.pc_makesymbol.d]
    mov       [r10+56],	al
    jmp       L1007
L1009:
    mov       al,	1
    mov       r10,	[rbp + pc_api.pc_makesymbol.d]
    mov       [r10+57],	al
    mov       rax,	2
    mov       [rbp + pc_api.pc_makesymbol.id],	rax
L1010:
L1007:
    mov       al,	[rbp + pc_api.pc_makesymbol.id]
    mov       r10,	[rbp + pc_api.pc_makesymbol.d]
    mov       [r10+49],	al
    mov       rax,	[rbp + pc_api.pc_makesymbol.id]
    cmp       rax,	4
    jz        L1012
    cmp       rax,	5
    jz        L1012
    jmp       L1013
L1012:
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rbp + pc_api.pc_makesymbol.d]
    mov       [r10+32],	rax
    jmp       L1011
L1013:
    mov       rax,	[pc_decls.currprog]
    mov       r10,	[rbp + pc_api.pc_makesymbol.d]
    mov       [r10+32],	rax
L1011:
    mov       rcx,	[rbp + pc_api.pc_makesymbol.d]
    call      pc_api.pc_addsymbol
    mov       rax,	[rbp + pc_api.pc_makesymbol.d]
L1006:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getfullname
pc_api.getfullname:
;>>
    %define pc_api.getfullname.d 16
    %define pc_api.getfullname.backtick 24
    %define pc_api.getfullname.chain -128
    %define pc_api.getfullname.n -136
    %define pc_api.getfullname.e -144
    %define pc_api.getfullname.i -152
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       eax,	eax
    mov       [rbp + pc_api.getfullname.n],	rax
    mov       rax,	[rbp + pc_api.getfullname.d]
    mov       [rbp + pc_api.getfullname.e],	rax
    movzx     rax,	byte [mc_decls.fpshortnames]
    test      rax,	rax
    jz        L1016
    mov       rax,	[rbp + pc_api.getfullname.d]
    mov       r10,	[rax]
    mov       rax,	r10
    jmp       L1014
L1016:
L1015:
    mov       rax,	[rbp + pc_api.getfullname.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L1018
    mov       rax,	[rbp + pc_api.getfullname.backtick]
    test      rax,	rax
    jz        L1020
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[rel L5516]
    call      strcpy
    mov       rax,	[rbp + pc_api.getfullname.d]
    mov       r10,	[rax]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	r10
    call      strcat
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[rel L5517]
    call      strcat
    jmp       L1019
L1020:
    mov       rax,	[rbp + pc_api.getfullname.d]
    mov       r10,	[rax]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	r10
    call      strcpy
L1019:
    lea       rax,	[pc_api.getfullname.str]
    jmp       L1014
L1018:
L1017:
L1021:
    inc       qword [rbp + pc_api.getfullname.n]
    mov       rax,	[rbp + pc_api.getfullname.n]
    mov       r10,	[rbp + pc_api.getfullname.e]
    mov       [rbp + rax*8 + pc_api.getfullname.chain-8],	r10
    mov       rax,	[rbp + pc_api.getfullname.e]
    mov       r10,	[rax+32]
    mov       [rbp + pc_api.getfullname.e],	r10
L1022:
    mov       rax,	[rbp + pc_api.getfullname.e]
    cmp       rax,	0
    jnz       L1021
L1023:
    mov       rax,	[rbp + pc_api.getfullname.backtick]
    test      rax,	rax
    jz        L1025
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[rel L5518]
    call      strcpy
    jmp       L1024
L1025:
    xor       eax,	eax
    mov       [pc_api.getfullname.str],	al
L1024:
    mov       rax,	[rbp + pc_api.getfullname.n]
    mov       r10,	[rbp + rax*8 + pc_api.getfullname.chain-8]
    mov       rax,	[r10]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    mov       rax,	[rbp + pc_api.getfullname.n]
    sub       rax,	1
    mov       [rbp + pc_api.getfullname.i],	rax
    mov       rax,	[rbp + pc_api.getfullname.i]
    cmp       rax,	1
    jl        L1028
L1026:
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[rel L5519]
    call      strcat
    mov       rax,	[rbp + pc_api.getfullname.i]
    mov       r10,	[rbp + rax*8 + pc_api.getfullname.chain-8]
    mov       rax,	[r10]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
L1027:
    mov       rax,	[rbp + pc_api.getfullname.i]
    dec       rax
    mov       [rbp + pc_api.getfullname.i],	rax
    cmp       rax,	1
    jge       L1026
L1028:
    lea       rax,	[pc_api.getfullname.str]
L1014:
;---------------
    add       rsp,	192
    pop       rbp
    ret       
;End 
;Proc pcerrorstop
pc_api.pcerrorstop:
;>>
    %define pc_api.pcerrorstop.filename 16
    %define pc_api.pcerrorstop.lineno 24
    %define pc_api.pcerrorstop.f -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[rel L5520]
    lea       rdx,	[rel L5521]
    call      fopen
    mov       [rbp + pc_api.pcerrorstop.f],	rax
    mov       rcx,	[rbp + pc_api.pcerrorstop.f]
    call      msys.m$print_startfile
    mov       rcx,	[rbp + pc_api.pcerrorstop.filename]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.pcerrorstop.lineno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_api.pcerrorstop.f]
    call      fclose
    mov       rcx,	1
    call      exit
L1029:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pc_addplib
pc_api.pc_addplib:
pc_addplib:
;>>
    %define pc_api.pc_addplib.name 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	50
    jl        L1032
    lea       rcx,	[rel L5522]
    call      pc_api.perror
L1032:
L1031:
    inc       qword [pc_decls.nplibfiles]
    mov       rax,	[pc_decls.nplibfiles]
    mov       r10,	[rbp + pc_api.pc_addplib.name]
    lea       r11,	[pc_decls.plibfiles]
    mov       [r11 + rax*8-8],	r10
L1030:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pc_defproc
pc_api.pc_defproc:
pc_defproc:
;>>
    %define pc_api.pc_defproc.d 16
    %define pc_api.pc_defproc.mode 24
    %define pc_api.pc_defproc.threaded 32
    %define pc_api.pc_defproc.$T1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jz        L1035
    lea       rcx,	[rel L5523]
    call      pc_api.pclerror
L1035:
L1034:
    mov       rcx,	[rbp + pc_api.pc_defproc.d]
    call      pc_api.genmem
    mov       [rbp + pc_api.pc_defproc.$T1],	rax
    mov       rax,	[rbp + pc_api.pc_defproc.threaded]
    test      rax,	rax
    jz        L1037
    mov       rax,	120
    jmp       L1036
L1037:
    mov       rax,	119
L1036:
    mov       rcx,	rax
    mov       rdx,	[rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    mov       rax,	[rbp + pc_api.pc_defproc.mode]
    cmp       rax,	0
    jnz       L1039
    mov       rax,	[rbp + pc_api.pc_defproc.d]
    movzx     r10,	byte [rax+58]
    mov       [rbp + pc_api.pc_defproc.mode],	r10
L1039:
L1038:
    mov       rcx,	[rbp + pc_api.pc_defproc.mode]
    xor       edx,	edx
    call      pc_api.pc_setmode
    mov       rax,	[rbp + pc_api.pc_defproc.d]
    mov       r10,	[rax+40]
    test      r10,	r10
    jz        L1041
    mov       rax,	[rbp + pc_api.pc_defproc.d]
    mov       r10,	[rax]
    lea       rcx,	[rel L5524]
    mov       rdx,	r10
    call      pc_api.addstr
    mov       rcx,	rax
    call      pc_api.pclerror
L1041:
L1040:
    mov       rax,	[pc_api.pccurr]
    mov       r10,	[rbp + pc_api.pc_defproc.d]
    mov       [r10+40],	rax
    mov       rax,	[pc_decls.entryproc]
    cmp       rax,	0
    jnz       L1043
    mov       rax,	[rbp + pc_api.pc_defproc.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L5525]
    call      mlib.eqstring
    test      rax,	rax
    jz        L1043
    mov       rax,	[rbp + pc_api.pc_defproc.d]
    mov       [pc_decls.entryproc],	rax
L1043:
L1042:
    mov       rax,	[rbp + pc_api.pc_defproc.d]
    mov       [pc_decls.currfunc],	rax
L1033:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pc_addparam
pc_api.pc_addparam:
pc_addparam:
;>>
    %define pc_api.pc_addparam.d 16
    %define pc_api.pc_addparam.p -8
    %define pc_api.pc_addparam.q -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_decls.currfunc]
    mov       [rbp + pc_api.pc_addparam.p],	rax
    mov       rax,	[rbp + pc_api.pc_addparam.p]
    test      rax,	rax
    jnz       L1046
    lea       rcx,	[rel L5526]
    call      pc_api.pclerror
L1046:
L1045:
    mov       rax,	[rbp + pc_api.pc_addparam.p]
    mov       r10,	[rax+16]
    mov       [rbp + pc_api.pc_addparam.q],	r10
    mov       rax,	[rbp + pc_api.pc_addparam.q]
    cmp       rax,	0
    jnz       L1048
    mov       rax,	[rbp + pc_api.pc_addparam.d]
    mov       r10,	[rbp + pc_api.pc_addparam.p]
    mov       [r10+16],	rax
    jmp       L1047
L1048:
    jmp       L1050
L1049:
    mov       rax,	[rbp + pc_api.pc_addparam.q]
    mov       r10,	[rax+16]
    mov       [rbp + pc_api.pc_addparam.q],	r10
L1050:
    mov       rax,	[rbp + pc_api.pc_addparam.q]
    mov       r10,	[rax+16]
    test      r10,	r10
    jnz       L1049
L1051:
    mov       rax,	[rbp + pc_api.pc_addparam.d]
    mov       r10,	[rbp + pc_api.pc_addparam.q]
    mov       [r10+16],	rax
L1047:
    mov       rax,	[pc_decls.currfunc]
    lea       rax,	[rax+97]
    inc       byte [rax]
L1044:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pc_addlocal
pc_api.pc_addlocal:
pc_addlocal:
;>>
    %define pc_api.pc_addlocal.d 16
    %define pc_api.pc_addlocal.p -8
    %define pc_api.pc_addlocal.q -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_decls.currfunc]
    mov       [rbp + pc_api.pc_addlocal.p],	rax
    mov       rax,	[rbp + pc_api.pc_addlocal.p]
    test      rax,	rax
    jnz       L1054
    lea       rcx,	[rel L5526]
    call      pc_api.pclerror
L1054:
L1053:
    mov       rax,	[rbp + pc_api.pc_addlocal.p]
    mov       r10,	[rax+24]
    mov       [rbp + pc_api.pc_addlocal.q],	r10
    mov       rax,	[rbp + pc_api.pc_addlocal.q]
    cmp       rax,	0
    jnz       L1056
    mov       rax,	[rbp + pc_api.pc_addlocal.d]
    mov       r10,	[rbp + pc_api.pc_addlocal.p]
    mov       [r10+24],	rax
    jmp       L1055
L1056:
    jmp       L1058
L1057:
    mov       rax,	[rbp + pc_api.pc_addlocal.q]
    mov       r10,	[rax+24]
    mov       [rbp + pc_api.pc_addlocal.q],	r10
L1058:
    mov       rax,	[rbp + pc_api.pc_addlocal.q]
    mov       r10,	[rax+24]
    test      r10,	r10
    jnz       L1057
L1059:
    mov       rax,	[rbp + pc_api.pc_addlocal.d]
    mov       r10,	[rbp + pc_api.pc_addlocal.q]
    mov       [r10+24],	rax
L1055:
    mov       rax,	[pc_decls.currfunc]
    lea       rax,	[rax+100]
    inc       word [rax]
L1052:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pc_endproc
pc_api.pc_endproc:
pc_endproc:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jnz       L1062
    lea       rcx,	[rel L5526]
    call      pc_api.pclerror
L1062:
L1061:
    mov       rcx,	121
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       eax,	eax
    mov       [pc_decls.currfunc],	rax
L1060:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc addstr
pc_api.addstr:
addstr:
;>>
    %define pc_api.addstr.s 16
    %define pc_api.addstr.t 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[pc_api.addstr.str]
    mov       rdx,	[rbp + pc_api.addstr.s]
    call      strcpy
    lea       rcx,	[pc_api.addstr.str]
    mov       rdx,	[rbp + pc_api.addstr.t]
    call      strcat
    lea       rax,	[pc_api.addstr.str]
L1063:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc strpcl
pc_diags.strpcl:
;>>
    %define pc_diags.strpcl.p 16
    %define pc_diags.strpcl.pmodestr -256
    %define pc_diags.strpcl.str -512
    %define pc_diags.strpcl.opcode -520
    %define pc_diags.strpcl.defused -528
    %define pc_diags.strpcl.s -536
    %define pc_diags.strpcl.d -544
    %define pc_diags.strpcl.e -552
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	592
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax]
    mov       [rbp + pc_diags.strpcl.opcode],	r10
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    r10,	dword [rax+28]
    shr       r10,	8
    and       r10,	16777215
    mov       rcx,	r10
    lea       rdx,	[rel L5527]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rel L5528]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.opcode]
    cmp       rax,	125
    jz        L1066
    cmp       rax,	126
    jz        L1067
    cmp       rax,	133
    jz        L1068
    cmp       rax,	119
    jz        L1069
    cmp       rax,	120
    jz        L1069
    cmp       rax,	121
    jz        L1070
    cmp       rax,	134
    jz        L1071
    cmp       rax,	124
    jz        L1072
    cmp       rax,	122
    jz        L1073
    cmp       rax,	123
    jz        L1073
    jmp       L1074
L1066:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	1
    call      pc_diags.strlabel
    jmp       L1064
L1067:
    lea       rcx,	[rel L5529]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rel L5530]
    call      pc_diags.psstr
    jmp       L1064
L1068:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10,	[rax+8]
    movzx     rax,	byte [r10]
    test      rax,	rax
    jz        L1076
    lea       rcx,	[rel L5531]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      pc_diags.psstr
L1076:
L1075:
    jmp       L1064
L1069:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_diags.strpcl.d],	r10
    mov       rax,	[rbp + pc_diags.strpcl.opcode]
    cmp       rax,	120
    jnz       L1078
    lea       rcx,	[rel L5532]
    call      pc_diags.psstr
    jmp       L1077
L1078:
    lea       rcx,	[rel L5533]
    call      pc_diags.psstr
L1077:
    lea       rcx,	[rel L5534]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.strpcl.d]
    call      pc_diags.psname
    mov       rax,	[rbp + pc_diags.strpcl.d]
    mov       r10,	[rax+16]
    mov       [rbp + pc_diags.strpcl.e],	r10
    lea       rcx,	[rel L5535]
    call      pc_diags.psstr
    jmp       L1082
L1079:
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10d,	[rax+60]
    mov       rax,	[rbp + pc_diags.strpcl.e]
    movzx     r11,	byte [rax+58]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rel L5536]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10,	[rax+16]
    test      r10,	r10
    jz        L1084
    lea       rcx,	[rel L5537]
    call      pc_diags.psstr
L1084:
L1083:
L1080:
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10,	[rax+16]
    mov       [rbp + pc_diags.strpcl.e],	r10
L1082:
    mov       rax,	[rbp + pc_diags.strpcl.e]
    test      rax,	rax
    jnz       L1079
L1081:
    lea       rcx,	[rel L5538]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+3]
    test      r10,	r10
    jz        L1086
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	r10
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
L1086:
L1085:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10,	[rax+8]
    movzx     rax,	byte [r10+57]
    test      rax,	rax
    jz        L1088
    lea       rax,	[rel L5539]
    jmp       L1087
L1088:
    lea       rax,	[rel L5540]
L1087:
    mov       rcx,	rax
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       rax,	[rbp + pc_diags.strpcl.d]
    mov       r10,	[rax+24]
    mov       [rbp + pc_diags.strpcl.e],	r10
    jmp       L1092
L1089:
    lea       rcx,	[rel L5541]
    call      pc_diags.psstr
    lea       rcx,	[rel L5542]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10d,	[rax+60]
    mov       rax,	[rbp + pc_diags.strpcl.e]
    movzx     r11,	byte [rax+58]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rel L5543]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      pc_diags.psstr
    call      pc_diags.psline
L1090:
    mov       rax,	[rbp + pc_diags.strpcl.e]
    mov       r10,	[rax+24]
    mov       [rbp + pc_diags.strpcl.e],	r10
L1092:
    mov       rax,	[rbp + pc_diags.strpcl.e]
    test      rax,	rax
    jnz       L1089
L1091:
    jmp       L1064
L1070:
    lea       rcx,	[rel L5544]
    call      pc_diags.psstr
    jmp       L1064
L1071:
    lea       rcx,	[rel L5545]
    call      pc_diags.psstr
    jmp       L1064
L1072:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	11
    jnz       L1094
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1064
L1094:
L1093:
    jmp       L1065
L1073:
    jmp       L1095
L1074:
L1065:
    lea       rcx,	[rel L5546]
    call      pc_diags.psstr
;skiptab:
L1095:
    mov       rax,	[rbp + pc_diags.strpcl.opcode]
    cmp       rax,	25
    jz        L1097
    cmp       rax,	30
    jz        L1098
    jmp       L1099
L1097:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rel L5547]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+2]
    lea       rax,	[pc_tables.ccnames]
    mov       r11,	[rax + r10*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r11
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    r10,	dword [rax+16]
    test      r10,	r10
    jz        L1101
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rel L5548]
    call      strcat
L1101:
L1100:
    jmp       L1096
L1098:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rel L5549]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+2]
    lea       rax,	[pc_tables.ccnames]
    mov       r11,	[rax + r10*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r11
    call      strcat
    jmp       L1096
L1099:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	[rbp + pc_diags.strpcl.opcode]
    mov       r11,	[rax + r10*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r11
    call      strcpy
L1096:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	9
    mov       r9,	32
    call      mlib.gs_leftstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	0
    jz        L1103
    lea       rcx,	[rel L5550]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
L1103:
L1102:
    mov       rcx,	40
    call      pc_diags.pstabto
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [rax+3]
    test      r10,	r10
    jz        L1105
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     r11,	byte [rax+3]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rax,	[pc_tables.pclhastype]
    mov       r10,	[rbp + pc_diags.strpcl.opcode]
    movzx     r11,	byte [rax + r10]
    cmp       r11,	2
    jnz       L1107
    lea       rcx,	[rel L5551]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	r10
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
L1107:
L1106:
    jmp       L1104
L1105:
    lea       rcx,	[rel L5552]
    call      pc_diags.psstr
L1104:
    lea       rax,	[pc_tables.pclextra]
    mov       r10,	[rbp + pc_diags.strpcl.opcode]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1109
    mov       rax,	[rbp + pc_diags.strpcl.opcode]
    cmp       rax,	25
    jz        L1109
    lea       rcx,	[rel L5553]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    call      pc_diags.psint
    lea       rax,	[pc_tables.pclextra]
    mov       r10,	[rbp + pc_diags.strpcl.opcode]
    movzx     r11,	byte [rax + r10]
    cmp       r11,	2
    jnz       L1111
    lea       rcx,	[rel L5554]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    r10,	dword [rax+20]
    mov       rcx,	r10
    call      pc_diags.psint
L1111:
L1110:
    lea       rcx,	[rel L5555]
    call      pc_diags.psstr
L1109:
L1108:
    mov       rax,	[rbp + pc_diags.strpcl.opcode]
    cmp       rax,	132
    jnz       L1113
    lea       rcx,	[rel L5556]
    call      pc_diags.psstr
L1113:
L1112:
L1064:
;---------------
    add       rsp,	592
    pop       rbp
    ret       
;End 
;Proc stropnd
pc_diags.stropnd:
;>>
    %define pc_diags.stropnd.p 16
    %define pc_diags.stropnd.length -8
    %define pc_diags.stropnd.d -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.stropnd.p]
    cmp       rax,	0
    jnz       L1116
    lea       rax,	[rel L5557]
    jmp       L1114
L1116:
L1115:
    xor       eax,	eax
    mov       [pc_diags.stropnd.str],	al
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jz        L1118
    cmp       r10,	5
    jz        L1119
    cmp       r10,	6
    jz        L1120
    cmp       r10,	10
    jz        L1121
    cmp       r10,	11
    jz        L1121
    cmp       r10,	7
    jz        L1122
    cmp       r10,	1
    jz        L1123
    cmp       r10,	2
    jz        L1124
    cmp       r10,	3
    jz        L1125
    cmp       r10,	0
    jz        L1126
    cmp       r10,	9
    jz        L1127
    cmp       r10,	12
    jz        L1128
    jmp       L1129
L1118:
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    jmp       L1114
L1119:
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movq      XMM4,	[rax+8]
    comisd    XMM4,	[rel L5558]
    jnz       L1131
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5559]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movq      XMM4,	[rax+8]
    movq      rax,	XMM4
    mov       rcx,	rax
    lea       rdx,	[rel L5560]
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L1130
L1131:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    lea       rdx,	[rel L5561]
    call      msys.m$print_r64
    call      msys.m$print_end
L1130:
    jmp       L1117
L1120:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L1117
L1121:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    lea       rcx,	[rel L5562]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1117
L1122:
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      strlen
    mov       [rbp + pc_diags.stropnd.length],	rax
    cmp       rax,	256
    jge       L1133
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[rel L5563]
    call      strcpy
    lea       rax,	[pc_diags.stropnd.str]
    lea       rax,	[rax+1]
    mov       r10,	[rbp + pc_diags.stropnd.p]
    mov       r11,	[r10+8]
    mov       rcx,	r11
    mov       rdx,	rax
    call      pc_diags.convertstring
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[rel L5563]
    call      strcat
    jmp       L1132
L1133:
    lea       rax,	[rel L5564]
    jmp       L1114
L1132:
    jmp       L1117
L1123:
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_diags.stropnd.d],	r10
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    xor       edx,	edx
    call      pc_api.getfullname
    lea       rcx,	[pc_diags.stropnd.str]
    mov       rdx,	rax
    call      strcat
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movzx     r10,	byte [rax]
    cmp       r10,	122
    jz        L1136
    cmp       r10,	123
    jnz       L1135
L1136:
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[rel L5565]
    call      strcat
    mov       rax,	[rbp + pc_diags.stropnd.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L1138
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[rel L5565]
    call      strcat
L1138:
L1137:
L1135:
L1134:
    jmp       L1117
L1124:
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[rel L5566]
    call      strcpy
    jmp       L1123
L1125:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5567]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1117
L1126:
    lea       rax,	[rel L5568]
    jmp       L1114
L1127:
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    jmp       L1114
L1128:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5569]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10d,	[rax+4]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + pc_diags.stropnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1117
L1129:
    call      msys.m$print_startcon
    mov       rax,	[rbp + pc_diags.stropnd.p]
    movzx     r10,	byte [rax+1]
    lea       rax,	[pc_tables.opndnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rel L5570]
    jmp       L1114
L1117:
    lea       rax,	[pc_diags.stropnd.str]
L1114:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc strpclstr
pc_diags.strpclstr:
;>>
    %define pc_diags.strpclstr.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_free
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    xor       eax,	eax
    mov       [pc_diags.destlinestart],	rax
    mov       rcx,	[rbp + pc_diags.strpclstr.p]
    call      pc_diags.strpcl
    mov       rcx,	[pc_diags.dest]
    xor       edx,	edx
    call      mlib.gs_char
    mov       rax,	[pc_diags.dest]
    mov       r10,	[rax]
    mov       rax,	r10
L1139:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc writepcl
pc_diags.writepcl:
;>>
    %define pc_diags.writepcl.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.writepcl.p]
    movzx     r10,	byte [rax]
    cmp       r10,	130
    jz        L1142
    cmp       r10,	129
    jz        L1142
    jmp       L1143
L1142:
    jmp       L1140
L1143:
L1141:
    mov       rcx,	[rbp + pc_diags.writepcl.p]
    call      pc_diags.strpcl
    mov       rax,	[rbp + pc_diags.writepcl.p]
    movzx     r10,	byte [rax]
    cmp       r10,	119
    jz        L1145
    cmp       r10,	4
    jz        L1146
    cmp       r10,	5
    jz        L1146
    cmp       r10,	6
    jz        L1146
    cmp       r10,	132
    jz        L1146
    jmp       L1147
L1145:
    jmp       L1144
L1146:
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
    jmp       L1144
L1147:
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
L1144:
L1140:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc writeallpcl
pc_diags.writeallpcl:
;>>
    %define pc_diags.writeallpcl.p -8
    %define pc_diags.writeallpcl.d -16
    %define pc_diags.writeallpcl.e -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    mov       rax,	[pc_diags.dest]
    movsxd    r10,	dword [rax+8]
    mov       [pc_diags.destlinestart],	r10
    mov       rax,	[pc_api.pcstart]
    mov       [rbp + pc_diags.writeallpcl.p],	rax
    jmp       L1150
L1149:
    mov       rcx,	[rbp + pc_diags.writeallpcl.p]
    call      pc_diags.writepcl
    mov       rax,	[pc_diags.dest]
    movsxd    r10,	dword [rax+8]
    mov       [pc_diags.destlinestart],	r10
    add       qword [rbp + pc_diags.writeallpcl.p],	32
L1150:
    mov       rax,	[rbp + pc_diags.writeallpcl.p]
    cmp       rax,	[pc_api.pccurr]
    jbe       L1149
L1151:
    call      pc_diags.psline
    mov       rax,	[pc_api.longstring]
    test      rax,	rax
    jz        L1153
    mov       rcx,	[pc_api.longstring]
    mov       rdx,	[pc_api.longstringlen]
    call      mlib.pcm_free
L1153:
L1152:
    mov       rax,	[pc_diags.dest]
L1148:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc psstr
pc_diags.psstr:
;>>
    %define pc_diags.psstr.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	[rbp + pc_diags.psstr.s]
    call      mlib.gs_str
L1154:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc psstrline
pc_diags.psstrline:
;>>
    %define pc_diags.psstrline.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	[rbp + pc_diags.psstrline.s]
    call      mlib.gs_str
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
L1155:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc psline
pc_diags.psline:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
L1156:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc psint
pc_diags.psint:
;>>
    %define pc_diags.psint.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_diags.psint.a]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
L1157:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc psname
pc_diags.psname:
;>>
    %define pc_diags.psname.d 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.psname.d]
    mov       r10,	[rax]
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	r10
    call      mlib.gs_str
L1158:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pstabto
pc_diags.pstabto:
;>>
    %define pc_diags.pstabto.n 16
    %define pc_diags.pstabto.col -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[pc_diags.dest]
    movsxd    r10,	dword [rax+8]
    sub       r10,	[pc_diags.destlinestart]
    mov       [rbp + pc_diags.pstabto.col],	r10
    jmp       L1161
L1160:
    lea       rcx,	[rel L5571]
    call      pc_diags.psstr
    inc       qword [rbp + pc_diags.pstabto.col]
L1161:
    mov       rax,	[rbp + pc_diags.pstabto.n]
    cmp       rax,	[rbp + pc_diags.pstabto.col]
    jg        L1160
L1162:
L1159:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc strlabel
pc_diags.strlabel:
;>>
    %define pc_diags.strlabel.labelno 16
    %define pc_diags.strlabel.colon 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rcx,	[rel L5572]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.strlabel.labelno]
    call      pc_diags.psint
    mov       rax,	[rbp + pc_diags.strlabel.colon]
    test      rax,	rax
    jz        L1165
    lea       rcx,	[rel L5573]
    call      pc_diags.psstr
L1165:
L1164:
    lea       rcx,	[rel L5574]
    call      pc_diags.psstr
L1163:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc psopnd
pc_diags.psopnd:
;>>
    %define pc_diags.psopnd.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + pc_diags.psopnd.p]
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
L1166:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc psdata
pc_diags.psdata:
;>>
    %define pc_diags.psdata.p 16
    %define pc_diags.psdata.n -8
    %define pc_diags.psdata.m -16
    %define pc_diags.psdata.q -24
    %define pc_diags.psdata.av_1 -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.psdata.p]
    mov       r10d,	[rax+4]
    mov       [rbp + pc_diags.psdata.n],	r10
    mov       rax,	[rbp + pc_diags.psdata.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_diags.psdata.q],	r10
    mov       rax,	[rbp + pc_diags.psdata.n]
    cmp       rax,	0
    jnz       L1169
    jmp       L1167
L1169:
L1168:
    jmp       L1171
L1170:
    mov       rax,	[rbp + pc_diags.psdata.n]
    mov       [rbp + pc_diags.psdata.m],	rax
    mov       rax,	[rbp + pc_diags.psdata.m]
    cmp       rax,	20
    jl        L1174
    mov       rax,	20
    mov       [rbp + pc_diags.psdata.m],	rax
L1174:
L1173:
    mov       rax,	[rbp + pc_diags.psdata.m]
    sub       [rbp + pc_diags.psdata.n],	rax
    lea       rcx,	[rel L5575]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.psdata.m]
    call      pc_diags.psint
    lea       rcx,	[rel L5576]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.psdata.m]
    cmp       rax,	10
    jge       L1176
    lea       rcx,	[rel L5577]
    call      pc_diags.psstr
L1176:
L1175:
    mov       rax,	[rbp + pc_diags.psdata.m]
    mov       [rbp + pc_diags.psdata.av_1],	rax
    mov       rax,	[rbp + pc_diags.psdata.av_1]
    cmp       rax,	0
    jle       L1179
L1177:
    mov       rax,	[rbp + pc_diags.psdata.q]
    movzx     r10,	byte [rax]
    mov       rcx,	r10
    call      pc_diags.psint
    lea       rcx,	[rel L5577]
    call      pc_diags.psstr
    inc       qword [rbp + pc_diags.psdata.q]
L1178:
    dec       qword [rbp + pc_diags.psdata.av_1]
    jnz       L1177
L1179:
    call      pc_diags.psline
L1171:
    mov       rax,	[rbp + pc_diags.psdata.n]
    cmp       rax,	0
    jg        L1170
L1172:
L1167:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc convertstring
pc_diags.convertstring:
;>>
    %define pc_diags.convertstring.s 16
    %define pc_diags.convertstring.t 24
    %define pc_diags.convertstring.c -8
    %define pc_diags.convertstring.t0 -16
    %define pc_diags.convertstring.str -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_diags.convertstring.t]
    mov       [rbp + pc_diags.convertstring.t0],	rax
    jmp       L1182
L1181:
    mov       rax,	[rbp + pc_diags.convertstring.c]
    cmp       rax,	34
    jz        L1185
    cmp       rax,	10
    jz        L1186
    cmp       rax,	13
    jz        L1187
    cmp       rax,	9
    jz        L1188
    cmp       rax,	92
    jz        L1189
    cmp       rax,	7
    jz        L1190
    cmp       rax,	8
    jz        L1190
    cmp       rax,	26
    jz        L1190
    cmp       rax,	27
    jz        L1190
    jmp       L1191
L1185:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	34
    mov       [rax],	r10b
    jmp       L1184
L1186:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	110
    mov       [rax],	r10b
    jmp       L1184
L1187:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	99
    mov       [rax],	r10b
    jmp       L1184
L1188:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	116
    mov       [rax],	r10b
    jmp       L1184
L1189:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    jmp       L1184
L1190:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	60
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.c]
    mov       r10,	10
    cqo       
    idiv      r10
    add       rax,	48
    mov       r10,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       [r10],	al
    mov       rax,	[rbp + pc_diags.convertstring.c]
    mov       r10,	10
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	48
    mov       r10,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       [r10],	al
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	62
    mov       [rax],	r10b
    jmp       L1184
L1191:
    mov       rax,	[rbp + pc_diags.convertstring.c]
    cmp       rax,	32
    jl        L1193
    cmp       rax,	126
    jg        L1193
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	[rbp + pc_diags.convertstring.c]
    mov       [rax],	r10b
    jmp       L1192
L1193:
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       r10b,	120
    mov       [rax],	r10b
    lea       rcx,	[rbp + pc_diags.convertstring.str]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + pc_diags.convertstring.c]
    lea       rdx,	[rel L5578]
    call      msys.m$print_i64
    call      msys.m$print_end
    movzx     rax,	byte [rbp + pc_diags.convertstring.str]
    mov       r10,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       [r10],	al
    movzx     rax,	byte [rbp + pc_diags.convertstring.str+1]
    mov       r10,	[rbp + pc_diags.convertstring.t]
    inc       qword [rbp + pc_diags.convertstring.t]
    mov       [r10],	al
L1192:
L1184:
L1182:
    mov       rax,	[rbp + pc_diags.convertstring.s]
    inc       qword [rbp + pc_diags.convertstring.s]
    movzx     r10,	byte [rax]
    mov       [rbp + pc_diags.convertstring.c],	r10
    test      r10,	r10
    jnz       L1181
L1183:
    xor       eax,	eax
    mov       r10,	[rbp + pc_diags.convertstring.t]
    mov       [r10],	al
    mov       rax,	[rbp + pc_diags.convertstring.t]
    sub       rax,	[rbp + pc_diags.convertstring.t0]
L1180:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc fullname
pc_diags.fullname:
;>>
    %define pc_diags.fullname.dest 16
    %define pc_diags.fullname.d 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_diags.fullname.d]
    mov       r10,	[rax+32]
    test      r10,	r10
    jz        L1196
    mov       rax,	[rbp + pc_diags.fullname.d]
    mov       r10,	[rax+32]
    mov       rcx,	[rbp + pc_diags.fullname.dest]
    mov       rdx,	r10
    call      pc_diags.fullname
    mov       rcx,	[rbp + pc_diags.fullname.dest]
    lea       rdx,	[rel L5579]
    call      strcat
L1196:
L1195:
    mov       rax,	[rbp + pc_diags.fullname.d]
    mov       r10,	[rax]
    mov       rcx,	[rbp + pc_diags.fullname.dest]
    mov       rdx,	r10
    call      strcat
L1194:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcl_writepst
pc_diags.pcl_writepst:
pcl_writepst:
;>>
    %define pc_diags.pcl_writepst.f 16
    %define pc_diags.pcl_writepst.localfile -8
    %define pc_diags.pcl_writepst.str -264
    %define pc_diags.pcl_writepst.d -272
    %define pc_diags.pcl_writepst.i -280
    %define pc_diags.pcl_writepst.av_1 -288
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	320
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + pc_diags.pcl_writepst.localfile],	al
    xor       eax,	eax
    mov       [rbp + pc_diags.pcl_writepst.i],	rax
    mov       rax,	[rbp + pc_diags.pcl_writepst.f]
    cmp       rax,	0
    jnz       L1199
    lea       rcx,	[rel L5580]
    lea       rdx,	[rel L5581]
    call      fopen
    mov       [rbp + pc_diags.pcl_writepst.f],	rax
    mov       al,	1
    mov       [rbp + pc_diags.pcl_writepst.localfile],	al
L1199:
L1198:
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5582]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[pc_decls.psymboltable]
    mov       [rbp + pc_diags.pcl_writepst.d],	rax
    jmp       L1203
L1200:
    inc       qword [rbp + pc_diags.pcl_writepst.i]
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    mov       rcx,	[rbp + pc_diags.pcl_writepst.i]
    lea       rdx,	[rel L5583]
    call      msys.m$print_i64
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+49]
    lea       rax,	[pc_tables.idnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rel L5584]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+49]
    lea       rax,	[pc_tables.idnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      strlen
    mov       r10,	8
    sub       r10,	rax
    mov       [rbp + pc_diags.pcl_writepst.av_1],	r10
    mov       rax,	[rbp + pc_diags.pcl_writepst.av_1]
    cmp       rax,	0
    jle       L1206
L1204:
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5585]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L1205:
    dec       qword [rbp + pc_diags.pcl_writepst.av_1]
    jnz       L1204
L1206:
    xor       eax,	eax
    mov       [rbp + pc_diags.pcl_writepst.str],	al
    lea       rcx,	[rbp + pc_diags.pcl_writepst.str]
    mov       rdx,	[rbp + pc_diags.pcl_writepst.d]
    call      pc_diags.fullname
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rbp + pc_diags.pcl_writepst.str]
    lea       rdx,	[rel L5586]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    mov       r10d,	[rax+60]
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r11,	byte [rax+58]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	2
    jnz       L1208
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5587]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+97]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movsx     r10,	word [rax+100]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L1208:
L1207:
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L1210
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5588]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L1210:
L1209:
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L1212
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5589]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L1212:
L1211:
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+84]
    test      r10,	r10
    jz        L1214
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5590]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L1214:
L1213:
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    lea       rcx,	[rel L5591]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    movzx     r10,	byte [rax+70]
    lea       rax,	[mc_decls.segmentnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L1201:
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    mov       r10,	[rax+8]
    mov       [rbp + pc_diags.pcl_writepst.d],	r10
L1203:
    mov       rax,	[rbp + pc_diags.pcl_writepst.d]
    test      rax,	rax
    jnz       L1200
L1202:
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     rax,	byte [rbp + pc_diags.pcl_writepst.localfile]
    test      rax,	rax
    jz        L1216
    mov       rcx,	[rbp + pc_diags.pcl_writepst.f]
    call      fclose
L1216:
L1215:
L1197:
;---------------
    add       rsp,	320
    pop       rbp
    ret       
;End 
;Proc stropndstack
pc_diags.stropndstack:
;>>
    %define pc_diags.stropndstack.indent 16
    %define pc_diags.stropndstack.str2 -512
    %define pc_diags.stropndstack.s -520
    %define pc_diags.stropndstack.t -528
    %define pc_diags.stropndstack.fs -536
    %define pc_diags.stropndstack.i -544
    %define pc_diags.stropndstack.r -552
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	592
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[pc_diags.stropndstack.str]
    mov       [rbp + pc_diags.stropndstack.s],	rax
    mov       rax,	[rbp + pc_diags.stropndstack.indent]
    test      rax,	rax
    jz        L1219
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5592]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1218
L1219:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5593]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L1218:
    mov       rax,	1
    mov       [rbp + pc_diags.stropndstack.i],	rax
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L1222
L1220:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	[rbp + pc_diags.stropndstack.i]
    add       rax,	1
    sub       rax,	1
    cmp       rax,	4
    jae       L1225
    lea       r10,	[rel L1224]
    jmp       [r10 + rax*8]
    segment .data
L1224:
    dq  L1226
    dq  L1227
    dq  L1228
    dq  L1229
    segment .text
L1226:
    lea       rax,	[rel L5594]
    jmp       L1223
L1227:
    lea       rax,	[rel L5595]
    jmp       L1223
L1228:
    lea       rax,	[rel L5596]
    jmp       L1223
L1229:
    lea       rax,	[rel L5597]
    jmp       L1223
L1225:
    lea       rax,	[rel L5598]
L1223:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jz        L1231
    cmp       r11,	2
    jz        L1232
    jmp       L1233
L1231:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	2
    jg        L1235
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    movzx     r11,	byte [rax + r10-1]
    lea       rax,	[mc_decls.xregnames]
    mov       r10,	[rax + r11*8]
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	r10
    call      strcat
    jmp       L1234
L1235:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    movzx     r11,	byte [rax + r10-1]
    lea       rax,	[mc_decls.regnames]
    mov       r10,	[rax + r11*8]
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	r10
    call      strcat
L1234:
    jmp       L1230
L1232:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5599]
    call      strcat
    mov       rcx,	[rbp + pc_diags.stropndstack.i]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
    jmp       L1230
L1233:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5600]
    call      strcat
    movzx     rax,	byte [mc_decls.fpshortnames]
    mov       [rbp + pc_diags.stropndstack.fs],	rax
    mov       al,	1
    mov       [mc_decls.fpshortnames],	al
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      pc_diags.stropnd
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
    mov       al,	[rbp + pc_diags.stropndstack.fs]
    mov       [mc_decls.fpshortnames],	al
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5601]
    call      strcat
L1230:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jle       L1237
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5602]
    call      strcat
L1237:
L1236:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5603]
    call      strcat
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + pc_diags.stropndstack.i]
    movzx     r11,	byte [rax + r10-1]
    lea       rax,	[pc_tables.pstdnames]
    mov       r10,	[rax + r11*8]
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	r10
    call      strcat
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5604]
    call      strcat
    mov       rax,	[rbp + pc_diags.stropndstack.i]
    cmp       rax,	[mc_decls.noperands]
    jge       L1239
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5605]
    call      strcat
L1239:
L1238:
L1221:
    mov       rax,	[rbp + pc_diags.stropndstack.i]
    inc       rax
    mov       [rbp + pc_diags.stropndstack.i],	rax
    cmp       rax,	[mc_decls.noperands]
    jle       L1220
L1222:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5606]
    call      strcat
    lea       rcx,	[pc_diags.stropndstack.str]
    mov       rdx,	50
    lea       r8,	[rel L5607]
    call      mlib.ipadstr
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5608]
    call      strcat
    mov       rax,	1
    mov       [rbp + pc_diags.stropndstack.r],	rax
L1240:
    lea       rax,	[mc_decls.regset]
    mov       r10,	[rbp + pc_diags.stropndstack.r]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L1244
    lea       rax,	[rel L5609]
    jmp       L1243
L1244:
    lea       rax,	[rel L5610]
L1243:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
L1241:
    mov       rax,	[rbp + pc_diags.stropndstack.r]
    inc       rax
    mov       [rbp + pc_diags.stropndstack.r],	rax
    cmp       rax,	5
    jle       L1240
L1242:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5611]
    call      strcat
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5612]
    call      strcat
    mov       rax,	1
    mov       [rbp + pc_diags.stropndstack.r],	rax
L1245:
    lea       rax,	[mc_decls.xregset]
    mov       r10,	[rbp + pc_diags.stropndstack.r]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L1249
    lea       rax,	[rel L5613]
    jmp       L1248
L1249:
    lea       rax,	[rel L5614]
L1248:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
L1246:
    mov       rax,	[rbp + pc_diags.stropndstack.r]
    inc       rax
    mov       [rbp + pc_diags.stropndstack.r],	rax
    cmp       rax,	9
    jle       L1245
L1247:
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5615]
    call      strcat
    mov       rcx,	[mc_decls.mstackdepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5616]
    call      strcat
    mov       rcx,	[mc_decls.noperands]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    lea       rdx,	[rel L5617]
    call      strcat
    mov       rcx,	[mc_decls.ncalldepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rbp + pc_diags.stropndstack.s]
    mov       rdx,	rax
    call      strcat
    mov       rax,	[rbp + pc_diags.stropndstack.s]
L1217:
;---------------
    add       rsp,	592
    pop       rbp
    ret       
;End 
;Proc showopndstack
pc_diags.showopndstack:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rcx,	1
    call      pc_diags.stropndstack
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
L1250:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc dispatch_loop
pc_run.dispatch_loop:
;>>
    %define pc_run.dispatch_loop.pcentry 16
    %define pc_run.dispatch_loop.cmain 24
    %define pc_run.dispatch_loop.pc -8
    %define pc_run.dispatch_loop.sp -16
    %define pc_run.dispatch_loop.fp -24
    %define pc_run.dispatch_loop.ptr -32
    %define pc_run.dispatch_loop.a -40
    %define pc_run.dispatch_loop.b -48
    %define pc_run.dispatch_loop.ptrb -56
    %define pc_run.dispatch_loop.n -64
    %define pc_run.dispatch_loop.d -72
    %define pc_run.dispatch_loop.stack -560072
    %define pc_run.dispatch_loop.callstack -600072
    %define pc_run.dispatch_loop.callstackst -680072
    %define pc_run.dispatch_loop.callsp -680080
    %define pc_run.dispatch_loop.str -680336
    %define pc_run.dispatch_loop.mag -680344
    %define pc_run.dispatch_loop.oldsp -680352
    %define pc_run.dispatch_loop.$T1 -680360
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	680400
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_run.dispatch_loop.pcentry]
    mov       [rbp + pc_run.dispatch_loop.pc],	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.sp],	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.fp],	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.callsp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.cmain]
    test      rax,	rax
    jz        L1253
    mov       rax,	[pc_decls.pcmdskip]
    imul      rax,	8
    mov       r10,	[msys.cmdparams]
    lea       r10,	[r10 + rax]
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    mov       rax,	[msys.ncmdparams]
    add       rax,	1
    sub       rax,	[pc_decls.pcmdskip]
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    xor       r10d,	r10d
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
L1253:
L1252:
L1254:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    and       rax,	31
    test      rax,	rax
    jz        L1257
    call      msys.m$print_startcon
    lea       rcx,	[rel L5618]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1257:
L1256:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    cmp       rax,	69900
    jle       L1259
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5619]
    lea       r8,	[rel L5620]
    call      pc_runaux.pcerrorx
L1259:
L1258:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	9900
    jle       L1261
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5621]
    lea       r8,	[rel L5622]
    call      pc_runaux.pcerrorx
L1261:
L1260:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    cmp       r10,	133
    jz        L1264
    cmp       r10,	130
    jz        L1264
    cmp       r10,	125
    jnz       L1263
L1264:
    jmp       L1265
L1263:
L1262:
    mov       rax,	[pc_run.dostep]
    test      rax,	rax
    jnz       L1267
    jmp       L1265
L1267:
L1266:
    call      msys.m$print_startcon
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+28]
    shr       r10,	8
    and       r10,	16777215
    mov       rcx,	r10
    lea       rdx,	[rel L5623]
    call      msys.m$print_u64
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    lea       rax,	[pc_tables.pclnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    lea       rdx,	[rel L5624]
    call      msys.m$print_str
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r11,	byte [rax+3]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+1]
    lea       rax,	[pc_tables.opndnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5625]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_run.dispatch_loop.sp]
    call      msys.m$print_i64_nf
    lea       rcx,	[rel L5626]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_run.dispatch_loop.fp]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[pc_run.go]
    test      rax,	rax
    jnz       L1269
    call      mwindows.os_getch
    cmp       rax,	27
    jz        L1271
    cmp       rax,	82
    jz        L1272
    cmp       rax,	114
    jz        L1272
    cmp       rax,	71
    jz        L1273
    cmp       rax,	103
    jz        L1273
    jmp       L1274
L1271:
    xor       ecx,	ecx
    call      exit
    jmp       L1270
L1272:
    xor       eax,	eax
    mov       [pc_run.dostep],	rax
    jmp       L1270
L1273:
    mov       rax,	1
    mov       [pc_run.go],	rax
L1274:
L1270:
L1269:
L1268:
;skip:
L1265:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    cmp       r10,	140
    jae       L1277
    lea       rax,	[rel L1276]
    jmp       [rax + r10*8]
    segment .data
L1276:
    dq  L1278
    dq  L1280
    dq  L1281
    dq  L1282
    dq  L1283
    dq  L1290
    dq  L1291
    dq  L1292
    dq  L1292
    dq  L1293
    dq  L1294
    dq  L1295
    dq  L1296
    dq  L1297
    dq  L1298
    dq  L1299
    dq  L1300
    dq  L1301
    dq  L1319
    dq  L1309
    dq  L1301
    dq  L1327
    dq  L1314
    dq  L1332
    dq  L1333
    dq  L1334
    dq  L1342
    dq  L1345
    dq  L1348
    dq  L1349
    dq  L1350
    dq  L1357
    dq  L1358
    dq  L1361
    dq  L1364
    dq  L1367
    dq  L1370
    dq  L1373
    dq  L1374
    dq  L1375
    dq  L1376
    dq  L1377
    dq  L1378
    dq  L1381
    dq  L1384
    dq  L1387
    dq  L1388
    dq  L1391
    dq  L1394
    dq  L1395
    dq  L1396
    dq  L1397
    dq  L1398
    dq  L1399
    dq  L1402
    dq  L1403
    dq  L1404
    dq  L1405
    dq  L1406
    dq  L1407
    dq  L1410
    dq  L1411
    dq  L1412
    dq  L1413
    dq  L1414
    dq  L1415
    dq  L1418
    dq  L1419
    dq  L1420
    dq  L1421
    dq  L1422
    dq  L1423
    dq  L1424
    dq  L1425
    dq  L1426
    dq  L1427
    dq  L1428
    dq  L1429
    dq  L1430
    dq  L1431
    dq  L1432
    dq  L1433
    dq  L1434
    dq  L1435
    dq  L1436
    dq  L1437
    dq  L1438
    dq  L1439
    dq  L1440
    dq  L1441
    dq  L1444
    dq  L1447
    dq  L1450
    dq  L1451
    dq  L1452
    dq  L1453
    dq  L1454
    dq  L1455
    dq  L1456
    dq  L1457
    dq  L1460
    dq  L1461
    dq  L1462
    dq  L1463
    dq  L1464
    dq  L1465
    dq  L1466
    dq  L1467
    dq  L1468
    dq  L1469
    dq  L1470
    dq  L1473
    dq  L1474
    dq  L1475
    dq  L1476
    dq  L1477
    dq  L1478
    dq  L1479
    dq  L1480
    dq  L1481
    dq  L1482
    dq  L1483
    dq  L1484
    dq  L1485
    dq  L1486
    dq  L1487
    dq  L1488
    dq  L1489
    dq  L1490
    dq  L1491
    dq  L1492
    dq  L1493
    dq  L1499
    dq  L1500
    dq  L1501
    dq  L1494
    dq  L1495
    dq  L1496
    dq  L1497
    dq  L1498
    segment .text
L1278:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1280:
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    mov       rdx,	r10
    call      pc_runaux.pci_getopnd
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1281:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1282:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r11
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+20]
    lea       r10,	[r10 + r11]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1283:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+1]
    cmp       r10,	1
    jz        L1285
    jmp       L1286
L1285:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.dispatch_loop.d],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	3
    jnz       L1288
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    jmp       L1287
L1288:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	11
    jnz       L1289
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	5
    jnz       L1289
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    add       rax,	r10
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    jmp       L1287
L1289:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    add       rax,	r10
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
L1287:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r11,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	rdi
    mov       r8,	r11
    mov       r9,	r10
    call      pc_runaux.pci_storeptr
    jmp       L1284
L1286:
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    call      pc_runaux.pcusopnd
L1284:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1290:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r11,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	rdi
    mov       r8,	r11
    mov       r9,	r10
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1291:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r11
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+20]
    lea       r10,	[r10 + r11]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r11,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	rdi
    mov       r8,	r11
    mov       r9,	r10
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1292:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1293:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    sub       r10,	1
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    sub       rax,	r10
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+20]
    sub       r11,	1
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    sub       rax,	r11
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[r10]
    mov       rdi,	[r11]
    mov       [r11],	rax
    mov       [r10],	rdi
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1294:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1295:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1296:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1297:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       cl,	r11b
    shr       r10,	cl
    and       r10d,	1
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-16],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1298:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-24]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.pci_loadbf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	2
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1299:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-24]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	3
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1300:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-24]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-32]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rcx,	[rbp + pc_run.dispatch_loop.a]
    mov       rdx,	rdi
    mov       r8,	r11
    mov       r9,	r10
    call      pc_runaux.pci_storebf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	4
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1301:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.dispatch_loop.d],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L1303
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + pc_run.dispatch_loop.n],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    sub       rax,	1
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    push      r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+20]
    push      r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.d]
    xor       edx,	edx
    mov       r8,	r10
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    cmp       r10,	17
    jnz       L1305
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    jmp       L1304
L1305:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
L1304:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1302
L1303:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rax+40]
    test      r10,	r10
    jnz       L1306
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rax]
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5627]
    mov       r8,	r10
    call      pc_runaux.pcerrorx
    jmp       L1302
L1306:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    sub       rax,	r10
    mov       [rbp + pc_run.dispatch_loop.$T1],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    cmp       r10,	20
    jnz       L1308
    mov       rax,	1
    jmp       L1307
L1308:
    xor       eax,	eax
L1307:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       r10,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [r10+16]
    or        rax,	r11
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_run.dispatch_loop.pc],	r10
L1302:
    jmp       L1275
L1309:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + pc_run.dispatch_loop.n],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+20]
    sub       [rbp + pc_run.dispatch_loop.sp],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.fp],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    and       rax,	31
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1311
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5628]
    lea       r8,	[rel L5629]
    call      pc_runaux.pcerrorx
L1311:
L1310:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       r10d,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    cmp       rax,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1313
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5630]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + pc_run.dispatch_loop.sp]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[rel L5631]
    call      pc_runaux.pcerrorx
L1313:
L1312:
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    and       rax,	-32
    mov       [rbp + pc_run.dispatch_loop.pc],	rax
    jmp       L1275
L1314:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + pc_run.dispatch_loop.n],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+20]
    sub       [rbp + pc_run.dispatch_loop.sp],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.fp],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    and       rax,	31
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1316
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5632]
    lea       r8,	[rel L5633]
    call      pc_runaux.pcerrorx
L1316:
L1315:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       r10d,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    cmp       rax,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1318
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5634]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + pc_run.dispatch_loop.sp]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[rel L5635]
    call      pc_runaux.pcerrorx
L1318:
L1317:
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    and       rax,	-32
    mov       [rbp + pc_run.dispatch_loop.pc],	rax
    jmp       L1275
L1319:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    cmp       rax,	0
    jnz       L1321
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5636]
    lea       r8,	[rel L5637]
    call      pc_runaux.pcerrorx
L1321:
L1320:
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    cmp       rax,	[pc_api.pcstart]
    jb        L1323
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    cmp       rax,	[pc_api.pccurr]
    ja        L1323
;icallp:
L1324:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    sub       rax,	1
    mov       r10,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [r10+16]
    sub       rax,	r11
    mov       [rbp + pc_run.dispatch_loop.$T1],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    cmp       r10,	21
    jnz       L1326
    mov       rax,	1
    jmp       L1325
L1326:
    xor       eax,	eax
L1325:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    xor       eax,	eax
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       r10,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [r10+16]
    or        rax,	r11
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       [rbp + pc_run.dispatch_loop.pc],	rax
    jmp       L1322
L1323:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + pc_run.dispatch_loop.n],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    sub       rax,	1
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    push      r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+20]
    push      r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xor       ecx,	ecx
    mov       rdx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r8,	r10
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
L1322:
    jmp       L1275
L1327:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    cmp       rax,	0
    jnz       L1329
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5638]
    lea       r8,	[rel L5639]
    call      pc_runaux.pcerrorx
L1329:
L1328:
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    cmp       rax,	[pc_api.pcstart]
    jb        L1331
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    cmp       rax,	[pc_api.pccurr]
    ja        L1331
    jmp       L1324
L1331:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + pc_run.dispatch_loop.n],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    sub       rax,	1
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    push      r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+20]
    push      r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xor       ecx,	ecx
    mov       rdx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r8,	r10
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movq      XMM4,	[rbp + pc_run.dispatch_loop.a]
    cvttsd2si rax,	XMM4
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
L1330:
    jmp       L1275
L1332:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1275
L1333:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1334:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1336
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM5,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+2]
    mov       rcx,	r10
    movq      XMM1,	XMM5
    movq      XMM2,	XMM4
    call      pc_runaux.cmpreal
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1335
L1336:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1337
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     rdi,	byte [rax+2]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1335
L1337:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     rdi,	byte [rax+2]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1335:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    test      r10,	r10
    jz        L1339
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jnz       L1339
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    jmp       L1338
L1339:
    mov       rax,	2
    sub       [rbp + pc_run.dispatch_loop.sp],	rax
L1338:
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jz        L1341
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1340
L1341:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
L1340:
    jmp       L1275
L1342:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    test      r10,	r10
    jz        L1344
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1343
L1344:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
L1343:
    jmp       L1275
L1345:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    cmp       r10,	0
    jnz       L1347
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1346
L1347:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
L1346:
    jmp       L1275
L1348:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1275
L1349:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1350:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jz        L1352
    cmp       r10,	1
    jz        L1353
    jmp       L1354
L1352:
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5640]
    lea       r8,	[rel L5641]
    call      pc_runaux.pcerrorx
    jmp       L1351
L1353:
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5642]
    lea       r8,	[rel L5643]
    call      pc_runaux.pcerrorx
    jmp       L1351
L1354:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1356
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     rdi,	byte [rax+2]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1355
L1356:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     rdi,	byte [rax+2]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1355:
L1351:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1357:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	r10
    jmp       L1251
L1358:
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       rcx,	rax
    mov       rdx,	r10
    call      pc_runaux.pci_getopndaddr
    mov       [rbp + pc_run.dispatch_loop.ptr],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    dec       qword [rax]
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r10,	[rax]
    test      r10,	r10
    jz        L1360
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1359
L1360:
    add       qword [rbp + pc_run.dispatch_loop.pc],	64
L1359:
    jmp       L1275
L1361:
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       rcx,	rax
    mov       rdx,	r10
    call      pc_runaux.pci_getopndaddr
    mov       [rbp + pc_run.dispatch_loop.ptr],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+64]
    mov       rcx,	rax
    mov       rdx,	r10
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    add       [rax],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r10,	[rax]
    cmp       r10,	[rbp + pc_run.dispatch_loop.n]
    jg        L1363
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1362
L1363:
    add       qword [rbp + pc_run.dispatch_loop.pc],	96
L1362:
    jmp       L1275
L1364:
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       rcx,	rax
    mov       rdx,	r10
    call      pc_runaux.pci_getopndaddr
    mov       [rbp + pc_run.dispatch_loop.ptr],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+64]
    mov       rcx,	rax
    mov       rdx,	r10
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    sub       [rax],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r10,	[rax]
    cmp       r10,	[rbp + pc_run.dispatch_loop.n]
    jl        L1366
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1365
L1366:
    add       qword [rbp + pc_run.dispatch_loop.pc],	96
L1365:
    jmp       L1275
L1367:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	11
    jnz       L1369
    mov       rcx,	[rbp + pc_run.dispatch_loop.pc]
    lea       rdx,	[rel L5644]
    lea       r8,	[rel L5645]
    call      pc_runaux.pcerrorx
L1369:
L1368:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptrb],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.b],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.b]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1370:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    cmp       rax,	r10
    jl        L1372
    mov       r10,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [r10+20]
    cmp       rax,	r11
    jg        L1372
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [r10+16]
    shl       r11,	5
    sub       rax,	r11
    lea       rax,	[rax+96]
    mov       [rbp + pc_run.dispatch_loop.pc],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
    jmp       L1371
L1372:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       r10,	[rax+8]
    mov       rax,	[pc_run.labeltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + pc_run.dispatch_loop.pc],	r11
L1371:
    jmp       L1275
L1373:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1374:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1375:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1376:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	r11
    xor       edx,	edx
    mov       r8,	r10
    call      memset
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1377:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1378:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1380
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    movq      XMM5,	[r10]
    addsd     XMM5,	XMM4
    movq      [r10],	XMM5
    jmp       L1379
L1380:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    add       [r11],	r10
L1379:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1381:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1383
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    movq      XMM5,	[r10]
    subsd     XMM5,	XMM4
    movq      [r10],	XMM5
    jmp       L1382
L1383:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    sub       [r11],	r10
L1382:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1384:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1386
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    movq      XMM5,	[r10]
    mulsd     XMM5,	XMM4
    movq      [r10],	XMM5
    jmp       L1385
L1386:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[r11]
    imul      rax,	r10
    mov       [r11],	rax
L1385:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1387:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM5,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    divsd     XMM4,	XMM5
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      [rbp + rax*8 + pc_run.dispatch_loop.stack-16],	XMM4
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1388:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1390
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xchg      rax,	r10
    cqo       
    idiv      r11
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-16],	rax
    jmp       L1389
L1390:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xchg      rax,	r10
    xor       rdx,	rdx
    div       r11
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-16],	rax
L1389:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1391:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1393
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xchg      rax,	r10
    cqo       
    idiv      r11
    xchg      rax,	rdx
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-16],	rax
    jmp       L1392
L1393:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xchg      rax,	r10
    xor       rdx,	rdx
    div       r11
    xchg      rax,	rdx
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-16],	rax
L1392:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1394:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1395:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    and       [r11],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1396:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    or        [r11],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1397:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    xor       [r11],	r10
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1398:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       cl,	r10b
    shl       qword [r11],	cl
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1399:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1401
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       cl,	r10b
    sar       qword [r11],	cl
    jmp       L1400
L1401:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-16]
    mov       cl,	r10b
    shr       qword [r11],	cl
L1400:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1402:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1403:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1404:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r11
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+20]
    lea       r10,	[r10 + r11]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1405:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r11
    sub       r10,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+20]
    lea       r10,	[r10 + r11]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1406:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    xchg      rax,	r10
    cqo       
    idiv      r11
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + r10*8 + pc_run.dispatch_loop.stack-16]
    sub       [r11],	rax
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1407:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1409
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xorpd     XMM4,	[rel L5646]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	XMM4
    jmp       L1408
L1409:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    neg       r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
L1408:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1410:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1411:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    not       r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1412:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    xor       r10,	1
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1413:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    test      r10,	r10
    setnz     r10b
    movzx     r10d,	r10b
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1414:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    test      r10,	r10
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1415:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1417
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    movq      XMM5,	[r10]
    mulsd     XMM5,	XMM4
    movq      [r10],	XMM5
    jmp       L1416
L1417:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    imul      r10,	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
L1416:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1418:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    sqrtsd    XMM4,	XMM4
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	XMM4
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1419:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1420:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1421:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1422:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1423:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1424:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1425:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1426:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1427:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1428:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1429:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1430:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1431:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1432:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1433:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1434:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1435:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.doincr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1436:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    neg       r11
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rdi,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.doincr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1437:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.doincr
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1438:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    neg       r11
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.doincr
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1439:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.doincr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1440:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    neg       r11
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r11
    mov       r8,	r10
    call      pc_runaux.doincr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1441:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1443
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    movq      XMM5,	rax
    addsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1442
L1443:
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    add       [rbp + pc_run.dispatch_loop.a],	rax
L1442:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1444:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1446
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    movq      XMM5,	rax
    subsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1445
L1446:
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    sub       [rbp + pc_run.dispatch_loop.a],	rax
L1445:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1447:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L1449
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    movq      XMM5,	rax
    mulsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1448
L1449:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	[rbp + pc_run.dispatch_loop.b]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1448:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1450:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1451:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1452:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1453:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    and       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1454:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    or        [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1455:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.b]
    xor       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1456:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       cl,	[rbp + pc_run.dispatch_loop.b]
    shl       qword [rbp + pc_run.dispatch_loop.a],	cl
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1457:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.b],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1459
    mov       cl,	[rbp + pc_run.dispatch_loop.b]
    sar       qword [rbp + pc_run.dispatch_loop.a],	cl
    jmp       L1458
L1459:
    mov       cl,	[rbp + pc_run.dispatch_loop.b]
    shr       qword [rbp + pc_run.dispatch_loop.a],	cl
L1458:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptr]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	r10
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1460:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1461:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1462:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    imul      r10,	r11
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    add       [rax],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1463:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r11,	dword [rax+16]
    imul      r10,	r11
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    sub       [rax],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1464:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1465:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1466:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1467:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1468:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1469:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1470:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L1472
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    cvtsi2sd  XMM4,	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	XMM4
    jmp       L1471
L1472:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    cmp       r10,	0
    jl        L5647
    cvtsi2sd  XMM4,	r10
    jmp       L5648
L5647:
    and       r10,	[rel L5649]
    cvtsi2sd  XMM4,	r10
    addsd     XMM4,	[rel L5650]
L5648:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	XMM4
L1471:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1473:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    movq      XMM4,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    cvttsd2si rax,	XMM4
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1474:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1475:
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    lea       r11,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1476:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1477:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1478:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1479:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1480:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1481:
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.fp]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + pc_run.dispatch_loop.fp],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+20]
    add       [rbp + pc_run.dispatch_loop.sp],	r10
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1482:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1483:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1484:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1485:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1486:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1487:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1488:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1489:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    lea       rax,	[rax+32]
    mov       r10,	[rbp + pc_run.dispatch_loop.ptr]
    mov       [r10],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.ptr]
    mov       [r10+8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.fp]
    mov       r10,	[rbp + pc_run.dispatch_loop.ptr]
    mov       [r10+16],	rax
    xor       eax,	eax
    mov       r10,	[rbp + pc_run.dispatch_loop.sp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.stack-8],	rax
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1490:
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.a],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + rax*8 + pc_run.dispatch_loop.stack-8]
    mov       [rbp + pc_run.dispatch_loop.ptr],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r10,	[rax]
    mov       [rbp + pc_run.dispatch_loop.pc],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.dispatch_loop.sp],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ptr]
    mov       r10,	[rax+16]
    mov       [rbp + pc_run.dispatch_loop.fp],	r10
    inc       qword [rbp + pc_run.dispatch_loop.sp]
    mov       rax,	[rbp + pc_run.dispatch_loop.sp]
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rbp + rax*8 + pc_run.dispatch_loop.stack-8],	r10
    jmp       L1275
L1491:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1492:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1493:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1494:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1495:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1496:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1497:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1498:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1499:
    dec       qword [rbp + pc_run.dispatch_loop.sp]
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1500:
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1501:
    jmp       L1279
    add       qword [rbp + pc_run.dispatch_loop.pc],	32
    jmp       L1275
L1277:
;unimpl:
L1279:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L5651]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movzx     r10,	byte [rax]
    lea       rax,	[pc_tables.pclnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_run.dispatch_loop.pc]
    movsxd    r10,	dword [rax+28]
    shr       r10,	8
    and       r10,	16777215
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L1275:
    jmp       L1254
L1255:
    xor       eax,	eax
L1251:
;---------------
    add       rsp,	680400
    pop       rbp
    ret       
;End 
;Proc fixuppcl
pc_run.fixuppcl:
;>>
    %define pc_run.fixuppcl.p -8
    %define pc_run.fixuppcl.d -16
    %define pc_run.fixuppcl.e -24
    %define pc_run.fixuppcl.dproc -32
    %define pc_run.fixuppcl.pdata -40
    %define pc_run.fixuppcl.parambytes -48
    %define pc_run.fixuppcl.framebytes -56
    %define pc_run.fixuppcl.paramslots -64
    %define pc_run.fixuppcl.localslots -72
    %define pc_run.fixuppcl.a -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
;---------------
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    add       rax,	1
    imul      rax,	8
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [pc_run.labeltable],	rax
    mov       rax,	[pc_api.pcstart]
    mov       [rbp + pc_run.fixuppcl.p],	rax
    jmp       L1506
L1503:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    movzx     r10,	byte [rax]
    cmp       r10,	122
    jz        L1508
    cmp       r10,	123
    jz        L1508
    jmp       L1509
L1508:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.fixuppcl.d],	r10
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10d,	[rax+4]
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       r10,	[rbp + pc_run.fixuppcl.d]
    mov       [r10+40],	rax
L1509:
L1507:
L1504:
    add       qword [rbp + pc_run.fixuppcl.p],	32
L1506:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    cmp       rax,	[pc_api.pccurr]
    jbe       L1503
L1505:
    mov       rax,	[pc_api.pcstart]
    mov       [rbp + pc_run.fixuppcl.p],	rax
    jmp       L1513
L1510:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    movzx     r10,	byte [rax]
    cmp       r10,	122
    jz        L1515
    cmp       r10,	123
    jz        L1515
    cmp       r10,	124
    jz        L1516
    cmp       r10,	119
    jz        L1517
    cmp       r10,	125
    jz        L1518
    cmp       r10,	19
    jz        L1519
    cmp       r10,	22
    jz        L1519
    jmp       L1520
L1515:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10,	[rax+8]
    mov       rax,	[r10+40]
    mov       [rbp + pc_run.fixuppcl.pdata],	rax
    jmp       L1514
L1516:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	11
    jz        L1522
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	1
    jz        L1524
    cmp       r10,	2
    jz        L1525
    jmp       L1526
L1524:
    mov       rcx,	[rbp + pc_run.fixuppcl.p]
    lea       rdx,	[rel L5652]
    lea       r8,	[rel L5653]
    call      pc_runaux.pcerrorx
    jmp       L1523
L1525:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.fixuppcl.d],	r10
    mov       rax,	[rbp + pc_run.fixuppcl.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	3
    jz        L1528
    cmp       r10,	2
    jz        L1529
    cmp       r10,	1
    jz        L1530
    jmp       L1531
L1528:
    mov       rax,	[rbp + pc_run.fixuppcl.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_run.fixuppcl.a],	r10
    jmp       L1527
L1529:
    mov       rax,	[rbp + pc_run.fixuppcl.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_run.fixuppcl.a],	r10
    jmp       L1527
L1530:
    mov       rcx,	[rbp + pc_run.fixuppcl.d]
    call      pc_runaux.getdllfnptr
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1527
L1531:
    mov       rcx,	[rbp + pc_run.fixuppcl.p]
    lea       rdx,	[rel L5654]
    lea       r8,	[rel L5655]
    call      pc_runaux.pcerrorx
L1527:
    mov       rax,	[rbp + pc_run.fixuppcl.a]
    cmp       rax,	0
    jnz       L1533
    mov       rcx,	[rbp + pc_run.fixuppcl.p]
    lea       rdx,	[rel L5656]
    lea       r8,	[rel L5657]
    call      pc_runaux.pcerrorx
L1533:
L1532:
    jmp       L1523
L1526:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.fixuppcl.a],	r10
L1523:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + pc_run.fixuppcl.pdata]
    lea       rdx,	[rbp + pc_run.fixuppcl.a]
    mov       r8,	r10
    call      memcpy
    jmp       L1521
L1522:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10d,	[rax+4]
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r11,	[rax+8]
    mov       rcx,	[rbp + pc_run.fixuppcl.pdata]
    mov       rdx,	r11
    mov       r8,	r10
    call      memcpy
L1521:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10d,	[rax+4]
    add       [rbp + pc_run.fixuppcl.pdata],	r10
    jmp       L1514
L1517:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_run.fixuppcl.d],	r10
    mov       [rbp + pc_run.fixuppcl.dproc],	r10
    mov       rax,	[rbp + pc_run.fixuppcl.d]
    mov       r10,	[rax+16]
    mov       [rbp + pc_run.fixuppcl.e],	r10
    xor       eax,	eax
    mov       [rbp + pc_run.fixuppcl.parambytes],	rax
    jmp       L1537
L1534:
    mov       rax,	8
    add       [rbp + pc_run.fixuppcl.parambytes],	rax
    mov       rax,	[rbp + pc_run.fixuppcl.parambytes]
    sar       rax,	3
    add       rax,	1
    neg       rax
    mov       r10,	[rbp + pc_run.fixuppcl.e]
    mov       [r10+52],	eax
L1535:
    mov       rax,	[rbp + pc_run.fixuppcl.e]
    mov       r10,	[rax+16]
    mov       [rbp + pc_run.fixuppcl.e],	r10
L1537:
    mov       rax,	[rbp + pc_run.fixuppcl.e]
    test      rax,	rax
    jnz       L1534
L1536:
    mov       rax,	[rbp + pc_run.fixuppcl.d]
    mov       r10,	[rax+24]
    mov       [rbp + pc_run.fixuppcl.e],	r10
    xor       eax,	eax
    mov       [rbp + pc_run.fixuppcl.framebytes],	rax
    jmp       L1541
L1538:
    mov       rax,	[rbp + pc_run.fixuppcl.framebytes]
    sar       rax,	3
    add       rax,	1
    mov       r10,	[rbp + pc_run.fixuppcl.e]
    mov       [r10+52],	eax
    mov       rax,	[rbp + pc_run.fixuppcl.e]
    mov       r10d,	[rax+60]
    mov       rcx,	r10
    mov       rdx,	8
    call      mlib.roundtoblock
    add       [rbp + pc_run.fixuppcl.framebytes],	rax
L1539:
    mov       rax,	[rbp + pc_run.fixuppcl.e]
    mov       r10,	[rax+24]
    mov       [rbp + pc_run.fixuppcl.e],	r10
L1541:
    mov       rax,	[rbp + pc_run.fixuppcl.e]
    test      rax,	rax
    jnz       L1538
L1540:
    mov       rax,	[rbp + pc_run.fixuppcl.parambytes]
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.paramslots],	rax
    mov       r10,	[rbp + pc_run.fixuppcl.p]
    mov       [r10+16],	eax
    mov       rax,	[rbp + pc_run.fixuppcl.framebytes]
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.localslots],	rax
    mov       r10,	[rbp + pc_run.fixuppcl.p]
    mov       [r10+20],	eax
    jmp       L1514
L1518:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    mov       r11,	[pc_run.labeltable]
    mov       [r11 + r10*8-8],	rax
    jmp       L1514
L1519:
    mov       eax,	[rbp + pc_run.fixuppcl.paramslots]
    mov       r10,	[rbp + pc_run.fixuppcl.p]
    mov       [r10+16],	eax
    mov       eax,	[rbp + pc_run.fixuppcl.localslots]
    mov       r10,	[rbp + pc_run.fixuppcl.p]
    mov       [r10+20],	eax
L1520:
L1514:
L1511:
    add       qword [rbp + pc_run.fixuppcl.p],	32
L1513:
    mov       rax,	[rbp + pc_run.fixuppcl.p]
    cmp       rax,	[pc_api.pccurr]
    jbe       L1510
L1512:
L1502:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc pcl_runpcl
pc_run.pcl_runpcl:
pcl_runpcl:
;>>
    %define pc_run.pcl_runpcl.stopcode -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    call      pc_runaux.loadlibs
    call      pc_run.fixuppcl
    mov       rax,	[pc_decls.entryproc]
    cmp       rax,	0
    jnz       L1544
    mov       rcx,	[pc_api.pcstart]
    lea       rdx,	[rel L5658]
    lea       r8,	[rel L5659]
    call      pc_runaux.pcerrorx
L1544:
L1543:
    call      pc_runaux.docmdskip
    call      msys.m$print_startcon
    lea       rcx,	[rel L5660]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[pc_decls.entryproc]
    movzx     r10,	byte [rax+97]
    cmp       r10,	2
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	[pc_decls.entryproc]
    mov       r11,	[rax+40]
    mov       rcx,	r11
    mov       rdx,	r10
    call      pc_run.dispatch_loop
    mov       [rbp + pc_run.pcl_runpcl.stopcode],	rax
    call      msys.m$print_startcon
    lea       rcx,	[rel L5661]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_run.pcl_runpcl.stopcode]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_run.pcl_runpcl.stopcode]
    call      exit
L1542:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pci_getopnd
pc_runaux.pci_getopnd:
;>>
    %define pc_runaux.pci_getopnd.p 16
    %define pc_runaux.pci_getopnd.locals 24
    %define pc_runaux.pci_getopnd.a -8
    %define pc_runaux.pci_getopnd.d -16
    %define pc_runaux.pci_getopnd.ptr -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jz        L1547
    cmp       r10,	1
    jz        L1548
    cmp       r10,	2
    jz        L1549
    cmp       r10,	7
    jz        L1550
    cmp       r10,	5
    jz        L1551
    cmp       r10,	6
    jz        L1551
    jmp       L1552
L1547:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_runaux.pci_getopnd.a],	r10
    jmp       L1546
L1548:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_runaux.pci_getopnd.d],	r10
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	3
    jz        L1554
    jmp       L1555
L1554:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_runaux.pci_getopnd.ptr],	r10
    jmp       L1553
L1555:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + pc_runaux.pci_getopnd.locals]
    lea       rax,	[rax + r10*8]
    mov       [rbp + pc_runaux.pci_getopnd.ptr],	rax
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jnz       L1557
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	5
    jnz       L1557
    mov       rax,	[rbp + pc_runaux.pci_getopnd.ptr]
    mov       r10,	[rax]
    mov       [rbp + pc_runaux.pci_getopnd.ptr],	r10
L1557:
L1556:
L1553:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[rbp + pc_runaux.pci_getopnd.ptr]
    mov       rdx,	r10
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_runaux.pci_getopnd.a],	rax
    jmp       L1546
L1549:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_runaux.pci_getopnd.d],	r10
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	4
    jz        L1559
    cmp       r10,	5
    jz        L1560
    cmp       r10,	1
    jz        L1561
    jmp       L1562
L1559:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + pc_runaux.pci_getopnd.locals]
    lea       rax,	[rax + r10*8]
    mov       [rbp + pc_runaux.pci_getopnd.a],	rax
    jmp       L1558
L1560:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + pc_runaux.pci_getopnd.locals]
    lea       rax,	[rax + r10*8]
    mov       [rbp + pc_runaux.pci_getopnd.a],	rax
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jnz       L1564
    mov       rax,	[rbp + pc_runaux.pci_getopnd.a]
    mov       [rbp + pc_runaux.pci_getopnd.ptr],	rax
    mov       rax,	[rbp + pc_runaux.pci_getopnd.ptr]
    mov       r10,	[rax]
    mov       [rbp + pc_runaux.pci_getopnd.a],	r10
L1564:
L1563:
    jmp       L1558
L1561:
    mov       rcx,	[rbp + pc_runaux.pci_getopnd.d]
    call      pc_runaux.getdllfnptr
    mov       [rbp + pc_runaux.pci_getopnd.a],	rax
    jmp       L1558
L1562:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_runaux.pci_getopnd.a],	r10
L1558:
    jmp       L1546
L1550:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_runaux.pci_getopnd.a],	r10
    jmp       L1546
L1551:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.p]
    movq      XMM4,	[rax+8]
    movq      rax,	XMM4
    mov       [rbp + pc_runaux.pci_getopnd.a],	rax
    jmp       L1546
L1552:
    mov       rcx,	[rbp + pc_runaux.pci_getopnd.p]
    call      pc_runaux.pcusopnd
L1546:
    mov       rax,	[rbp + pc_runaux.pci_getopnd.a]
L1545:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc pci_loadptr
pc_runaux.pci_loadptr:
;>>
    %define pc_runaux.pci_loadptr.p 16
    %define pc_runaux.pci_loadptr.mode 24
    %define pc_runaux.pci_loadptr.x -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_runaux.pci_loadptr.mode]
    sub       rax,	1
    cmp       rax,	11
    jae       L1568
    lea       r10,	[rel L1567]
    jmp       [r10 + rax*8]
    segment .data
L1567:
    dq  L1571
    dq  L1570
    dq  L1579
    dq  L1578
    dq  L1577
    dq  L1576
    dq  L1575
    dq  L1574
    dq  L1573
    dq  L1572
    dq  L1569
    segment .text
L1569:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    jmp       L1566
L1570:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    mov       r10,	[rax]
    mov       rax,	r10
    jmp       L1566
L1571:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    movd      XMM4,	[rax]
    cvtss2sd  XMM4,	XMM4
    movq      [rbp + pc_runaux.pci_loadptr.x],	XMM4
    movq      XMM4,	[rbp + pc_runaux.pci_loadptr.x]
    movq      rax,	XMM4
    jmp       L1566
L1572:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    mov       r10,	[rax]
    mov       rax,	r10
    jmp       L1566
L1573:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    movsxd    r10,	dword [rax]
    mov       rax,	r10
    jmp       L1566
L1574:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    movsx     r10,	word [rax]
    mov       rax,	r10
    jmp       L1566
L1575:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    movsx     r10,	byte [rax]
    mov       rax,	r10
    jmp       L1566
L1576:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    mov       r10,	[rax]
    mov       rax,	r10
    jmp       L1566
L1577:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    mov       r10d,	[rax]
    mov       rax,	r10
    jmp       L1566
L1578:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    movzx     r10,	word [rax]
    mov       rax,	r10
    jmp       L1566
L1579:
    mov       rax,	[rbp + pc_runaux.pci_loadptr.p]
    movzx     r10,	byte [rax]
    mov       rax,	r10
    jmp       L1566
L1568:
    xor       eax,	eax
L1566:
L1565:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc pci_storeptr
pc_runaux.pci_storeptr:
;>>
    %define pc_runaux.pci_storeptr.p 16
    %define pc_runaux.pci_storeptr.a 24
    %define pc_runaux.pci_storeptr.mode 32
    %define pc_runaux.pci_storeptr.size 40
    %define pc_runaux.pci_storeptr.x -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + pc_runaux.pci_storeptr.mode]
    cmp       rax,	11
    jz        L1582
    cmp       rax,	1
    jz        L1583
    jmp       L1584
L1582:
    mov       rcx,	[rbp + pc_runaux.pci_storeptr.p]
    mov       rdx,	[rbp + pc_runaux.pci_storeptr.a]
    mov       r8,	[rbp + pc_runaux.pci_storeptr.size]
    call      memcpy
    jmp       L1581
L1583:
    mov       rax,	[rbp + pc_runaux.pci_storeptr.a]
    movq      XMM4,	rax
    movq      [rbp + pc_runaux.pci_storeptr.x],	XMM4
    movq      XMM4,	[rbp + pc_runaux.pci_storeptr.x]
    cvtsd2ss  XMM4,	XMM4
    mov       rax,	[rbp + pc_runaux.pci_storeptr.p]
    movd      [rax],	XMM4
    jmp       L1581
L1584:
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + pc_runaux.pci_storeptr.mode]
    movzx     r11,	byte [rax + r10]
    cmp       r11,	8
    jz        L1586
    cmp       r11,	4
    jz        L1587
    cmp       r11,	2
    jz        L1588
    jmp       L1589
L1586:
    mov       rax,	[rbp + pc_runaux.pci_storeptr.a]
    mov       r10,	[rbp + pc_runaux.pci_storeptr.p]
    mov       [r10],	rax
    jmp       L1585
L1587:
    mov       eax,	[rbp + pc_runaux.pci_storeptr.a]
    mov       r10,	[rbp + pc_runaux.pci_storeptr.p]
    mov       [r10],	eax
    jmp       L1585
L1588:
    mov       ax,	[rbp + pc_runaux.pci_storeptr.a]
    mov       r10,	[rbp + pc_runaux.pci_storeptr.p]
    mov       [r10],	ax
    jmp       L1585
L1589:
    mov       al,	[rbp + pc_runaux.pci_storeptr.a]
    mov       r10,	[rbp + pc_runaux.pci_storeptr.p]
    mov       [r10],	al
L1585:
L1581:
L1580:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pci_getopndaddr
pc_runaux.pci_getopndaddr:
;>>
    %define pc_runaux.pci_getopndaddr.p 16
    %define pc_runaux.pci_getopndaddr.locals 24
    %define pc_runaux.pci_getopndaddr.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + pc_runaux.pci_getopndaddr.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	1
    jz        L1592
    mov       rcx,	[rbp + pc_runaux.pci_getopndaddr.p]
    lea       rdx,	[rel L5662]
    lea       r8,	[rel L5663]
    call      pc_runaux.pcerrorx
L1592:
L1591:
    mov       rax,	[rbp + pc_runaux.pci_getopndaddr.p]
    mov       r10,	[rax+8]
    mov       [rbp + pc_runaux.pci_getopndaddr.d],	r10
    mov       rax,	[rbp + pc_runaux.pci_getopndaddr.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	3
    jnz       L1594
    mov       rax,	[rbp + pc_runaux.pci_getopndaddr.d]
    mov       r10,	[rax+40]
    mov       rax,	r10
    jmp       L1593
L1594:
    mov       rax,	[rbp + pc_runaux.pci_getopndaddr.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + pc_runaux.pci_getopndaddr.locals]
    lea       rax,	[rax + r10*8]
L1593:
L1590:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pcerrorx
pc_runaux.pcerrorx:
;>>
    %define pc_runaux.pcerrorx.p 16
    %define pc_runaux.pcerrorx.mess 24
    %define pc_runaux.pcerrorx.param 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5664]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_runaux.pcerrorx.mess]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_runaux.pcerrorx.param]
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5665]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_runaux.pcerrorx.p]
    test      rax,	rax
    jz        L1597
    mov       rax,	[rbp + pc_runaux.pcerrorx.p]
    movsxd    r10,	dword [rax+28]
    shr       r10,	8
    and       r10,	16777215
    mov       rax,	r10
    jmp       L1596
L1597:
    xor       eax,	eax
L1596:
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L1595:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pcusopnd
pc_runaux.pcusopnd:
;>>
    %define pc_runaux.pcusopnd.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5666]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_runaux.pcusopnd.p]
    movzx     r10,	byte [rax+1]
    lea       rax,	[pc_tables.opndnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5667]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_runaux.pcusopnd.p]
    movzx     r10,	byte [rax]
    lea       rax,	[pc_tables.pclnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    mov       rax,	[rbp + pc_runaux.pcusopnd.p]
    movsxd    r10,	dword [rax+28]
    shr       r10,	8
    and       r10,	16777215
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L1598:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc docalldll
pc_runaux.docalldll:
;>>
    %define pc_runaux.docalldll.d 16
    %define pc_runaux.docalldll.fnaddr 24
    %define pc_runaux.docalldll.revargs 32
    %define pc_runaux.docalldll.nargs 40
    %define pc_runaux.docalldll.nvars 48
    %define pc_runaux.docalldll.retmode 56
    %define pc_runaux.docalldll.args -800
    %define pc_runaux.docalldll.retval -808
    %define pc_runaux.docalldll.i -816
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	848
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + pc_runaux.docalldll.fnaddr]
    cmp       rax,	0
    jnz       L1601
    mov       rcx,	[rbp + pc_runaux.docalldll.d]
    call      pc_runaux.getdllfnptr
    mov       [rbp + pc_runaux.docalldll.fnaddr],	rax
L1601:
L1600:
    mov       rax,	[rbp + pc_runaux.docalldll.nargs]
    mov       [rbp + pc_runaux.docalldll.i],	rax
    mov       rax,	[rbp + pc_runaux.docalldll.i]
    cmp       rax,	1
    jl        L1604
L1602:
    mov       rax,	[rbp + pc_runaux.docalldll.revargs]
    mov       r10,	[rbp + pc_runaux.docalldll.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + pc_runaux.docalldll.nargs]
    sub       rax,	[rbp + pc_runaux.docalldll.i]
    mov       [rbp + rax*8 + pc_runaux.docalldll.args],	r11
L1603:
    mov       rax,	[rbp + pc_runaux.docalldll.i]
    dec       rax
    mov       [rbp + pc_runaux.docalldll.i],	rax
    cmp       rax,	1
    jge       L1602
L1604:
    sub       rsp,	8
    push      0
    mov       rax,	[rbp + pc_runaux.docalldll.retmode]
    cmp       rax,	1
    jz        L1607
    cmp       rax,	2
    jnz       L1606
L1607:
    mov       rax,	82
    jmp       L1605
L1606:
    mov       rax,	73
L1605:
    mov       rcx,	[rbp + pc_runaux.docalldll.fnaddr]
    mov       rdx,	rax
    mov       r8,	[rbp + pc_runaux.docalldll.nargs]
    lea       r9,	[rbp + pc_runaux.docalldll.args]
    sub       rsp,	32
    call      mwindll.os_calldllfunction
    add       rsp,	48
    mov       [rbp + pc_runaux.docalldll.retval],	rax
    mov       rax,	[rbp + pc_runaux.docalldll.retval]
L1599:
;---------------
    add       rsp,	848
    pop       rbp
    ret       
;End 
;Proc getdllfnptr
pc_runaux.getdllfnptr:
;>>
    %define pc_runaux.getdllfnptr.d 16
    %define pc_runaux.getdllfnptr.fnaddr -8
    %define pc_runaux.getdllfnptr.libindex -16
    %define pc_runaux.getdllfnptr.dllinst -24
    %define pc_runaux.getdllfnptr.procname -32
    %define pc_runaux.getdllfnptr.libname -40
    %define pc_runaux.getdllfnptr.i -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + pc_runaux.getdllfnptr.d]
    mov       r10,	[rax+40]
    mov       [rbp + pc_runaux.getdllfnptr.fnaddr],	r10
    mov       rax,	[rbp + pc_runaux.getdllfnptr.fnaddr]
    test      rax,	rax
    jz        L1610
    mov       rax,	[rbp + pc_runaux.getdllfnptr.fnaddr]
    jmp       L1608
L1610:
L1609:
    mov       rax,	[rbp + pc_runaux.getdllfnptr.d]
    mov       r10,	[rax]
    mov       [rbp + pc_runaux.getdllfnptr.procname],	r10
    mov       rax,	1
    mov       [rbp + pc_runaux.getdllfnptr.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1614
L1611:
    lea       rax,	[pc_decls.plibinst]
    mov       r10,	[rbp + pc_runaux.getdllfnptr.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    mov       rdx,	[rbp + pc_runaux.getdllfnptr.procname]
    call      mwindows.os_getdllprocaddr
    mov       [rbp + pc_runaux.getdllfnptr.fnaddr],	rax
    mov       rax,	[rbp + pc_runaux.getdllfnptr.fnaddr]
    test      rax,	rax
    jz        L1616
    jmp       L1613
L1616:
L1615:
L1612:
    mov       rax,	[rbp + pc_runaux.getdllfnptr.i]
    inc       rax
    mov       [rbp + pc_runaux.getdllfnptr.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L1611
L1614:
    xor       ecx,	ecx
    lea       rdx,	[rel L5668]
    mov       r8,	[rbp + pc_runaux.getdllfnptr.procname]
    call      pc_runaux.pcerrorx
L1613:
    mov       rax,	[rbp + pc_runaux.getdllfnptr.fnaddr]
    mov       r10,	[rbp + pc_runaux.getdllfnptr.d]
    mov       [r10+40],	rax
    mov       rax,	[rbp + pc_runaux.getdllfnptr.fnaddr]
L1608:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc loadlibs
pc_runaux.loadlibs:
;>>
    %define pc_runaux.loadlibs.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + pc_runaux.loadlibs.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1620
L1618:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + pc_runaux.loadlibs.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      mwindows.os_getdllinst
    lea       r10,	[pc_decls.plibinst]
    mov       r11,	[rbp + pc_runaux.loadlibs.i]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[pc_decls.plibinst]
    mov       r10,	[rbp + pc_runaux.loadlibs.i]
    mov       r11,	[rax + r10*8-8]
    test      r11,	r11
    jnz       L1622
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + pc_runaux.loadlibs.i]
    mov       r11,	[rax + r10*8-8]
    xor       ecx,	ecx
    lea       rdx,	[rel L5669]
    mov       r8,	r11
    call      pc_runaux.pcerrorx
L1622:
L1621:
L1619:
    mov       rax,	[rbp + pc_runaux.loadlibs.i]
    inc       rax
    mov       [rbp + pc_runaux.loadlibs.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L1618
L1620:
L1617:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc cmpreal
pc_runaux.cmpreal:
;>>
    %define pc_runaux.cmpreal.cond 16
    %define pc_runaux.cmpreal.x 24
    %define pc_runaux.cmpreal.y 32
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    movq      [rbp+24],	XMM1
    movq      [rbp+32],	XMM2
;---------------
    mov       rax,	[rbp + pc_runaux.cmpreal.cond]
    cmp       rax,	1
    jz        L1625
    cmp       rax,	2
    jz        L1626
    cmp       rax,	3
    jz        L1627
    cmp       rax,	4
    jz        L1628
    cmp       rax,	5
    jz        L1629
    jmp       L1630
L1625:
    movq      XMM4,	[rbp + pc_runaux.cmpreal.x]
    comisd    XMM4,	[rbp + pc_runaux.cmpreal.y]
    setz      al
    movzx     eax,	al
    jmp       L1624
L1626:
    movq      XMM4,	[rbp + pc_runaux.cmpreal.x]
    comisd    XMM4,	[rbp + pc_runaux.cmpreal.y]
    setnz     al
    movzx     eax,	al
    jmp       L1624
L1627:
    movq      XMM4,	[rbp + pc_runaux.cmpreal.x]
    comisd    XMM4,	[rbp + pc_runaux.cmpreal.y]
    setb      al
    movzx     eax,	al
    jmp       L1624
L1628:
    movq      XMM4,	[rbp + pc_runaux.cmpreal.x]
    comisd    XMM4,	[rbp + pc_runaux.cmpreal.y]
    setbe     al
    movzx     eax,	al
    jmp       L1624
L1629:
    movq      XMM4,	[rbp + pc_runaux.cmpreal.x]
    comisd    XMM4,	[rbp + pc_runaux.cmpreal.y]
    setae     al
    movzx     eax,	al
    jmp       L1624
L1630:
    movq      XMM4,	[rbp + pc_runaux.cmpreal.x]
    comisd    XMM4,	[rbp + pc_runaux.cmpreal.y]
    seta      al
    movzx     eax,	al
L1624:
L1623:
;---------------
    pop       rbp
    ret       
;End 
;Proc cmpint
pc_runaux.cmpint:
;>>
    %define pc_runaux.cmpint.cond 16
    %define pc_runaux.cmpint.x 24
    %define pc_runaux.cmpint.y 32
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + pc_runaux.cmpint.cond]
    cmp       rax,	1
    jz        L1633
    cmp       rax,	2
    jz        L1634
    cmp       rax,	3
    jz        L1635
    cmp       rax,	4
    jz        L1636
    cmp       rax,	5
    jz        L1637
    jmp       L1638
L1633:
    mov       rax,	[rbp + pc_runaux.cmpint.x]
    cmp       rax,	[rbp + pc_runaux.cmpint.y]
    setz      al
    movzx     eax,	al
    jmp       L1632
L1634:
    mov       rax,	[rbp + pc_runaux.cmpint.x]
    cmp       rax,	[rbp + pc_runaux.cmpint.y]
    setnz     al
    movzx     eax,	al
    jmp       L1632
L1635:
    mov       rax,	[rbp + pc_runaux.cmpint.x]
    cmp       rax,	[rbp + pc_runaux.cmpint.y]
    setl      al
    movzx     eax,	al
    jmp       L1632
L1636:
    mov       rax,	[rbp + pc_runaux.cmpint.x]
    cmp       rax,	[rbp + pc_runaux.cmpint.y]
    setle     al
    movzx     eax,	al
    jmp       L1632
L1637:
    mov       rax,	[rbp + pc_runaux.cmpint.x]
    cmp       rax,	[rbp + pc_runaux.cmpint.y]
    setge     al
    movzx     eax,	al
    jmp       L1632
L1638:
    mov       rax,	[rbp + pc_runaux.cmpint.x]
    cmp       rax,	[rbp + pc_runaux.cmpint.y]
    setg      al
    movzx     eax,	al
L1632:
L1631:
;---------------
    pop       rbp
    ret       
;End 
;Proc cmpword
pc_runaux.cmpword:
;>>
    %define pc_runaux.cmpword.cond 16
    %define pc_runaux.cmpword.x 24
    %define pc_runaux.cmpword.y 32
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + pc_runaux.cmpword.cond]
    cmp       rax,	1
    jz        L1641
    cmp       rax,	2
    jz        L1642
    cmp       rax,	3
    jz        L1643
    cmp       rax,	4
    jz        L1644
    cmp       rax,	5
    jz        L1645
    jmp       L1646
L1641:
    mov       rax,	[rbp + pc_runaux.cmpword.x]
    cmp       rax,	[rbp + pc_runaux.cmpword.y]
    setz      al
    movzx     eax,	al
    jmp       L1640
L1642:
    mov       rax,	[rbp + pc_runaux.cmpword.x]
    cmp       rax,	[rbp + pc_runaux.cmpword.y]
    setnz     al
    movzx     eax,	al
    jmp       L1640
L1643:
    mov       rax,	[rbp + pc_runaux.cmpword.x]
    cmp       rax,	[rbp + pc_runaux.cmpword.y]
    setb      al
    movzx     eax,	al
    jmp       L1640
L1644:
    mov       rax,	[rbp + pc_runaux.cmpword.x]
    cmp       rax,	[rbp + pc_runaux.cmpword.y]
    setbe     al
    movzx     eax,	al
    jmp       L1640
L1645:
    mov       rax,	[rbp + pc_runaux.cmpword.x]
    cmp       rax,	[rbp + pc_runaux.cmpword.y]
    setae     al
    movzx     eax,	al
    jmp       L1640
L1646:
    mov       rax,	[rbp + pc_runaux.cmpword.x]
    cmp       rax,	[rbp + pc_runaux.cmpword.y]
    seta      al
    movzx     eax,	al
L1640:
L1639:
;---------------
    pop       rbp
    ret       
;End 
;Proc doincr
pc_runaux.doincr:
;>>
    %define pc_runaux.doincr.pu8 16
    %define pc_runaux.doincr.incr 24
    %define pc_runaux.doincr.mode 32
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + pc_runaux.doincr.mode]
    movzx     r11,	byte [rax + r10]
    cmp       r11,	8
    jz        L1649
    cmp       r11,	4
    jz        L1650
    cmp       r11,	2
    jz        L1651
    jmp       L1652
L1649:
    mov       rax,	[rbp + pc_runaux.doincr.pu8]
    mov       r10,	[rbp + pc_runaux.doincr.incr]
    add       [rax],	r10
    jmp       L1648
L1650:
    mov       rax,	[rbp + pc_runaux.doincr.pu8]
    mov       r10d,	[rbp + pc_runaux.doincr.incr]
    add       [rax],	r10d
    jmp       L1648
L1651:
    mov       rax,	[rbp + pc_runaux.doincr.pu8]
    mov       r10w,	[rbp + pc_runaux.doincr.incr]
    add       [rax],	r10w
    jmp       L1648
L1652:
    mov       rax,	[rbp + pc_runaux.doincr.pu8]
    mov       r10b,	[rbp + pc_runaux.doincr.incr]
    add       [rax],	r10b
L1648:
L1647:
;---------------
    pop       rbp
    ret       
;End 
;Proc docmdskip
pc_runaux.docmdskip:
;>>
    %define pc_runaux.docmdskip.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[pc_decls.psymboltable]
    mov       [rbp + pc_runaux.docmdskip.d],	rax
    jmp       L1657
L1654:
    mov       rax,	[rbp + pc_runaux.docmdskip.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L5670]
    call      mlib.eqstring
    test      rax,	rax
    jz        L1659
    mov       rax,	[rbp + pc_runaux.docmdskip.d]
    mov       r10,	[rax+40]
    mov       al,	[pc_decls.pcmdskip]
    mov       [r10],	al
    jmp       L1656
L1659:
L1658:
L1655:
    mov       rax,	[rbp + pc_runaux.docmdskip.d]
    mov       r10,	[rax+8]
    mov       [rbp + pc_runaux.docmdskip.d],	r10
L1657:
    mov       rax,	[rbp + pc_runaux.docmdskip.d]
    test      rax,	rax
    jnz       L1654
L1656:
L1653:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pci_loadbf
pc_runaux.pci_loadbf:
;>>
    %define pc_runaux.pci_loadbf.a 16
    %define pc_runaux.pci_loadbf.i 24
    %define pc_runaux.pci_loadbf.j 32
    %define pc_runaux.pci_loadbf.mask -8
    %define pc_runaux.pci_loadbf.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + pc_runaux.pci_loadbf.j]
    cmp       rax,	[rbp + pc_runaux.pci_loadbf.i]
    jae       L1662
    mov       rax,	[rbp + pc_runaux.pci_loadbf.i]
    mov       r10,	[rbp + pc_runaux.pci_loadbf.j]
    mov       [rbp + pc_runaux.pci_loadbf.j],	rax
    mov       [rbp + pc_runaux.pci_loadbf.i],	r10
L1662:
L1661:
    mov       rax,	[rbp + pc_runaux.pci_loadbf.j]
    sub       rax,	[rbp + pc_runaux.pci_loadbf.i]
    add       rax,	1
    mov       [rbp + pc_runaux.pci_loadbf.n],	rax
    mov       rax,	-1
    mov       cl,	[rbp + pc_runaux.pci_loadbf.n]
    shl       rax,	cl
    not       rax
    mov       cl,	[rbp + pc_runaux.pci_loadbf.i]
    shl       rax,	cl
    mov       [rbp + pc_runaux.pci_loadbf.mask],	rax
    mov       rax,	[rbp + pc_runaux.pci_loadbf.a]
    and       rax,	[rbp + pc_runaux.pci_loadbf.mask]
    mov       cl,	[rbp + pc_runaux.pci_loadbf.i]
    shr       rax,	cl
L1660:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc pci_storebf
pc_runaux.pci_storebf:
;>>
    %define pc_runaux.pci_storebf.a 16
    %define pc_runaux.pci_storebf.i 24
    %define pc_runaux.pci_storebf.j 32
    %define pc_runaux.pci_storebf.x 40
    %define pc_runaux.pci_storebf.mask -8
    %define pc_runaux.pci_storebf.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + pc_runaux.pci_storebf.j]
    cmp       rax,	[rbp + pc_runaux.pci_storebf.i]
    jae       L1665
    mov       rax,	[rbp + pc_runaux.pci_storebf.i]
    mov       r10,	[rbp + pc_runaux.pci_storebf.j]
    mov       [rbp + pc_runaux.pci_storebf.j],	rax
    mov       [rbp + pc_runaux.pci_storebf.i],	r10
L1665:
L1664:
    mov       rax,	[rbp + pc_runaux.pci_storebf.j]
    sub       rax,	[rbp + pc_runaux.pci_storebf.i]
    add       rax,	1
    mov       [rbp + pc_runaux.pci_storebf.n],	rax
    mov       rax,	-1
    mov       cl,	[rbp + pc_runaux.pci_storebf.n]
    shl       rax,	cl
    not       rax
    mov       cl,	[rbp + pc_runaux.pci_storebf.i]
    shl       rax,	cl
    mov       [rbp + pc_runaux.pci_storebf.mask],	rax
    mov       rax,	[rbp + pc_runaux.pci_storebf.x]
    mov       cl,	[rbp + pc_runaux.pci_storebf.i]
    shl       rax,	cl
    and       rax,	[rbp + pc_runaux.pci_storebf.mask]
    mov       [rbp + pc_runaux.pci_storebf.x],	rax
    mov       rax,	[rbp + pc_runaux.pci_storebf.mask]
    not       rax
    mov       r10,	[rbp + pc_runaux.pci_storebf.a]
    and       r10,	rax
    or        r10,	[rbp + pc_runaux.pci_storebf.x]
    mov       rax,	r10
L1663:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc initpass
mc_auxmcl.initpass:
;>>
    %define mc_auxmcl.initpass.d 16
    %define mc_auxmcl.initpass.e -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[mc_decls.regset]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.spillregs]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.spillxregs]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.pcltempflags]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    xor       eax,	eax
    mov       [pc_decls.r13used],	al
    mov       [pc_decls.r11used],	al
    mov       [pc_decls.r10used],	al
    xor       eax,	eax
    mov       [mc_decls.mstackdepth],	rax
    xor       eax,	eax
    mov       [mc_decls.noperands],	rax
    xor       eax,	eax
    mov       [pc_decls.framebytes],	rax
    mov       [pc_decls.paramoffset],	rax
    mov       [pc_decls.frameoffset],	rax
    xor       eax,	eax
    mov       [pc_decls.usedxparams],	rax
    mov       [pc_decls.usedparams],	rax
    xor       eax,	eax
    mov       [pc_decls.highargs],	rax
    mov       [pc_decls.nproccalls],	rax
    xor       eax,	eax
    mov       [pc_decls.localshadow],	al
    xor       eax,	eax
    mov       [pc_decls.assemused],	al
    xor       eax,	eax
    mov       [pc_decls.highxreg],	rax
    mov       [pc_decls.highreg],	rax
    lea       rax,	[mc_decls.pcltempflags]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    mov       rax,	[rbp + mc_auxmcl.initpass.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jnz       L1668
    lea       rcx,	[rel L5671]
    xor       edx,	edx
    call      pc_api.pc_makesymbol
    mov       [rbp + mc_auxmcl.initpass.e],	rax
    mov       rax,	[rbp + mc_auxmcl.initpass.d]
    movzx     r10,	byte [rax+58]
    mov       rax,	[rbp + mc_auxmcl.initpass.e]
    mov       [rax+58],	r10b
    mov       al,	1
    mov       r10,	[rbp + mc_auxmcl.initpass.e]
    mov       [r10+68],	al
    mov       al,	5
    mov       r10,	[rbp + mc_auxmcl.initpass.e]
    mov       [r10+49],	al
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_auxmcl.initpass.e]
    mov       [rax+16],	r10
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rbp + mc_auxmcl.initpass.e]
    mov       [r10+32],	rax
    mov       rax,	[rbp + mc_auxmcl.initpass.e]
    mov       r10,	[pc_decls.currfunc]
    mov       [r10+16],	rax
    mov       rax,	[rbp + mc_auxmcl.initpass.e]
    mov       [pc_decls.blockretname],	rax
L1668:
L1667:
L1666:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_procentry
mc_auxmcl.do_procentry:
;>>
    %define mc_auxmcl.do_procentry.p 16
    %define mc_auxmcl.do_procentry.retmode -8
    %define mc_auxmcl.do_procentry.ntemps -16
    %define mc_auxmcl.do_procentry.hasequiv -24
    %define mc_auxmcl.do_procentry.offset -32
    %define mc_auxmcl.do_procentry.size -40
    %define mc_auxmcl.do_procentry.ax -48
    %define mc_auxmcl.do_procentry.d -56
    %define mc_auxmcl.do_procentry.str -160
    %define mc_auxmcl.do_procentry.newname -264
    %define mc_auxmcl.do_procentry.i -272
    %define mc_auxmcl.do_procentry.r -280
    %define mc_auxmcl.do_procentry.$T1 -288
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	320
;---------------
    mov       rcx,	[mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       eax,	eax
    mov       [pc_decls.bxspilloffset],	rax
    mov       [pc_decls.bxspill],	rax
    mov       [pc_decls.bspill],	rax
    mov       rax,	[pc_decls.highreg]
    cmp       rax,	4
    jl        L1671
    mov       rax,	[pc_decls.highreg]
    sub       rax,	3
    mov       [pc_decls.bspill],	rax
L1671:
L1670:
    mov       rax,	[pc_decls.highxreg]
    cmp       rax,	7
    jl        L1673
    mov       rax,	[pc_decls.highxreg]
    sub       rax,	6
    mov       [pc_decls.bxspill],	rax
L1673:
L1672:
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax+16]
    mov       [rbp + mc_auxmcl.do_procentry.d],	r10
    jmp       L1677
L1674:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movzx     r10,	byte [rax+66]
    test      r10,	r10
    jnz       L1679
    mov       rax,	[pc_decls.paramoffset]
    add       rax,	16
    mov       r10,	[pc_decls.bspill]
    imul      r10,	8
    add       rax,	r10
    mov       r10,	[rbp + mc_auxmcl.do_procentry.d]
    mov       [r10+52],	eax
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movsxd    r10,	dword [rax+52]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.d]
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	7
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1679:
L1678:
    mov       rax,	8
    add       [pc_decls.paramoffset],	rax
L1675:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    mov       r10,	[rax+16]
    mov       [rbp + mc_auxmcl.do_procentry.d],	r10
L1677:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    test      rax,	rax
    jnz       L1674
L1676:
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+58]
    mov       [rbp + mc_auxmcl.do_procentry.retmode],	r10
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax+24]
    mov       [rbp + mc_auxmcl.do_procentry.d],	r10
    jmp       L1683
L1680:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movzx     r10,	byte [rax+58]
    lea       rax,	[pc_tables.psize]
    movzx     r11,	byte [rax + r10]
    mov       [rbp + mc_auxmcl.do_procentry.size],	r11
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jnz       L1685
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    mov       r10d,	[rax+60]
    mov       [rbp + mc_auxmcl.do_procentry.size],	r10
L1685:
L1684:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movzx     r10,	byte [rax+67]
    test      r10,	r10
    jz        L1687
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_procentry.hasequiv],	rax
    jmp       L1686
L1687:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movzx     r10,	byte [rax+66]
    test      r10,	r10
    jnz       L1688
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.size]
    call      mc_libmcl.roundsizetg
    sub       [pc_decls.frameoffset],	rax
    mov       eax,	[pc_decls.frameoffset]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.d]
    mov       [r10+52],	eax
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    movsxd    r10,	dword [rax+52]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.d]
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	7
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1688:
L1686:
L1681:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    mov       r10,	[rax+24]
    mov       [rbp + mc_auxmcl.do_procentry.d],	r10
L1683:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.d]
    test      rax,	rax
    jnz       L1680
L1682:
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_procentry.ntemps],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
L1689:
    lea       rax,	[mc_decls.pcltempflags]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L1693
    inc       qword [rbp + mc_auxmcl.do_procentry.ntemps]
    mov       rax,	8
    sub       [pc_decls.frameoffset],	rax
    lea       rax,	[mc_decls.pcltempopnds]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_auxmcl.do_procentry.ax],	r11
    mov       eax,	[pc_decls.frameoffset]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.ax]
    mov       [r10+12],	eax
    mov       rax,	[rbp + mc_auxmcl.do_procentry.ax]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	[pc_decls.currfunc]
    mov       rdx,	[rbp + mc_auxmcl.do_procentry.i]
    call      mc_writenasm.gettempname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	7
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1693:
L1692:
L1690:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.i]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
    cmp       rax,	20
    jle       L1689
L1691:
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L1695
    mov       rax,	[pc_decls.bxspill]
    imul      rax,	8
    sub       [pc_decls.frameoffset],	rax
    mov       rax,	[pc_decls.frameoffset]
    mov       [pc_decls.bxspilloffset],	rax
L1695:
L1694:
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+84]
    test      r10,	r10
    jz        L1697
    mov       rax,	[pc_decls.currfunc]
    movsx     r10,	word [rax+100]
    test      r10,	r10
    jnz       L1700
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+97]
    test      r10,	r10
    jz        L1699
L1700:
    lea       rcx,	[rel L5672]
    lea       rdx,	[rel L5673]
    call      mc_libmcl.merror
L1699:
L1698:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.ntemps]
    test      rax,	rax
    jz        L1702
    lea       rcx,	[rel L5674]
    lea       rdx,	[rel L5675]
    call      mc_libmcl.merror
L1702:
L1701:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jnz       L1705
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L1704
L1705:
    lea       rcx,	[rel L5676]
    lea       rdx,	[rel L5677]
    call      mc_libmcl.merror
L1704:
L1703:
    call      mc_auxmcl.resetmclentry
    jmp       L1669
L1697:
L1696:
    mov       rax,	[pc_decls.frameoffset]
    neg       rax
    mov       [pc_decls.framebytes],	rax
    mov       eax,	[pc_decls.bspill]
    and       eax,	1
    test      rax,	rax
    jz        L1707
    mov       rax,	[pc_decls.framebytes]
    and       rax,	8
    test      rax,	rax
    jnz       L1709
    mov       rax,	8
    add       [pc_decls.framebytes],	rax
L1709:
L1708:
    jmp       L1706
L1707:
    mov       rax,	[pc_decls.framebytes]
    and       rax,	8
    test      rax,	rax
    jz        L1711
    mov       rax,	8
    add       [pc_decls.framebytes],	rax
L1711:
L1710:
L1706:
    movzx     rax,	byte [pc_decls.localshadow]
    test      rax,	rax
    jz        L1713
    mov       rax,	32
    add       [pc_decls.framebytes],	rax
L1713:
L1712:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jz        L1715
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    mov       rax,	[pc_decls.highreg]
    cmp       rax,	4
    jl        L1718
L1716:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1717:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	[pc_decls.highreg]
    jle       L1716
L1718:
L1715:
L1714:
    mov       rax,	[pc_decls.framebytes]
    test      rax,	rax
    jnz       L1721
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+97]
    test      r10,	r10
    jz        L1720
L1721:
    mov       rcx,	13
    mov       rdx,	[mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[mc_decls.dframeopnd]
    mov       r8,	[mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.framebytes]
    call      mc_libmcl.pushstack
L1720:
L1719:
    call      mc_auxmcl.spillparams
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L1723
    mov       rax,	[pc_decls.bxspilloffset]
    mov       [rbp + mc_auxmcl.do_procentry.offset],	rax
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    mov       rax,	[pc_decls.highxreg]
    cmp       rax,	7
    jl        L1726
L1724:
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	[rbp + mc_auxmcl.do_procentry.offset]
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.do_procentry.ax],	rax
    mov       rax,	8
    add       [rbp + mc_auxmcl.do_procentry.offset],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	18
    mov       rdx,	[rbp + mc_auxmcl.do_procentry.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1725:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	[pc_decls.highxreg]
    jle       L1724
L1726:
L1723:
L1722:
    lea       rcx,	[rel L5678]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L1669:
;---------------
    add       rsp,	320
    pop       rbp
    ret       
;End 
;Proc do_procexit
mc_auxmcl.do_procexit:
;>>
    %define mc_auxmcl.do_procexit.ax -8
    %define mc_auxmcl.do_procexit.offset -16
    %define mc_auxmcl.do_procexit.r -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    lea       rcx,	[rel L5678]
    call      mc_libmcl.mgencomment
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+84]
    test      r10,	r10
    jz        L1729
    mov       rcx,	23
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1727
L1729:
L1728:
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L1731
    mov       rax,	[pc_decls.bxspilloffset]
    mov       [rbp + mc_auxmcl.do_procexit.offset],	rax
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procexit.r],	rax
    mov       rax,	[pc_decls.highxreg]
    cmp       rax,	7
    jl        L1734
L1732:
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	[rbp + mc_auxmcl.do_procexit.offset]
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.do_procexit.ax],	rax
    mov       rax,	8
    add       [rbp + mc_auxmcl.do_procexit.offset],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_procexit.r]
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	18
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procexit.ax]
    call      mc_libmcl.genmc
L1733:
    mov       rax,	[rbp + mc_auxmcl.do_procexit.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procexit.r],	rax
    cmp       rax,	[pc_decls.highxreg]
    jle       L1732
L1734:
L1731:
L1730:
    mov       rax,	[pc_decls.framebytes]
    test      rax,	rax
    jnz       L1737
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+97]
    test      r10,	r10
    jz        L1736
L1737:
    mov       rcx,	[pc_decls.framebytes]
    call      mc_libmcl.popstack
    mov       rcx,	14
    mov       rdx,	[mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1736:
L1735:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jz        L1739
    mov       rax,	[pc_decls.highreg]
    mov       [rbp + mc_auxmcl.do_procexit.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_procexit.r]
    cmp       rax,	4
    jl        L1742
L1740:
    mov       rcx,	[rbp + mc_auxmcl.do_procexit.r]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1741:
    mov       rax,	[rbp + mc_auxmcl.do_procexit.r]
    dec       rax
    mov       [rbp + mc_auxmcl.do_procexit.r],	rax
    cmp       rax,	4
    jge       L1740
L1742:
L1739:
L1738:
    mov       rcx,	23
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1727:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc spillparams
mc_auxmcl.spillparams:
;>>
    %define mc_auxmcl.spillparams.d -8
    %define mc_auxmcl.spillparams.ax -16
    %define mc_auxmcl.spillparams.offset -24
    %define mc_auxmcl.spillparams.regoffset -32
    %define mc_auxmcl.spillparams.firstoffset -40
    %define mc_auxmcl.spillparams.i -48
    %define mc_auxmcl.spillparams.$T1 -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    mov       rax,	16
    mov       [rbp + mc_auxmcl.spillparams.offset],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.spillparams.regoffset],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.spillparams.regoffset],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax+16]
    mov       [rbp + mc_auxmcl.spillparams.d],	r10
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+98]
    test      r10,	r10
    jz        L1745
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movsxd    r10,	dword [rax+52]
    mov       [rbp + mc_auxmcl.spillparams.firstoffset],	r10
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+97]
    mov       [rbp + mc_auxmcl.spillparams.i],	r10
    mov       rax,	[rbp + mc_auxmcl.spillparams.i]
    cmp       rax,	3
    jg        L1748
L1746:
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rax,	[rbp + mc_auxmcl.spillparams.i]
    imul      rax,	8
    add       rax,	[rbp + mc_auxmcl.spillparams.firstoffset]
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.spillparams.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.spillparams.i]
    add       rax,	11
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.spillparams.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1747:
    mov       rax,	[rbp + mc_auxmcl.spillparams.i]
    inc       rax
    mov       [rbp + mc_auxmcl.spillparams.i],	rax
    cmp       rax,	3
    jle       L1746
L1748:
L1745:
L1744:
    jmp       L1752
L1749:
    mov       rax,	[rbp + mc_auxmcl.spillparams.regoffset]
    cmp       rax,	3
    jle       L1754
    jmp       L1751
L1754:
L1753:
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+68]
    test      r10,	r10
    jz        L1756
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+66]
    test      r10,	r10
    jnz       L1758
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movsxd    r10,	dword [rax+52]
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r10
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.spillparams.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	2
    jz        L1760
    cmp       r10,	1
    jz        L1761
    jmp       L1762
L1760:
    mov       rax,	[rbp + mc_auxmcl.spillparams.regoffset]
    add       rax,	1
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	18
    mov       rdx,	[rbp + mc_auxmcl.spillparams.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L1759
L1761:
    mov       rax,	[rbp + mc_auxmcl.spillparams.regoffset]
    add       rax,	1
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    mov       rcx,	[rbp + mc_auxmcl.spillparams.ax]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L1759
L1762:
    mov       rax,	[rbp + mc_auxmcl.spillparams.regoffset]
    add       rax,	11
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.spillparams.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1759:
    jmp       L1757
L1758:
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+66]
    test      r10,	r10
    jz        L1763
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+66]
    cmp       r10,	10
    jg        L1763
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	2
    jz        L1765
    jmp       L1766
L1765:
    mov       rax,	[rbp + mc_auxmcl.spillparams.regoffset]
    add       rax,	1
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+66]
    mov       rcx,	r10
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	18
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L1764
L1766:
    mov       rax,	[rbp + mc_auxmcl.spillparams.regoffset]
    add       rax,	11
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    movzx     r10,	byte [rax+66]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L1764:
L1763:
L1757:
L1756:
L1755:
    mov       rax,	8
    add       [rbp + mc_auxmcl.spillparams.offset],	rax
    inc       qword [rbp + mc_auxmcl.spillparams.regoffset]
L1750:
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    mov       r10,	[rax+16]
    mov       [rbp + mc_auxmcl.spillparams.d],	r10
L1752:
    mov       rax,	[rbp + mc_auxmcl.spillparams.d]
    test      rax,	rax
    jnz       L1749
L1751:
L1743:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
;>>
    %define mc_auxmcl.do_jumptruefalse.p 16
    %define mc_auxmcl.do_jumptruefalse.cond 24
    %define mc_auxmcl.do_jumptruefalse.ax -8
    %define mc_auxmcl.do_jumptruefalse.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_jumptruefalse.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1769
    mov       rcx,	42
    mov       rdx,	[rbp + mc_auxmcl.do_jumptruefalse.ax]
    mov       r8,	[rbp + mc_auxmcl.do_jumptruefalse.ax]
    call      mc_libmcl.genmc
    jmp       L1768
L1769:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.do_jumptruefalse.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_auxmcl.do_jumptruefalse.bx]
    mov       r8,	[rbp + mc_auxmcl.do_jumptruefalse.bx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	74
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_auxmcl.do_jumptruefalse.ax]
    mov       r8,	[rbp + mc_auxmcl.do_jumptruefalse.bx]
    call      mc_libmcl.genmc
L1768:
    mov       rax,	[rbp + mc_auxmcl.do_jumptruefalse.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	[rbp + mc_auxmcl.do_jumptruefalse.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
L1767:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_bitwise
mc_auxmcl.do_bitwise:
;>>
    %define mc_auxmcl.do_bitwise.p 16
    %define mc_auxmcl.do_bitwise.opc 24
    %define mc_auxmcl.do_bitwise.ax -8
    %define mc_auxmcl.do_bitwise.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_bitwise.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_bitwise.bx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_bitwise.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_bitwise.ax]
    mov       r8,	[rbp + mc_auxmcl.do_bitwise.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L1770:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_shift
mc_auxmcl.do_shift:
;>>
    %define mc_auxmcl.do_shift.p 16
    %define mc_auxmcl.do_shift.opc 24
    %define mc_auxmcl.do_shift.ax -8
    %define mc_auxmcl.do_shift.cx -16
    %define mc_auxmcl.do_shift.y -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_shift.ax],	rax
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_auxmcl.do_shift.y],	r11
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L1773
    mov       rax,	[rbp + mc_auxmcl.do_shift.y]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jnz       L1773
    mov       rax,	[rbp + mc_auxmcl.do_shift.y]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_shift.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_shift.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L1772
L1773:
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L1775
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1775:
L1774:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       [rbp + mc_auxmcl.do_shift.cx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_shift.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_shift.ax]
    mov       r8,	[rbp + mc_auxmcl.do_shift.cx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L1777
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1777:
L1776:
L1772:
    call      mc_stackmcl.poppcl
L1771:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc setmclentry
mc_auxmcl.setmclentry:
;>>
    %define mc_auxmcl.setmclentry.p 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mce_oldmccodex],	rax
    mov       rax,	[rbp + mc_auxmcl.setmclentry.p]
    mov       [mc_decls.mccodex],	rax
    mov       rax,	[rbp + mc_auxmcl.setmclentry.p]
    mov       r10,	[rax]
    mov       [mc_decls.mce_nextmcl],	r10
L1778:
;---------------
    pop       rbp
    ret       
;End 
;Proc resetmclentry
mc_auxmcl.resetmclentry:
;>>
    %define mc_auxmcl.resetmclentry.pnew -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    mov       rax,	[mc_decls.mce_nextmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[mc_decls.mccodex]
    mov       [rbp + mc_auxmcl.resetmclentry.pnew],	rax
    mov       rax,	[mc_decls.mce_oldmccodex]
    mov       [mc_decls.mccodex],	rax
    mov       rax,	[rbp + mc_auxmcl.resetmclentry.pnew]
L1779:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc do_pushlowargs
mc_auxmcl.do_pushlowargs:
;>>
    %define mc_auxmcl.do_pushlowargs.nargs 16
    %define mc_auxmcl.do_pushlowargs.nvariadics 24
    %define mc_auxmcl.do_pushlowargs.isptr 32
    %define mc_auxmcl.do_pushlowargs.ax -8
    %define mc_auxmcl.do_pushlowargs.j -16
    %define mc_auxmcl.do_pushlowargs.k -24
    %define mc_auxmcl.do_pushlowargs.nextireg -32
    %define mc_auxmcl.do_pushlowargs.nextxreg -40
    %define mc_auxmcl.do_pushlowargs.mode -48
    %define mc_auxmcl.do_pushlowargs.imode -56
    %define mc_auxmcl.do_pushlowargs.blockret -64
    %define mc_auxmcl.do_pushlowargs.dblock -72
    %define mc_auxmcl.do_pushlowargs.av_1 -80
    %define mc_auxmcl.do_pushlowargs.i -88
    %define mc_auxmcl.do_pushlowargs.$T1 -96
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.nargs]
    cmp       rax,	0
    jnz       L1782
    jmp       L1780
L1782:
L1781:
    lea       rax,	[mc_decls.callblockret]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_auxmcl.do_pushlowargs.blockret],	r11
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.nargs]
    cmp       [pc_decls.highargs],	rax
    jge       L5679
    mov       [pc_decls.highargs],	rax
L5679:
    mov       rax,	11
    mov       [rbp + mc_auxmcl.do_pushlowargs.nextireg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_pushlowargs.nextxreg],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_pushlowargs.k],	rax
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	[rbp + mc_auxmcl.do_pushlowargs.nargs]
    add       rax,	1
    mov       [rbp + mc_auxmcl.do_pushlowargs.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L1785
L1783:
    inc       qword [rbp + mc_auxmcl.do_pushlowargs.k]
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.k]
    cmp       rax,	1
    jnz       L1787
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      rax,	rax
    jz        L1787
    lea       rax,	[mc_decls.callblocksize]
    mov       r10,	[mc_decls.ncalldepth]
    mov       r11d,	[rax + r10*4-4]
    mov       rcx,	r11
    call      mc_libmcl.newblocktemp
    mov       [rbp + mc_auxmcl.do_pushlowargs.dblock],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [r10+68],	al
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	15
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L1786
L1787:
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    sub       rax,	[rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       [rbp + mc_auxmcl.do_pushlowargs.j],	rax
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_auxmcl.do_pushlowargs.j]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_auxmcl.do_pushlowargs.mode],	r11
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.mode]
    cmp       rax,	11
    jz        L1789
    cmp       rax,	2
    jz        L1790
    cmp       rax,	1
    jz        L1790
    jmp       L1791
L1789:
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.j]
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.nextireg]
    call      mc_stackmcl.loadparam
    mov       [rbp + mc_auxmcl.do_pushlowargs.ax],	rax
    lea       rax,	[mc_decls.callargsize]
    mov       r10,	[mc_decls.ncalldepth]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	[rbp + mc_auxmcl.do_pushlowargs.k]
    mov       r11d,	[rax + r10*4-4]
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.ax]
    mov       rdx,	r11
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.k]
    call      mc_auxmcl.copyblockarg
    jmp       L1788
L1790:
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.j]
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    call      mc_stackmcl.loadparam
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    test      rax,	rax
    jz        L1793
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.k]
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    jl        L1793
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.mode]
    cmp       rax,	1
    jnz       L1795
    mov       rax,	5
    jmp       L1794
L1795:
    mov       rax,	6
L1794:
    mov       [rbp + mc_auxmcl.do_pushlowargs.imode],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.mode]
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.nextireg]
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L1793:
L1792:
    jmp       L1788
L1791:
;doint:
L1796:
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.j]
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.nextireg]
    call      mc_stackmcl.loadparam
L1788:
L1786:
    inc       qword [rbp + mc_auxmcl.do_pushlowargs.nextireg]
    inc       qword [rbp + mc_auxmcl.do_pushlowargs.nextxreg]
L1784:
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    dec       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L1783
L1785:
L1780:
;---------------
    add       rsp,	128
    pop       rbp
    ret       
;End 
;Proc do_getretvalue
mc_auxmcl.do_getretvalue:
;>>
    %define mc_auxmcl.do_getretvalue.p 16
    %define mc_auxmcl.do_getretvalue.reg -8
    %define mc_auxmcl.do_getretvalue.xreg -16
    %define mc_auxmcl.do_getretvalue.i -24
    %define mc_auxmcl.do_getretvalue.n -32
    %define mc_auxmcl.do_getretvalue.m -40
    %define mc_auxmcl.do_getretvalue.modes -120
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.p]
    lea       rax,	[rax+32]
    movzx     r10,	byte [rax]
    cmp       r10,	12
    jnz       L1799
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_getretvalue.n],	rax
    jmp       L1801
L1800:
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.p]
    movzx     r10,	byte [rax+3]
    inc       qword [rbp + mc_auxmcl.do_getretvalue.n]
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.n]
    mov       [rbp + rax*8 + mc_auxmcl.do_getretvalue.modes-8],	r10
L1801:
    add       qword [rbp + mc_auxmcl.do_getretvalue.p],	32
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.p]
    movzx     r10,	byte [rax]
    cmp       r10,	12
    jz        L1800
L1802:
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.p]
    sub       rax,	32
    mov       [mc_decls.currpcl],	rax
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.n]
    mov       [rbp + mc_auxmcl.do_getretvalue.i],	rax
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.i]
    cmp       rax,	1
    jl        L1805
L1803:
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.i]
    mov       r10,	[rbp + rax*8 + mc_auxmcl.do_getretvalue.modes-8]
    mov       [rbp + mc_auxmcl.do_getretvalue.m],	r10
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.m]
    cmp       rax,	2
    jg        L1807
    lea       rax,	[mc_decls.multxregs]
    mov       r10,	[rbp + mc_auxmcl.do_getretvalue.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
    jmp       L1806
L1807:
    lea       rax,	[mc_decls.multregs]
    mov       r10,	[rbp + mc_auxmcl.do_getretvalue.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
L1806:
    mov       rcx,	[rbp + mc_auxmcl.do_getretvalue.m]
    mov       rdx,	rax
    call      mc_stackmcl.pushpcl_reg
L1804:
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.i]
    dec       rax
    mov       [rbp + mc_auxmcl.do_getretvalue.i],	rax
    cmp       rax,	1
    jge       L1803
L1805:
    jmp       L1798
L1799:
    mov       rax,	[rbp + mc_auxmcl.do_getretvalue.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	r10
    mov       rdx,	1
    call      mc_stackmcl.pushpcl_reg
L1798:
L1797:
;---------------
    add       rsp,	160
    pop       rbp
    ret       
;End 
;Proc ismemaddr
mc_auxmcl.ismemaddr:
;>>
    %define mc_auxmcl.ismemaddr.n 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_auxmcl.ismemaddr.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L1810
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_auxmcl.ismemaddr.n]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11+1]
    cmp       rax,	2
    jnz       L1810
    mov       rax,	1
    jmp       L1808
L1810:
L1809:
    xor       eax,	eax
L1808:
;---------------
    pop       rbp
    ret       
;End 
;Proc do_incr
mc_auxmcl.do_incr:
;>>
    %define mc_auxmcl.do_incr.p 16
    %define mc_auxmcl.do_incr.incrop 24
    %define mc_auxmcl.do_incr.addop 32
    %define mc_auxmcl.do_incr.mx -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_incr.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_incr.mx],	rax
    mov       rax,	[rbp + mc_auxmcl.do_incr.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jnz       L1813
    mov       rcx,	[rbp + mc_auxmcl.do_incr.incrop]
    mov       rdx,	[rbp + mc_auxmcl.do_incr.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1812
L1813:
    mov       rax,	[rbp + mc_auxmcl.do_incr.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_incr.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_incr.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1812:
    call      mc_stackmcl.poppcl
L1811:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_incrload
mc_auxmcl.do_incrload:
;>>
    %define mc_auxmcl.do_incrload.p 16
    %define mc_auxmcl.do_incrload.incrop 24
    %define mc_auxmcl.do_incrload.addop 32
    %define mc_auxmcl.do_incrload.ax -8
    %define mc_auxmcl.do_incrload.mx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_incrload.mx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     rdi,	byte [r10 + r11-1]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_auxmcl.do_incrload.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.do_incrload.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jnz       L1816
    mov       rcx,	[rbp + mc_auxmcl.do_incrload.incrop]
    mov       rdx,	[rbp + mc_auxmcl.do_incrload.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1815
L1816:
    mov       rax,	[rbp + mc_auxmcl.do_incrload.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_incrload.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_incrload.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1815:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_incrload.ax]
    mov       r8,	[rbp + mc_auxmcl.do_incrload.mx]
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rbp + mc_auxmcl.do_incrload.ax]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [rax + r11-1],	r10b
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L1814:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_loadincr
mc_auxmcl.do_loadincr:
;>>
    %define mc_auxmcl.do_loadincr.p 16
    %define mc_auxmcl.do_loadincr.incrop 24
    %define mc_auxmcl.do_loadincr.addop 32
    %define mc_auxmcl.do_loadincr.ax -8
    %define mc_auxmcl.do_loadincr.mx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_loadincr.mx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_loadincr.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_loadincr.ax]
    mov       r8,	[rbp + mc_auxmcl.do_loadincr.mx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_loadincr.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jnz       L1819
    mov       rcx,	[rbp + mc_auxmcl.do_loadincr.incrop]
    mov       rdx,	[rbp + mc_auxmcl.do_loadincr.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1818
L1819:
    mov       rax,	[rbp + mc_auxmcl.do_loadincr.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_loadincr.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_loadincr.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1818:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
L1817:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_for
mc_auxmcl.do_for:
;>>
    %define mc_auxmcl.do_for.p 16
    %define mc_auxmcl.do_for.incop 24
    %define mc_auxmcl.do_for.addop 32
    %define mc_auxmcl.do_for.cond 40
    %define mc_auxmcl.do_for.q -8
    %define mc_auxmcl.do_for.r -16
    %define mc_auxmcl.do_for.ax -24
    %define mc_auxmcl.do_for.bx -32
    %define mc_auxmcl.do_for.cx -40
    %define mc_auxmcl.do_for.dx -48
    %define mc_auxmcl.do_for.mx -56
    %define mc_auxmcl.do_for.reg -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_for.p]
    lea       rax,	[rax+32]
    mov       [rbp + mc_auxmcl.do_for.q],	rax
    mov       rax,	[rbp + mc_auxmcl.do_for.q]
    lea       rax,	[rax+32]
    mov       [mc_decls.currpcl],	rax
    mov       [rbp + mc_auxmcl.do_for.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_for.q]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_for.mx],	rax
    mov       rax,	[rbp + mc_auxmcl.do_for.q]
    mov       r10,	[rax+8]
    movzx     rax,	byte [r10+66]
    test      rax,	rax
    jz        L1822
    mov       rax,	[rbp + mc_auxmcl.do_for.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jnz       L1824
    mov       rcx,	[rbp + mc_auxmcl.do_for.incop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1823
L1824:
    mov       rax,	[rbp + mc_auxmcl.do_for.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1823:
    mov       rax,	[rbp + mc_auxmcl.do_for.mx]
    mov       [rbp + mc_auxmcl.do_for.ax],	rax
    jmp       L1821
L1822:
    call      mc_stackmcl.getworkireg
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_for.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_for.ax]
    mov       r8,	[rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_for.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jnz       L1826
    mov       rcx,	[rbp + mc_auxmcl.do_for.incop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1825
L1826:
    mov       rax,	[rbp + mc_auxmcl.do_for.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1825:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	[rbp + mc_auxmcl.do_for.ax]
    call      mc_libmcl.genmc
L1821:
    mov       rax,	[rbp + mc_auxmcl.do_for.r]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jnz       L1828
    mov       rax,	[rbp + mc_auxmcl.do_for.r]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_for.bx],	rax
    jmp       L1827
L1828:
    mov       rax,	[rbp + mc_auxmcl.do_for.r]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_for.bx],	rax
L1827:
    mov       rcx,	43
    mov       rdx,	[rbp + mc_auxmcl.do_for.ax]
    mov       r8,	[rbp + mc_auxmcl.do_for.bx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_for.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	[rbp + mc_auxmcl.do_for.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
L1820:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc scaleindex
mc_auxmcl.scaleindex:
;>>
    %define mc_auxmcl.scaleindex.ax 16
    %define mc_auxmcl.scaleindex.scale 24
    %define mc_auxmcl.scaleindex.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.scaleindex.scale]
    cmp       rax,	1
    jz        L1832
    cmp       rax,	2
    jz        L1832
    cmp       rax,	4
    jz        L1832
    cmp       rax,	8
    jnz       L1831
L1832:
    mov       rax,	[rbp + mc_auxmcl.scaleindex.scale]
    jmp       L1829
L1831:
L1830:
    mov       rcx,	[rbp + mc_auxmcl.scaleindex.ax]
    mov       rdx,	[rbp + mc_auxmcl.scaleindex.scale]
    call      mc_auxmcl.mulimm
    mov       rax,	1
L1829:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mulimm
mc_auxmcl.mulimm:
;>>
    %define mc_auxmcl.mulimm.ax 16
    %define mc_auxmcl.mulimm.n 24
    %define mc_auxmcl.mulimm.shifts -8
    %define mc_auxmcl.mulimm.m -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.mulimm.n]
    cmp       rax,	0
    jz        L1835
    cmp       rax,	1
    jz        L1836
    cmp       rax,	-1
    jz        L1837
    jmp       L1838
L1835:
    mov       rcx,	41
    mov       rdx,	[rbp + mc_auxmcl.mulimm.ax]
    mov       r8,	[rbp + mc_auxmcl.mulimm.ax]
    call      mc_libmcl.genmc
    jmp       L1833
L1836:
    jmp       L1833
L1837:
    mov       rcx,	51
    mov       rdx,	[rbp + mc_auxmcl.mulimm.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1833
L1838:
L1834:
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.mulimm.shifts],	rax
    mov       rax,	[rbp + mc_auxmcl.mulimm.n]
    mov       [rbp + mc_auxmcl.mulimm.m],	rax
    jmp       L1840
L1839:
    sar       qword [rbp + mc_auxmcl.mulimm.m],	1
    inc       qword [rbp + mc_auxmcl.mulimm.shifts]
L1840:
    mov       eax,	[rbp + mc_auxmcl.mulimm.m]
    and       eax,	1
    test      rax,	rax
    jz        L1839
L1841:
    mov       rax,	[rbp + mc_auxmcl.mulimm.shifts]
    test      rax,	rax
    jz        L1843
    mov       rcx,	[rbp + mc_auxmcl.mulimm.shifts]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	44
    mov       rdx,	[rbp + mc_auxmcl.mulimm.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1843:
L1842:
    mov       rax,	[rbp + mc_auxmcl.mulimm.m]
    cmp       rax,	1
    jz        L1845
    cmp       rax,	3
    jz        L1846
    cmp       rax,	5
    jz        L1846
    cmp       rax,	9
    jz        L1846
    jmp       L1847
L1845:
    jmp       L1833
L1846:
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_auxmcl.mulimm.m]
    sub       rax,	1
    mov       r10,	[rbp + mc_auxmcl.mulimm.ax]
    movzx     r11,	byte [r10+10]
    mov       r10,	[rbp + mc_auxmcl.mulimm.ax]
    movzx     rdi,	byte [r10+10]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	15
    mov       rdx,	[rbp + mc_auxmcl.mulimm.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L1844
L1847:
    mov       rax,	[rbp + mc_auxmcl.mulimm.shifts]
    test      rax,	rax
    jz        L1849
    mov       al,	35
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+24],	al
    mov       rcx,	[rbp + mc_auxmcl.mulimm.n]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+16],	rax
    jmp       L1848
L1849:
    mov       rcx,	[rbp + mc_auxmcl.mulimm.n]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	35
    mov       rdx,	[rbp + mc_auxmcl.mulimm.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L1848:
L1844:
L1833:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_addrmode
mc_auxmcl.do_addrmode:
;>>
    %define mc_auxmcl.do_addrmode.p 16
    %define mc_auxmcl.do_addrmode.px -8
    %define mc_auxmcl.do_addrmode.ax -16
    %define mc_auxmcl.do_addrmode.bx -24
    %define mc_auxmcl.do_addrmode.scale -32
    %define mc_auxmcl.do_addrmode.extra -40
    %define mc_auxmcl.do_addrmode.offset -48
    %define mc_auxmcl.do_addrmode.reg -56
    %define mc_auxmcl.do_addrmode.regix -64
    %define mc_auxmcl.do_addrmode.d -72
    %define mc_auxmcl.do_addrmode.q -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	r10
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    r10,	dword [rax+20]
    mov       [rbp + mc_auxmcl.do_addrmode.extra],	r10
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_addrmode.q],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L1852
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    mov       r10,	[rax+8]
    imul      r10,	[rbp + mc_auxmcl.do_addrmode.scale]
    add       r10,	[rbp + mc_auxmcl.do_addrmode.extra]
    mov       [rbp + mc_auxmcl.do_addrmode.offset],	r10
L1852:
L1851:
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_addrmode.px],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    call      mc_auxmcl.ismemaddr
    test      rax,	rax
    jz        L1854
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       r11,	[rax + r10*8-16]
    mov       rax,	[r11+8]
    mov       [rbp + mc_auxmcl.do_addrmode.d],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	3
    jnz       L1858
    movzx     rax,	byte [mc_decls.phighmem]
    cmp       rax,	2
    jz        L1857
L1858:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	5
    jnz       L1856
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jnz       L1856
L1857:
    jmp       L1859
L1856:
L1855:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L1861
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	[rbp + mc_auxmcl.do_addrmode.offset]
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.do_addrmode.px],	rax
    jmp       L1860
L1861:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.do_addrmode.bx],	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.bx]
    movzx     r10,	byte [rax+10]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	[rbp + mc_auxmcl.do_addrmode.extra]
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.do_addrmode.px],	rax
L1860:
    jmp       L1853
L1854:
;skip:
L1859:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_addrmode.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L1863
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	[rbp + mc_auxmcl.do_addrmode.offset]
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.do_addrmode.px],	rax
    jmp       L1862
L1863:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.do_addrmode.bx],	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.bx]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.ax]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	[rbp + mc_auxmcl.do_addrmode.extra]
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rbp + mc_auxmcl.do_addrmode.px],	rax
L1862:
L1853:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movzx     r10,	byte [rax+3]
    lea       rax,	[pc_tables.psize]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.px]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.px]
L1850:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc dolea
mc_auxmcl.dolea:
;>>
    %define mc_auxmcl.dolea.ax 16
    %define mc_auxmcl.dolea.px 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.dolea.px]
    movzx     r10,	byte [rax+11]
    mov       rax,	[rbp + mc_auxmcl.dolea.px]
    movzx     r11,	word [rax+8]
    shr       r11,	12
    and       r11,	15
    cmp       r11,	r10
    jnz       L1868
    mov       rax,	[rbp + mc_auxmcl.dolea.px]
    movsxd    r10,	dword [rax+12]
    cmp       r10,	r11
    jnz       L1868
    cmp       r10,	0
    jnz       L1868
    mov       rax,	1
    jmp       L1869
L1868:
    xor       eax,	eax
L1869:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L1867
    mov       rax,	[rbp + mc_auxmcl.dolea.px]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + mc_auxmcl.dolea.ax]
    movzx     r11,	byte [rax+10]
    cmp       r10,	r11
    jz        L1866
L1867:
    mov       rcx,	15
    mov       rdx,	[rbp + mc_auxmcl.dolea.ax]
    mov       r8,	[rbp + mc_auxmcl.dolea.px]
    call      mc_libmcl.genmc
L1866:
L1865:
L1864:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_binto
mc_auxmcl.do_binto:
;>>
    %define mc_auxmcl.do_binto.p 16
    %define mc_auxmcl.do_binto.opc 24
    %define mc_auxmcl.do_binto.fopc 32
    %define mc_auxmcl.do_binto.ax -8
    %define mc_auxmcl.do_binto.bx -16
    %define mc_auxmcl.do_binto.rx -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L1872
    mov       rcx,	[rbp + mc_auxmcl.do_binto.p]
    mov       rdx,	[rbp + mc_auxmcl.do_binto.fopc]
    call      mc_auxmcl.do_binto_float
    jmp       L1870
L1872:
L1871:
    mov       rax,	[rbp + mc_auxmcl.do_binto.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_binto.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.do_binto.p]
    movzx     r10,	byte [rax+3]
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_binto.bx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_binto.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_binto.ax]
    mov       r8,	[rbp + mc_auxmcl.do_binto.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1870:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc do_binto_float
mc_auxmcl.do_binto_float:
;>>
    %define mc_auxmcl.do_binto_float.p 16
    %define mc_auxmcl.do_binto_float.opc 24
    %define mc_auxmcl.do_binto_float.px -8
    %define mc_auxmcl.do_binto_float.bx -16
    %define mc_auxmcl.do_binto_float.cx -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_binto_float.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_binto_float.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_binto_float.cx],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_binto_float.cx]
    mov       r8,	[rbp + mc_auxmcl.do_binto_float.px]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	[rbp + mc_auxmcl.do_binto_float.opc]
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_auxmcl.do_binto_float.cx]
    mov       r8,	[rbp + mc_auxmcl.do_binto_float.bx]
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_binto_float.px]
    mov       r8,	[rbp + mc_auxmcl.do_binto_float.cx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1873:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc do_shiftnto
mc_auxmcl.do_shiftnto:
;>>
    %define mc_auxmcl.do_shiftnto.p 16
    %define mc_auxmcl.do_shiftnto.opc 24
    %define mc_auxmcl.do_shiftnto.px -8
    %define mc_auxmcl.do_shiftnto.cx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_shiftnto.px],	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-2]
    cmp       r11,	0
    jnz       L1876
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       r11,	[rax + r10*8-16]
    movzx     rax,	byte [r11+1]
    cmp       rax,	4
    jnz       L1876
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       r11,	[rax + r10*8-16]
    mov       rax,	[r11+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_shiftnto.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_shiftnto.px]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L1875
L1876:
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L1878
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1878:
L1877:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       [rbp + mc_auxmcl.do_shiftnto.cx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_shiftnto.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_shiftnto.px]
    mov       r8,	[rbp + mc_auxmcl.do_shiftnto.cx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L1880
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1880:
L1879:
L1875:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1874:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_divrem
mc_auxmcl.do_divrem:
;>>
    %define mc_auxmcl.do_divrem.p 16
    %define mc_auxmcl.do_divrem.issigned 24
    %define mc_auxmcl.do_divrem.isdiv 32
    %define mc_auxmcl.do_divrem.ax -8
    %define mc_auxmcl.do_divrem.bx -16
    %define mc_auxmcl.do_divrem.px -24
    %define mc_auxmcl.do_divrem.q -32
    %define mc_auxmcl.do_divrem.opc -40
    %define mc_auxmcl.do_divrem.n -48
    %define mc_auxmcl.do_divrem.shifts -56
    %define mc_auxmcl.do_divrem.fdivto -64
    %define mc_auxmcl.do_divrem.locyy -72
    %define mc_auxmcl.do_divrem.loczz -80
    %define mc_auxmcl.do_divrem.$T1 -88
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	rax
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.p]
    movzx     r10,	byte [rax]
    cmp       r10,	93
    jz        L1884
    cmp       r10,	94
    jnz       L1883
L1884:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       r10,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	r10
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_divrem.ax],	rax
    mov       al,	1
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.ax]
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       [rbp + mc_auxmcl.do_divrem.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_auxmcl.do_divrem.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_divrem.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.ax]
    mov       r8,	[rbp + mc_auxmcl.do_divrem.px]
    call      mc_libmcl.genmc
    jmp       L1882
L1883:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_divrem.ax],	rax
L1882:
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_divrem.q],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.q]
    test      rax,	rax
    jz        L1886
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	1
    jnz       L1886
    mov       rax,	[rbp + mc_auxmcl.do_divrem.q]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.do_divrem.n],	r10
    mov       rax,	[rbp + mc_auxmcl.do_divrem.n]
    cmp       rax,	0
    jz        L1888
    cmp       rax,	1
    jz        L1889
    jmp       L1890
L1888:
    lea       rcx,	[rel L5680]
    lea       rdx,	[rel L5681]
    call      mc_libmcl.merror
    jmp       L1887
L1889:
    call      mc_stackmcl.poppcl
    jmp       L1881
L1890:
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.n]
    call      mc_libmcl.ispoweroftwo
    mov       [rbp + mc_auxmcl.do_divrem.shifts],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.shifts]
    test      rax,	rax
    jz        L1892
    movzx     rax,	byte [rbp + mc_auxmcl.do_divrem.fdivto]
    test      rax,	rax
    jnz       L1892
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.shifts]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L1894
    mov       rax,	45
    jmp       L1893
L1894:
    mov       rax,	46
L1893:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.ax]
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1881
L1892:
L1891:
L1887:
L1886:
L1885:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_divrem.bx],	rax
    call      mc_auxmcl.saverdx
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_divrem.bx],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L1896
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r11,	byte [r10 + rax]
    cmp       r11,	8
    jz        L1898
    cmp       r11,	4
    jz        L1899
    cmp       r11,	2
    jz        L1900
    jmp       L1901
L1898:
    mov       rax,	58
    jmp       L1897
L1899:
    mov       rax,	57
    jmp       L1897
L1900:
    mov       rax,	56
    jmp       L1897
L1901:
    lea       rcx,	[rel L5682]
    lea       rdx,	[rel L5683]
    call      mc_libmcl.merror
    xor       eax,	eax
L1897:
    mov       [rbp + mc_auxmcl.do_divrem.opc],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.opc]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	37
    mov       [rbp + mc_auxmcl.do_divrem.opc],	rax
    jmp       L1895
L1896:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	41
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    mov       rax,	38
    mov       [rbp + mc_auxmcl.do_divrem.opc],	rax
L1895:
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.bx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	0
    jz        L1903
    cmp       rax,	2
    jz        L1904
    jmp       L1905
L1903:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L1902
L1904:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.bx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L1905:
L1902:
    call      mc_auxmcl.restorerdx
    movzx     rax,	byte [rbp + mc_auxmcl.do_divrem.fdivto]
    test      rax,	rax
    jz        L1907
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.do_divrem.bx],	rax
    mov       rcx,	14
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.bx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.bx]
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
L1907:
L1906:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	2
    jz        L1909
    call      mc_stackmcl.poppcl
L1909:
L1908:
L1881:
;---------------
    add       rsp,	128
    pop       rbp
    ret       
;End 
;Proc fixdivopnds
mc_auxmcl.fixdivopnds:
;>>
    %define mc_auxmcl.fixdivopnds.locyy 16
    %define mc_auxmcl.fixdivopnds.loczz 24
    %define mc_auxmcl.fixdivopnds.regx -8
    %define mc_auxmcl.fixdivopnds.regy -16
    %define mc_auxmcl.fixdivopnds.zop -24
    %define mc_auxmcl.fixdivopnds.bx -32
    %define mc_auxmcl.fixdivopnds.ax -40
    %define mc_auxmcl.fixdivopnds.$T1 -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_auxmcl.fixdivopnds.locyy]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_auxmcl.fixdivopnds.regx],	r11
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_auxmcl.fixdivopnds.loczz]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_auxmcl.fixdivopnds.regy],	r11
    mov       rax,	[rbp + mc_auxmcl.fixdivopnds.regx]
    cmp       rax,	1
    jnz       L1912
    jmp       L1910
L1912:
L1911:
    mov       rcx,	[rbp + mc_auxmcl.fixdivopnds.locyy]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.fixdivopnds.bx],	rax
    mov       rcx,	[rbp + mc_auxmcl.fixdivopnds.loczz]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.fixdivopnds.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.fixdivopnds.regy]
    cmp       rax,	1
    jnz       L1914
    mov       rcx,	28
    mov       rdx,	[rbp + mc_auxmcl.fixdivopnds.bx]
    mov       r8,	[rbp + mc_auxmcl.fixdivopnds.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.fixdivopnds.locyy]
    mov       rdx,	[rbp + mc_auxmcl.fixdivopnds.loczz]
    call      mc_stackmcl.swapopnds
    jmp       L1910
L1914:
L1913:
    movzx     rax,	byte [mc_decls.regset]
    cmp       rax,	0
    jnz       L1916
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixdivopnds.bx]
    call      mc_libmcl.genmc
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_auxmcl.fixdivopnds.regx]
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_auxmcl.fixdivopnds.locyy]
    mov       [r10 + r11-1],	al
    mov       al,	1
    mov       [mc_decls.regset],	al
    jmp       L1910
L1916:
L1915:
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.fixdivopnds.zop],	rax
    mov       rax,	[rbp + mc_auxmcl.fixdivopnds.zop]
    cmp       rax,	1
    jl        L1920
L1917:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_auxmcl.fixdivopnds.zop]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jnz       L1922
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_auxmcl.fixdivopnds.zop]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jnz       L1922
    jmp       L1919
L1922:
L1921:
L1918:
    mov       rax,	[rbp + mc_auxmcl.fixdivopnds.zop]
    dec       rax
    mov       [rbp + mc_auxmcl.fixdivopnds.zop],	rax
    cmp       rax,	1
    jge       L1917
L1920:
    jmp       L1910
L1919:
    mov       rcx,	[rbp + mc_auxmcl.fixdivopnds.locyy]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.fixdivopnds.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_auxmcl.fixdivopnds.locyy]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_auxmcl.fixdivopnds.zop]
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       dil,	[r10]
    mov       [r10],	r11b
    mov       [rax],	dil
L1910:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc saverdx
mc_auxmcl.saverdx:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    movzx     rax,	byte [pc_decls.r11used]
    test      rax,	rax
    jz        L1925
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1925:
L1924:
L1923:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc restorerdx
mc_auxmcl.restorerdx:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    movzx     rax,	byte [pc_decls.r11used]
    test      rax,	rax
    jz        L1928
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1928:
L1927:
L1926:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc clearblock
mc_auxmcl.clearblock:
;>>
    %define mc_auxmcl.clearblock.ax 16
    %define mc_auxmcl.clearblock.n 24
    %define mc_auxmcl.clearblock.rx -8
    %define mc_auxmcl.clearblock.rcount -16
    %define mc_auxmcl.clearblock.nwords -24
    %define mc_auxmcl.clearblock.lab -32
    %define mc_auxmcl.clearblock.oddbytes -40
    %define mc_auxmcl.clearblock.offset -48
    %define mc_auxmcl.clearblock.workreg -56
    %define mc_auxmcl.clearblock.countreg -64
    %define mc_auxmcl.clearblock.av_1 -72
    %define mc_auxmcl.clearblock.i -80
    %define mc_auxmcl.clearblock.$T1 -88
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + mc_auxmcl.clearblock.oddbytes],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.oddbytes]
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    sar       rax,	3
    mov       [rbp + mc_auxmcl.clearblock.nwords],	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.clearblock.rx],	rax
    mov       rcx,	41
    mov       rdx,	[rbp + mc_auxmcl.clearblock.rx]
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.clearblock.offset],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.nwords]
    cmp       rax,	1
    jl        L1931
    cmp       rax,	8
    jg        L1931
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.nwords]
    mov       [rbp + mc_auxmcl.clearblock.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.av_1]
    cmp       rax,	0
    jle       L1934
L1932:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.clearblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	8
    add       [rbp + mc_auxmcl.clearblock.offset],	rax
L1933:
    dec       qword [rbp + mc_auxmcl.clearblock.av_1]
    jnz       L1932
L1934:
    jmp       L1930
L1931:
    mov       rax,	[rbp + mc_auxmcl.clearblock.nwords]
    cmp       rax,	0
    jz        L1935
    mov       rax,	[rbp + mc_auxmcl.clearblock.nwords]
    and       rax,	3
    test      rax,	rax
    jz        L1937
    call      mc_stackmcl.getworkireg
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.clearblock.rcount],	rax
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [rbp + mc_auxmcl.clearblock.lab],	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.nwords]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.clearblock.rcount]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.clearblock.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	54
    mov       rdx,	[rbp + mc_auxmcl.clearblock.rcount]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.clearblock.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.clearblock.offset],	rax
    jmp       L1936
L1937:
    call      mc_stackmcl.getworkireg
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.clearblock.rcount],	rax
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [rbp + mc_auxmcl.clearblock.lab],	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.nwords]
    sar       rax,	2
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.clearblock.rcount]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.clearblock.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	1
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
L1938:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.clearblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	8
    add       [rbp + mc_auxmcl.clearblock.offset],	rax
L1939:
    mov       rax,	[rbp + mc_auxmcl.clearblock.i]
    inc       rax
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
    cmp       rax,	4
    jle       L1938
L1940:
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	54
    mov       rdx,	[rbp + mc_auxmcl.clearblock.rcount]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.clearblock.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.clearblock.offset],	rax
L1936:
L1935:
L1930:
    mov       rax,	[rbp + mc_auxmcl.clearblock.oddbytes]
    test      rax,	rax
    jz        L1942
    mov       rax,	[rbp + mc_auxmcl.clearblock.oddbytes]
    mov       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	4
    jl        L1944
    mov       rcx,	[rbp + mc_auxmcl.clearblock.rx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.rx],	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.clearblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	4
    add       [rbp + mc_auxmcl.clearblock.offset],	rax
L1944:
L1943:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	2
    jl        L1946
    mov       rcx,	[rbp + mc_auxmcl.clearblock.rx]
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.rx],	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.clearblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	2
    add       [rbp + mc_auxmcl.clearblock.offset],	rax
L1946:
L1945:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	1
    jnz       L1948
    mov       rcx,	[rbp + mc_auxmcl.clearblock.rx]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.rx],	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.clearblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.rx]
    call      mc_libmcl.genmc
L1948:
L1947:
L1942:
L1941:
L1929:
;---------------
    add       rsp,	128
    pop       rbp
    ret       
;End 
;Proc do_blockdata
mc_auxmcl.do_blockdata:
;>>
    %define mc_auxmcl.do_blockdata.p 16
    %define mc_auxmcl.do_blockdata.s -8
    %define mc_auxmcl.do_blockdata.d -16
    %define mc_auxmcl.do_blockdata.n -24
    %define mc_auxmcl.do_blockdata.nqwords -32
    %define mc_auxmcl.do_blockdata.nwords -40
    %define mc_auxmcl.do_blockdata.r -48
    %define mc_auxmcl.do_blockdata.av_1 -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.p]
    mov       r10d,	[rax+4]
    mov       [rbp + mc_auxmcl.do_blockdata.n],	r10
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.n]
    cmp       rax,	0
    jnz       L1951
    jmp       L1949
L1951:
L1950:
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.n]
    sar       rax,	3
    mov       [rbp + mc_auxmcl.do_blockdata.nwords],	rax
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.do_blockdata.d],	r10
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.nwords]
    mov       [rbp + mc_auxmcl.do_blockdata.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.av_1]
    cmp       rax,	0
    jle       L1954
L1952:
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.d]
    add       qword [rbp + mc_auxmcl.do_blockdata.d],	8
    mov       r10,	[rax]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1953:
    dec       qword [rbp + mc_auxmcl.do_blockdata.av_1]
    jnz       L1952
L1954:
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.nwords]
    imul      rax,	8
    mov       r10,	[rbp + mc_auxmcl.do_blockdata.n]
    sub       r10,	rax
    mov       [rbp + mc_auxmcl.do_blockdata.r],	r10
    mov       rax,	[rbp + mc_auxmcl.do_blockdata.r]
    test      rax,	rax
    jz        L1956
    mov       rcx,	[rbp + mc_auxmcl.do_blockdata.d]
    mov       rdx,	[rbp + mc_auxmcl.do_blockdata.r]
    mov       r8,	66
    call      mc_auxmcl.genstring_db
L1956:
L1955:
    lea       rcx,	[rel L5684]
    call      mc_libmcl.mgencomment
L1949:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc copyblock
mc_auxmcl.copyblock:
;>>
    %define mc_auxmcl.copyblock.ax 16
    %define mc_auxmcl.copyblock.bx 24
    %define mc_auxmcl.copyblock.n 32
    %define mc_auxmcl.copyblock.savedest 40
    %define mc_auxmcl.copyblock.rx -8
    %define mc_auxmcl.copyblock.rcount -16
    %define mc_auxmcl.copyblock.nwords -24
    %define mc_auxmcl.copyblock.lab -32
    %define mc_auxmcl.copyblock.oddbytes -40
    %define mc_auxmcl.copyblock.offset -48
    %define mc_auxmcl.copyblock.workreg -56
    %define mc_auxmcl.copyblock.countreg -64
    %define mc_auxmcl.copyblock.axreg -72
    %define mc_auxmcl.copyblock.saved -80
    %define mc_auxmcl.copyblock.av_1 -88
    %define mc_auxmcl.copyblock.$T1 -96
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	16
    jnz       L1959
    mov       rcx,	2
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.copyblock.rx],	rax
    mov       rcx,	91
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       r8,	[rbp + mc_auxmcl.copyblock.bx]
    call      mc_libmcl.genmc
    mov       rcx,	91
    mov       rdx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       r8,	[rbp + mc_auxmcl.copyblock.rx]
    call      mc_libmcl.genmc
    jmp       L1957
L1959:
L1958:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + mc_auxmcl.copyblock.oddbytes],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    sar       rax,	3
    mov       [rbp + mc_auxmcl.copyblock.nwords],	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.copyblock.rx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.nwords]
    cmp       rax,	1
    jl        L1961
    cmp       rax,	4
    jg        L1961
    mov       rcx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.copyblock.ax],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.bx]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.copyblock.bx],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.nwords]
    mov       [rbp + mc_auxmcl.copyblock.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.av_1]
    cmp       rax,	0
    jle       L1964
L1962:
    mov       rcx,	[rbp + mc_auxmcl.copyblock.bx]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	8
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L1963:
    dec       qword [rbp + mc_auxmcl.copyblock.av_1]
    jnz       L1962
L1964:
    jmp       L1960
L1961:
    mov       rax,	[rbp + mc_auxmcl.copyblock.nwords]
    cmp       rax,	0
    jz        L1965
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.copyblock.rcount],	rax
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [rbp + mc_auxmcl.copyblock.lab],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.savedest]
    test      rax,	rax
    jz        L1967
    mov       rax,	[rbp + mc_auxmcl.copyblock.ax]
    movzx     r10,	byte [rax+10]
    mov       [rbp + mc_auxmcl.copyblock.axreg],	r10
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
L1967:
L1966:
    mov       rcx,	[rbp + mc_auxmcl.copyblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.copyblock.ax],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.bx]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.copyblock.bx],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.ax]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rcx,	[rbp + mc_auxmcl.copyblock.nwords]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rcount]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.copyblock.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       r8,	[rbp + mc_auxmcl.copyblock.bx]
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       r8,	[rbp + mc_auxmcl.copyblock.rx]
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.bx]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	54
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rcount]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.copyblock.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
L1965:
L1960:
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    test      rax,	rax
    jz        L1969
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	4
    jl        L1971
    mov       rcx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.copyblock.rx],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.bx]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	4
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L1971:
L1970:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	2
    jl        L1973
    mov       rcx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.copyblock.rx],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.bx]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.rx]
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	2
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L1973:
L1972:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	1
    jnz       L1975
    mov       rcx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.copyblock.rx],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.bx]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblock.rx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.copyblock.ax]
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.rx]
    call      mc_libmcl.genmc
L1975:
L1974:
L1969:
L1968:
    movzx     rax,	byte [rbp + mc_auxmcl.copyblock.saved]
    test      rax,	rax
    jz        L1977
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1977:
L1976:
L1957:
;---------------
    add       rsp,	128
    pop       rbp
    ret       
;End 
;Proc genstringtable
mc_auxmcl.genstringtable:
;>>
    %define mc_auxmcl.genstringtable.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.cstringlist]
    test      rax,	rax
    jnz       L1980
    jmp       L1978
L1980:
L1979:
    lea       rcx,	[rel L5685]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rax,	[mc_decls.kk0used]
    test      rax,	rax
    jz        L1982
    mov       rcx,	[mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L1982:
L1981:
    mov       rax,	[mc_decls.cstringlist]
    mov       [rbp + mc_auxmcl.genstringtable.p],	rax
    jmp       L1986
L1983:
    mov       rax,	[rbp + mc_auxmcl.genstringtable.p]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.genstringtable.p]
    mov       r10,	[rax]
    mov       rcx,	r10
    mov       rdx,	-1
    xor       r8d,	r8d
    call      mc_auxmcl.genstring_db
L1984:
    mov       rax,	[rbp + mc_auxmcl.genstringtable.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.genstringtable.p],	r10
L1986:
    mov       rax,	[rbp + mc_auxmcl.genstringtable.p]
    test      rax,	rax
    jnz       L1983
L1985:
L1978:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genstring_db
mc_auxmcl.genstring_db:
;>>
    %define mc_auxmcl.genstring_db.s 16
    %define mc_auxmcl.genstring_db.length 24
    %define mc_auxmcl.genstring_db.strtype 32
    %define mc_auxmcl.genstring_db.i -8
    %define mc_auxmcl.genstring_db.c -16
    %define mc_auxmcl.genstring_db.seqlen -24
    %define mc_auxmcl.genstring_db.seq -32
    %define mc_auxmcl.genstring_db.av_1 -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_auxmcl.genstring_db.length]
    cmp       rax,	-1
    jnz       L1989
    mov       rcx,	[rbp + mc_auxmcl.genstring_db.s]
    call      strlen
    mov       [rbp + mc_auxmcl.genstring_db.length],	rax
L1989:
L1988:
    mov       rax,	[rbp + mc_auxmcl.genstring_db.length]
    cmp       rax,	0
    jnz       L1991
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
    jmp       L1987
L1991:
L1990:
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.genstring_db.seqlen],	rax
    mov       rax,	[rbp + mc_auxmcl.genstring_db.length]
    mov       [rbp + mc_auxmcl.genstring_db.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.genstring_db.av_1]
    cmp       rax,	0
    jle       L1994
L1992:
    mov       rax,	[rbp + mc_auxmcl.genstring_db.s]
    inc       qword [rbp + mc_auxmcl.genstring_db.s]
    movzx     r10,	byte [rax]
    mov       [rbp + mc_auxmcl.genstring_db.c],	r10
    mov       rax,	[rbp + mc_auxmcl.genstring_db.c]
    cmp       rax,	32
    jl        L1997
    mov       rax,	[rbp + mc_auxmcl.genstring_db.c]
    cmp       rax,	127
    jge       L1997
    mov       rax,	[rbp + mc_auxmcl.genstring_db.c]
    cmp       rax,	34
    jz        L1998
    cmp       rax,	92
    jnz       L1996
L1998:
L1997:
    mov       rax,	[rbp + mc_auxmcl.genstring_db.seqlen]
    test      rax,	rax
    jz        L2000
    mov       rcx,	[rbp + mc_auxmcl.genstring_db.seq]
    mov       rdx,	[rbp + mc_auxmcl.genstring_db.seqlen]
    call      mc_auxmcl.gendbstring
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.genstring_db.seqlen],	rax
L2000:
L1999:
    mov       rcx,	[rbp + mc_auxmcl.genstring_db.c]
    call      mc_auxmcl.gendb
    jmp       L1995
L1996:
    mov       rax,	[rbp + mc_auxmcl.genstring_db.seqlen]
    cmp       rax,	0
    jnz       L2002
    mov       rax,	1
    mov       [rbp + mc_auxmcl.genstring_db.seqlen],	rax
    mov       rax,	[rbp + mc_auxmcl.genstring_db.s]
    sub       rax,	1
    mov       [rbp + mc_auxmcl.genstring_db.seq],	rax
    jmp       L2001
L2002:
    inc       qword [rbp + mc_auxmcl.genstring_db.seqlen]
L2001:
L1995:
L1993:
    dec       qword [rbp + mc_auxmcl.genstring_db.av_1]
    jnz       L1992
L1994:
    mov       rax,	[rbp + mc_auxmcl.genstring_db.seqlen]
    test      rax,	rax
    jz        L2004
    mov       rcx,	[rbp + mc_auxmcl.genstring_db.seq]
    mov       rdx,	[rbp + mc_auxmcl.genstring_db.seqlen]
    call      mc_auxmcl.gendbstring
L2004:
L2003:
    mov       rax,	[rbp + mc_auxmcl.genstring_db.strtype]
    cmp       rax,	0
    jnz       L2006
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2006:
L2005:
L1987:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc gendb
mc_auxmcl.gendb:
;>>
    %define mc_auxmcl.gendb.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_auxmcl.gendb.a]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2007:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gendbstring
mc_auxmcl.gendbstring:
;>>
    %define mc_auxmcl.gendbstring.s 16
    %define mc_auxmcl.gendbstring.length 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_auxmcl.gendbstring.s]
    mov       rdx,	[rbp + mc_auxmcl.gendbstring.length]
    call      mc_libmcl.mgenstring
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2008:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gendq
mc_auxmcl.gendq:
;>>
    %define mc_auxmcl.gendq.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_auxmcl.gendq.a]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2009:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genrealtable
mc_auxmcl.genrealtable:
;>>
    %define mc_auxmcl.genrealtable.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.creallist]
    test      rax,	rax
    jnz       L2012
    mov       rax,	[mc_decls.creal32list]
    test      rax,	rax
    jnz       L2012
    jmp       L2010
L2012:
L2011:
    lea       rcx,	[rel L5686]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rax,	[mc_decls.creallist]
    mov       [rbp + mc_auxmcl.genrealtable.p],	rax
    jmp       L2016
L2013:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    movq      XMM4,	[rax]
    comisd    XMM4,	[rel L5687]
    jnz       L2018
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    movq      XMM4,	[rax]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2017
L2018:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    movq      XMM4,	[rax]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2017:
L2014:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.genrealtable.p],	r10
L2016:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    test      rax,	rax
    jnz       L2013
L2015:
    lea       rcx,	[rel L5688]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.creal32list]
    mov       [rbp + mc_auxmcl.genrealtable.p],	rax
    jmp       L2022
L2019:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    movq      XMM4,	[rax]
    comisd    XMM4,	[rel L5689]
    jnz       L2024
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    movq      XMM4,	[rax]
    cvtsd2ss  XMM4,	XMM4
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2023
L2024:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    movq      XMM4,	[rax]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2023:
L2020:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.genrealtable.p],	r10
L2022:
    mov       rax,	[rbp + mc_auxmcl.genrealtable.p]
    test      rax,	rax
    jnz       L2019
L2021:
L2010:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genabsneg
mc_auxmcl.genabsneg:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[mc_decls.lababs32]
    add       rax,	[mc_decls.lababs64]
    add       rax,	[mc_decls.labneg32]
    add       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jz        L2027
    mov       rcx,	73
    mov       rdx,	16
    call      mc_libmcl.setsegment
L2027:
L2026:
    mov       rax,	[mc_decls.lababs32]
    test      rax,	rax
    jz        L2029
    lea       rcx,	[rel L5690]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2029:
L2028:
    mov       rax,	[mc_decls.lababs64]
    test      rax,	rax
    jz        L2031
    lea       rcx,	[rel L5691]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2031:
L2030:
    mov       rax,	[mc_decls.labneg32]
    test      rax,	rax
    jz        L2033
    lea       rcx,	[rel L5692]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2033:
L2032:
    mov       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jz        L2035
    lea       rcx,	[rel L5693]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2035:
L2034:
    mov       rax,	[mc_decls.labzero]
    test      rax,	rax
    jz        L2037
    lea       rcx,	[rel L5694]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendq
L2037:
L2036:
    mov       rax,	[mc_decls.labmask63]
    test      rax,	rax
    jz        L2039
    lea       rcx,	[rel L5695]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	[mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2039:
L2038:
L2025:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_maths
mc_auxmcl.do_maths:
;>>
    %define mc_auxmcl.do_maths.p 16
    %define mc_auxmcl.do_maths.opname 24
    %define mc_auxmcl.do_maths.nargs 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mc_auxmcl.do_maths.p]
    mov       rdx,	[rbp + mc_auxmcl.do_maths.opname]
    xor       r8d,	r8d
    mov       r9,	[rbp + mc_auxmcl.do_maths.nargs]
    call      mc_auxmcl.do_callrts
L2040:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_host
mc_auxmcl.do_host:
;>>
    %define mc_auxmcl.do_host.p 16
    %define mc_auxmcl.do_host.d 24
    %define mc_auxmcl.do_host.nargs 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mc_auxmcl.do_host.p]
    xor       edx,	edx
    mov       r8,	[rbp + mc_auxmcl.do_host.d]
    mov       r9,	[rbp + mc_auxmcl.do_host.nargs]
    call      mc_auxmcl.do_callrts
L2041:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_callrts
mc_auxmcl.do_callrts:
;>>
    %define mc_auxmcl.do_callrts.p 16
    %define mc_auxmcl.do_callrts.opname 24
    %define mc_auxmcl.do_callrts.d 32
    %define mc_auxmcl.do_callrts.nargs 40
    %define mc_auxmcl.do_callrts.slots -8
    %define mc_auxmcl.do_callrts.av_1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	[rbp + mc_auxmcl.do_callrts.nargs]
    call      mc_stackmcl.saveopnds
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_callrts.slots],	rax
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    test      rax,	rax
    jz        L2044
    mov       rcx,	1
    call      mc_libmcl.pushslots
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_callrts.slots],	rax
L2044:
L2043:
    mov       rax,	[rbp + mc_auxmcl.do_callrts.nargs]
    cmp       [pc_decls.highargs],	rax
    jge       L5696
    mov       [pc_decls.highargs],	rax
L5696:
    mov       rcx,	[rbp + mc_auxmcl.do_callrts.nargs]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_auxmcl.do_pushlowargs
    mov       rax,	[mc_decls.mstackdepth]
    test      rax,	rax
    jz        L2046
    mov       rax,	4
    add       [rbp + mc_auxmcl.do_callrts.slots],	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2045
L2046:
    mov       al,	1
    mov       [pc_decls.localshadow],	al
L2045:
    mov       rax,	[rbp + mc_auxmcl.do_callrts.opname]
    test      rax,	rax
    jz        L2048
    mov       rcx,	[rbp + mc_auxmcl.do_callrts.opname]
    call      mc_libmcl.mgenextname
    mov       rcx,	22
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2047
L2048:
    mov       rcx,	[rbp + mc_auxmcl.do_callrts.d]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	22
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2047:
    mov       rax,	[rbp + mc_auxmcl.do_callrts.nargs]
    mov       [rbp + mc_auxmcl.do_callrts.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_callrts.av_1]
    cmp       rax,	0
    jle       L2051
L2049:
    call      mc_stackmcl.poppcl
L2050:
    dec       qword [rbp + mc_auxmcl.do_callrts.av_1]
    jnz       L2049
L2051:
    mov       rax,	[rbp + mc_auxmcl.do_callrts.slots]
    test      rax,	rax
    jz        L2053
    mov       rcx,	[rbp + mc_auxmcl.do_callrts.slots]
    call      mc_libmcl.popslots
L2053:
L2052:
    mov       rcx,	[rbp + mc_auxmcl.do_callrts.p]
    call      mc_auxmcl.do_getretvalue
L2042:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_max_int
mc_auxmcl.do_max_int:
;>>
    %define mc_auxmcl.do_max_int.cond 16
    %define mc_auxmcl.do_max_int.ax -8
    %define mc_auxmcl.do_max_int.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_max_int.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_max_int.bx],	rax
    mov       rcx,	43
    mov       rdx,	[rbp + mc_auxmcl.do_max_int.ax]
    mov       r8,	[rbp + mc_auxmcl.do_max_int.bx]
    call      mc_libmcl.genmc
    mov       rcx,	16
    mov       rdx,	[rbp + mc_auxmcl.do_max_int.cond]
    mov       r8,	[rbp + mc_auxmcl.do_max_int.ax]
    mov       r9,	[rbp + mc_auxmcl.do_max_int.bx]
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
L2054:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_max_float
mc_auxmcl.do_max_float:
;>>
    %define mc_auxmcl.do_max_float.opc 16
    %define mc_auxmcl.do_max_float.ax -8
    %define mc_auxmcl.do_max_float.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_max_float.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_max_float.bx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_max_float.opc]
    mov       rdx,	[rbp + mc_auxmcl.do_max_float.ax]
    mov       r8,	[rbp + mc_auxmcl.do_max_float.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2055:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_maxto_int
mc_auxmcl.do_maxto_int:
;>>
    %define mc_auxmcl.do_maxto_int.cond 16
    %define mc_auxmcl.do_maxto_int.mode 24
    %define mc_auxmcl.do_maxto_int.ax -8
    %define mc_auxmcl.do_maxto_int.bx -16
    %define mc_auxmcl.do_maxto_int.lx -24
    %define mc_auxmcl.do_maxto_int.lab -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_maxto_int.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_maxto_int.bx],	rax
    mov       rcx,	43
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_int.ax]
    mov       r8,	[rbp + mc_auxmcl.do_maxto_int.bx]
    call      mc_libmcl.genmc
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [rbp + mc_auxmcl.do_maxto_int.lab],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_maxto_int.lab]
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.do_maxto_int.lx],	r10
    mov       rcx,	27
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_int.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_int.ax]
    mov       r8,	[rbp + mc_auxmcl.do_maxto_int.bx]
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_int.lx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2056:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc do_maxto_real
mc_auxmcl.do_maxto_real:
;>>
    %define mc_auxmcl.do_maxto_real.cond 16
    %define mc_auxmcl.do_maxto_real.mode 24
    %define mc_auxmcl.do_maxto_real.px -8
    %define mc_auxmcl.do_maxto_real.ax -16
    %define mc_auxmcl.do_maxto_real.bx -24
    %define mc_auxmcl.do_maxto_real.lx -32
    %define mc_auxmcl.do_maxto_real.lab -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_maxto_real.px],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_maxto_real.bx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_maxto_real.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.ax]
    mov       r8,	[rbp + mc_auxmcl.do_maxto_real.px]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_maxto_real.mode]
    sub       rax,	1
    mov       r10,	74
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.ax]
    mov       r8,	[rbp + mc_auxmcl.do_maxto_real.bx]
    call      mc_libmcl.genmc
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [rbp + mc_auxmcl.do_maxto_real.lab],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_maxto_real.lab]
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.do_maxto_real.lx],	r10
    mov       rcx,	27
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.px]
    mov       r8,	[rbp + mc_auxmcl.do_maxto_real.bx]
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.lx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2057:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc do_negreal
mc_auxmcl.do_negreal:
;>>
    %define mc_auxmcl.do_negreal.ax 16
    %define mc_auxmcl.do_negreal.mode 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    test      rax,	rax
    jz        L2060
    mov       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jnz       L2062
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.labneg64],	rax
L2062:
L2061:
    mov       rcx,	[mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	77
    mov       rdx,	[rbp + mc_auxmcl.do_negreal.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2059
L2060:
    mov       rax,	[mc_decls.labneg32]
    test      rax,	rax
    jnz       L2064
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.labneg32],	rax
L2064:
L2063:
    mov       rcx,	[mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	76
    mov       rdx,	[rbp + mc_auxmcl.do_negreal.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2059:
L2058:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_absreal
mc_auxmcl.do_absreal:
;>>
    %define mc_auxmcl.do_absreal.ax 16
    %define mc_auxmcl.do_absreal.mode 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    test      rax,	rax
    jz        L2067
    mov       rax,	[mc_decls.lababs64]
    test      rax,	rax
    jnz       L2069
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.lababs64],	rax
L2069:
L2068:
    mov       rcx,	[mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	79
    mov       rdx,	[rbp + mc_auxmcl.do_absreal.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2066
L2067:
    mov       rax,	[mc_decls.lababs32]
    test      rax,	rax
    jnz       L2071
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.lababs32],	rax
L2071:
L2070:
    mov       rcx,	[mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	78
    mov       rdx,	[rbp + mc_auxmcl.do_absreal.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2066:
L2065:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_loadbf_const
mc_auxmcl.do_loadbf_const:
;>>
    %define mc_auxmcl.do_loadbf_const.p 16
    %define mc_auxmcl.do_loadbf_const.i 24
    %define mc_auxmcl.do_loadbf_const.j 32
    %define mc_auxmcl.do_loadbf_const.ax -8
    %define mc_auxmcl.do_loadbf_const.mx -16
    %define mc_auxmcl.do_loadbf_const.mask -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_loadbf_const.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.do_loadbf_const.j]
    cmp       rax,	63
    jnz       L2074
    mov       rcx,	[rbp + mc_auxmcl.do_loadbf_const.i]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	[rbp + mc_auxmcl.do_loadbf_const.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2073
L2074:
    mov       rax,	[rbp + mc_auxmcl.do_loadbf_const.i]
    test      rax,	rax
    jz        L2076
    mov       rcx,	[rbp + mc_auxmcl.do_loadbf_const.i]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	46
    mov       rdx,	[rbp + mc_auxmcl.do_loadbf_const.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2076:
L2075:
    mov       rax,	[rbp + mc_auxmcl.do_loadbf_const.j]
    sub       rax,	[rbp + mc_auxmcl.do_loadbf_const.i]
    add       rax,	1
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       [rbp + mc_auxmcl.do_loadbf_const.mask],	r10
    mov       rax,	[rbp + mc_auxmcl.do_loadbf_const.mask]
    cmp       rax,	2147483647
    ja        L2078
    mov       rcx,	[rbp + mc_auxmcl.do_loadbf_const.mask]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	39
    mov       rdx,	[rbp + mc_auxmcl.do_loadbf_const.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2077
L2078:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_loadbf_const.mx],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_loadbf_const.mask]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_loadbf_const.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	39
    mov       rdx,	[rbp + mc_auxmcl.do_loadbf_const.ax]
    mov       r8,	[rbp + mc_auxmcl.do_loadbf_const.mx]
    call      mc_libmcl.genmc
L2077:
L2073:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2072:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc do_loadbf_var
mc_auxmcl.do_loadbf_var:
;>>
    %define mc_auxmcl.do_loadbf_var.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    lea       rcx,	[rel L5697]
    lea       rdx,	[rel L5698]
    call      mc_libmcl.merror
L2079:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_storebit
mc_auxmcl.do_storebit:
;>>
    %define mc_auxmcl.do_storebit.p 16
    %define mc_auxmcl.do_storebit.px -8
    %define mc_auxmcl.do_storebit.ax -16
    %define mc_auxmcl.do_storebit.cx -24
    %define mc_auxmcl.do_storebit.ix -32
    %define mc_auxmcl.do_storebit.q -40
    %define mc_auxmcl.do_storebit.r -48
    %define mc_auxmcl.do_storebit.i -56
    %define mc_auxmcl.do_storebit.offset -64
    %define mc_auxmcl.do_storebit.mask1s -72
    %define mc_auxmcl.do_storebit.mask0s -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebit.q],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebit.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebit.q]
    test      rax,	rax
    jz        L2082
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_storebit.px],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebit.q]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.do_storebit.i],	r10
    mov       rax,	[rbp + mc_auxmcl.do_storebit.i]
    sar       rax,	3
    mov       [rbp + mc_auxmcl.do_storebit.offset],	rax
    mov       rax,	7
    and       [rbp + mc_auxmcl.do_storebit.i],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       [rbp + mc_auxmcl.do_storebit.px],	rax
    mov       rax,	1
    mov       cl,	[rbp + mc_auxmcl.do_storebit.i]
    shl       rax,	cl
    mov       [rbp + mc_auxmcl.do_storebit.mask0s],	al
    mov       rax,	1
    mov       cl,	[rbp + mc_auxmcl.do_storebit.i]
    shl       rax,	cl
    not       rax
    mov       [rbp + mc_auxmcl.do_storebit.mask1s],	al
    mov       rax,	[rbp + mc_auxmcl.do_storebit.r]
    test      rax,	rax
    jz        L2084
    mov       rax,	[rbp + mc_auxmcl.do_storebit.r]
    mov       r10,	[rax+8]
    cmp       r10,	0
    jnz       L2086
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	39
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2085
L2086:
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask0s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	40
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2085:
    jmp       L2083
L2084:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	3
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_storebit.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	39
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebit.i]
    test      rax,	rax
    jz        L2088
    mov       rcx,	[rbp + mc_auxmcl.do_storebit.i]
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       rcx,	44
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2088:
L2087:
    mov       rcx,	40
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       r8,	[rbp + mc_auxmcl.do_storebit.ax]
    call      mc_libmcl.genmc
L2083:
    jmp       L2081
L2082:
    mov       rax,	[rbp + mc_auxmcl.do_storebit.r]
    test      rax,	rax
    jz        L2089
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_storebit.px],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebit.q]
    cmp       rax,	0
    jnz       L2091
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.do_storebit.ax],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_storebit.cx],	rax
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L2093
    mov       rcx,	13
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.cx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2093:
L2092:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       [rbp + mc_auxmcl.do_storebit.ix],	rax
    mov       rcx,	[rbp + mc_auxmcl.do_storebit.cx]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	44
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L2095
    mov       rcx,	14
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.cx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2095:
L2094:
    mov       rax,	[rbp + mc_auxmcl.do_storebit.r]
    mov       r10,	[rax+8]
    cmp       r10,	0
    jnz       L2097
    mov       rcx,	52
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	40
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       r8,	[rbp + mc_auxmcl.do_storebit.ax]
    call      mc_libmcl.genmc
    jmp       L2096
L2097:
    mov       rcx,	40
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.px]
    mov       r8,	[rbp + mc_auxmcl.do_storebit.ax]
    call      mc_libmcl.genmc
L2096:
    jmp       L2090
L2091:
    lea       rcx,	[rel L5699]
    lea       rdx,	[rel L5700]
    call      mc_libmcl.merror
L2090:
L2089:
L2081:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2080:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc do_storebf
mc_auxmcl.do_storebf:
;>>
    %define mc_auxmcl.do_storebf.p 16
    %define mc_auxmcl.do_storebf.ax -8
    %define mc_auxmcl.do_storebf.rx -16
    %define mc_auxmcl.do_storebf.mx -24
    %define mc_auxmcl.do_storebf.mx4 -32
    %define mc_auxmcl.do_storebf.dx -40
    %define mc_auxmcl.do_storebf.i -48
    %define mc_auxmcl.do_storebf.j -56
    %define mc_auxmcl.do_storebf.q -64
    %define mc_auxmcl.do_storebf.r -72
    %define mc_auxmcl.do_storebf.mask -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebf.q],	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebf.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    cmp       rax,	[rbp + mc_auxmcl.do_storebf.q]
    jnz       L2100
    cmp       rax,	0
    jnz       L2100
    lea       rcx,	[rel L5701]
    lea       rdx,	[rel L5702]
    call      mc_libmcl.merror
L2100:
L2099:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	3
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.do_storebf.dx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_auxmcl.do_storebf.ax],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebf.q]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.do_storebf.i],	r10
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    mov       r10,	[rax+8]
    mov       [rbp + mc_auxmcl.do_storebf.j],	r10
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.do_storebf.mx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.do_storebf.rx],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_storebf.rx]
    mov       r8,	[rbp + mc_auxmcl.do_storebf.ax]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebf.j]
    sub       rax,	[rbp + mc_auxmcl.do_storebf.i]
    add       rax,	1
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       cl,	[rbp + mc_auxmcl.do_storebf.i]
    shl       r10,	cl
    not       r10
    mov       [rbp + mc_auxmcl.do_storebf.mask],	r10
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.mask]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_storebf.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebf.i]
    test      rax,	rax
    jz        L2102
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.i]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	44
    mov       rdx,	[rbp + mc_auxmcl.do_storebf.dx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2102:
L2101:
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.mx]
    mov       rdx,	r10
    call      mc_libmcl.changeopndsize
    mov       rcx,	39
    mov       rdx,	[rbp + mc_auxmcl.do_storebf.rx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	40
    mov       rdx,	[rbp + mc_auxmcl.do_storebf.rx]
    mov       r8,	[rbp + mc_auxmcl.do_storebf.dx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.rx]
    mov       rdx,	r10
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.do_storebf.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2098:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc gethostfn
mc_auxmcl.gethostfn:
;>>
    %define mc_auxmcl.gethostfn.opc 16
    %define mc_auxmcl.gethostfn.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.igethostfn]
    cmp       rax,	0
    jnz       L2105
    lea       rcx,	[rel L5703]
    lea       rdx,	[rel L5704]
    call      mc_libmcl.merror
L2105:
L2104:
    mov       rcx,	[rbp + mc_auxmcl.gethostfn.opc]
    mov       rax,	[mc_decls.igethostfn]
    call      rax
    mov       [rbp + mc_auxmcl.gethostfn.d],	rax
    mov       rax,	[rbp + mc_auxmcl.gethostfn.d]
    cmp       rax,	0
    jnz       L2107
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	[rbp + mc_auxmcl.gethostfn.opc]
    mov       r11,	[rax + r10*8]
    lea       rcx,	[rel L5705]
    mov       rdx,	r11
    call      mc_libmcl.merror
L2107:
L2106:
    mov       rax,	[rbp + mc_auxmcl.gethostfn.d]
L2103:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc copyblockarg
mc_auxmcl.copyblockarg:
;>>
    %define mc_auxmcl.copyblockarg.px 16
    %define mc_auxmcl.copyblockarg.size 24
    %define mc_auxmcl.copyblockarg.argno 32
    %define mc_auxmcl.copyblockarg.dblock -8
    %define mc_auxmcl.copyblockarg.ax -16
    %define mc_auxmcl.copyblockarg.bx -24
    %define mc_auxmcl.copyblockarg.axi -32
    %define mc_auxmcl.copyblockarg.bxi -40
    %define mc_auxmcl.copyblockarg.$T3 -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.copyblockarg.px]
    cmp       rax,	0
    jnz       L2110
    call      msys.m$print_startcon
    lea       rcx,	[rel L5706]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rel L5707]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2108
L2110:
L2109:
    mov       rcx,	[rbp + mc_auxmcl.copyblockarg.size]
    call      mc_libmcl.newblocktemp
    mov       [rbp + mc_auxmcl.copyblockarg.dblock],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_auxmcl.copyblockarg.dblock]
    mov       [r10+68],	al
    mov       rax,	[rbp + mc_auxmcl.copyblockarg.px]
    test      rax,	rax
    jz        L2112
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.copyblockarg.bx],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.bx]
    mov       r8,	[rbp + mc_auxmcl.copyblockarg.px]
    call      mc_libmcl.genmc
    jmp       L2111
L2112:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	11
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_auxmcl.copyblockarg.bx],	rax
L2111:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_auxmcl.copyblockarg.ax],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblockarg.dblock]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.copyblockarg.bx]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_auxmcl.copyblockarg.$T3],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblockarg.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.$T3]
    mov       r8,	[rbp + mc_auxmcl.copyblockarg.size]
    mov       r9,	1
    call      mc_auxmcl.copyblock
    mov       rax,	[rbp + mc_auxmcl.copyblockarg.px]
    test      rax,	rax
    jz        L2114
    mov       rcx,	[rbp + mc_auxmcl.copyblockarg.dblock]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.px]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2114:
L2113:
    xor       ecx,	ecx
    call      mc_stackmcl.freeworkregs
L2108:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc fixmain
mc_auxmcl.fixmain:
;>>
    %define mc_auxmcl.fixmain.d -8
    %define mc_auxmcl.fixmain.e -16
    %define mc_auxmcl.fixmain.dn -24
    %define mc_auxmcl.fixmain.dargs -32
    %define mc_auxmcl.fixmain.denv -40
    %define mc_auxmcl.fixmain.dinfo -48
    %define mc_auxmcl.fixmain.$T1 -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    mov       rax,	[pc_decls.currfunc]
    mov       [rbp + mc_auxmcl.fixmain.d],	rax
    call      msys.m$print_startcon
    lea       rcx,	[rel L5708]
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5709]
    call      msys.m$print_str_nf
    mov       rcx,	[pc_decls.pcmdskip]
    call      msys.m$print_i64_nf
    mov       rcx,	[msys.$cmdskip]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mc_auxmcl.fixmain.d]
    mov       r10,	[rax+16]
    mov       [rbp + mc_auxmcl.fixmain.dn],	r10
    mov       rax,	[rbp + mc_auxmcl.fixmain.dn]
    mov       r10,	[rax+16]
    mov       [rbp + mc_auxmcl.fixmain.dargs],	r10
    lea       rcx,	[rel L5710]
    mov       rdx,	4
    call      pc_api.pc_makesymbol
    mov       [rbp + mc_auxmcl.fixmain.denv],	rax
    mov       al,	6
    mov       r10,	[rbp + mc_auxmcl.fixmain.denv]
    mov       [r10+58],	al
    mov       eax,	8
    mov       r10,	[rbp + mc_auxmcl.fixmain.denv]
    mov       [r10+60],	eax
    lea       rcx,	[rel L5711]
    mov       rdx,	4
    call      pc_api.pc_makesymbol
    mov       [rbp + mc_auxmcl.fixmain.dinfo],	rax
    mov       al,	11
    mov       r10,	[rbp + mc_auxmcl.fixmain.dinfo]
    mov       [r10+58],	al
    mov       eax,	128
    mov       r10,	[rbp + mc_auxmcl.fixmain.dinfo]
    mov       [r10+60],	eax
    mov       rcx,	[rbp + mc_auxmcl.fixmain.denv]
    call      pc_api.pc_addlocal
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dinfo]
    call      pc_api.pc_addlocal
    xor       eax,	eax
    mov       r10,	[rbp + mc_auxmcl.fixmain.d]
    mov       [r10+16],	rax
    mov       r10,	[rbp + mc_auxmcl.fixmain.dargs]
    mov       [r10+16],	rax
    mov       r10,	[rbp + mc_auxmcl.fixmain.dn]
    mov       [r10+16],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mc_auxmcl.fixmain.d]
    mov       [r10+97],	al
    mov       al,	4
    mov       r10,	[rbp + mc_auxmcl.fixmain.dn]
    mov       [r10+49],	al
    mov       al,	4
    mov       r10,	[rbp + mc_auxmcl.fixmain.dargs]
    mov       [r10+49],	al
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dargs]
    call      pc_api.pc_addlocal
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dn]
    call      pc_api.pc_addlocal
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dinfo]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	15
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	30
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dn]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	15
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dargs]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	15
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_auxmcl.fixmain.denv]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	13
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	15
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	14
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	14
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	41
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    lea       rcx,	[rel L5712]
    call      mc_libmcl.mgenextname
    mov       rcx,	22
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	48
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	30
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[pc_decls.pcmdskip]
    test      rax,	rax
    jz        L2117
    mov       rcx,	[pc_decls.pcmdskip]
    mov       rdx,	9
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dn]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       rcx,	30
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rax,	[pc_decls.pcmdskip]
    imul      rax,	8
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	[rbp + mc_auxmcl.fixmain.dargs]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2117:
L2116:
L2115:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc genmcl
mc_genmcl.genmcl:
;>>
    %define mc_genmcl.genmcl.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [pc_decls.mcldone]
    test      rax,	rax
    jz        L2120
    jmp       L2118
L2120:
L2119:
    xor       eax,	eax
    test      ax,	ax
    jnz       L2123
    xor       eax,	eax
    test      ax,	ax
    jz        L2122
L2123:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5713]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2122:
L2121:
    call      mc_genmcl.inithandlers
    call      mc_libmcl.mclinit
    mov       rax,	[pc_api.pcstart]
    mov       [mc_decls.currpcl],	rax
    xor       eax,	eax
    mov       [rbp + mc_genmcl.genmcl.i],	rax
L2124:
    mov       rcx,	[mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       eax,	eax
    test      ax,	ax
    jz        L2128
    mov       rax,	[mc_decls.currpcl]
    movzx     r10,	byte [rax]
    cmp       r10,	125
    jz        L2128
    cmp       r10,	133
    jz        L2128
    cmp       r10,	119
    jz        L2128
    cmp       r10,	120
    jz        L2128
    cmp       r10,	19
    jz        L2128
    cmp       r10,	121
    jz        L2128
    call      pc_diags.showopndstack
L2128:
L2127:
    add       qword [mc_decls.currpcl],	32
L2125:
    mov       rax,	[mc_decls.currpcl]
    cmp       rax,	[pc_api.pccurr]
    ja        L2129
    mov       rax,	[mc_decls.currpcl]
    movzx     r10,	byte [rax]
    cmp       r10,	134
    jnz       L2124
L2129:
L2126:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       al,	1
    mov       [pc_decls.mcldone],	al
L2118:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc convertpcl
mc_genmcl.convertpcl:
;>>
    %define mc_genmcl.convertpcl.p 16
    %define mc_genmcl.convertpcl.reg -8
    %define mc_genmcl.convertpcl.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.convertpcl.p]
    movzx     r10,	byte [rax+3]
    mov       [mc_decls.pmode],	r10b
    mov       rax,	[rbp + mc_genmcl.convertpcl.p]
    mov       [mc_decls.currpcl],	rax
    mov       rax,	[rbp + mc_genmcl.convertpcl.p]
    mov       r10d,	[rax+24]
    mov       [pc_decls.mmpos],	r10
    mov       rax,	[rbp + mc_genmcl.convertpcl.p]
    movsxd    r10,	dword [rax+28]
    shr       r10,	8
    and       r10,	16777215
    mov       [mc_genmcl.ppseqno],	r10
    mov       rax,	[rbp + mc_genmcl.convertpcl.p]
    movzx     r10,	byte [rax]
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       r11,	[rax + r10*8]
    mov       rcx,	[rbp + mc_genmcl.convertpcl.p]
    call      r11
    lea       rax,	[mc_decls.regset]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rax,	1
    mov       [rbp + mc_genmcl.convertpcl.i],	rax
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L2133
L2131:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_genmcl.convertpcl.i]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_genmcl.convertpcl.reg],	r11
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_genmcl.convertpcl.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L2135
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_genmcl.convertpcl.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	2
    jg        L2137
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_genmcl.convertpcl.reg]
    mov       [r10 + r11-1],	al
    jmp       L2136
L2137:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_genmcl.convertpcl.reg]
    mov       [r10 + r11-1],	al
L2136:
L2135:
L2134:
L2132:
    mov       rax,	[rbp + mc_genmcl.convertpcl.i]
    inc       rax
    mov       [rbp + mc_genmcl.convertpcl.i],	rax
    cmp       rax,	[mc_decls.noperands]
    jle       L2131
L2133:
L2130:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc inithandlers
mc_genmcl.inithandlers:
;>>
    %define mc_genmcl.inithandlers.name -8
    %define mc_genmcl.inithandlers.s -16
    %define mc_genmcl.inithandlers.n -24
    %define mc_genmcl.inithandlers.av_1 -32
    %define mc_genmcl.inithandlers.av_2 -40
    %define mc_genmcl.inithandlers.av_3 -48
    %define mc_genmcl.inithandlers.i -56
    %define mc_genmcl.inithandlers.k -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    movzx     rax,	byte [mc_genmcl.inithandlers.initdone]
    test      rax,	rax
    jz        L2140
    jmp       L2138
L2140:
L2139:
    mov       rax,	1193046
    mov       [rbp + mc_genmcl.inithandlers.n],	rax
    mov       rax,	123456
    mov       [rbp + mc_genmcl.inithandlers.n],	rax
    mov       rax,	[$nprocs]
    mov       [rbp + mc_genmcl.inithandlers.n],	rax
    mov       rax,	1
    mov       [rbp + mc_genmcl.inithandlers.i],	rax
    mov       rax,	[rbp + mc_genmcl.inithandlers.n]
    cmp       rax,	1
    jl        L2143
L2141:
    lea       rax,	[$procname]
    mov       r10,	[rbp + mc_genmcl.inithandlers.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_genmcl.inithandlers.name],	r11
    mov       rcx,	[rbp + mc_genmcl.inithandlers.name]
    lea       rdx,	[rel L5714]
    mov       r8,	3
    call      mlib.eqbytes
    test      rax,	rax
    jz        L2145
    xor       eax,	eax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    mov       rax,	139
    mov       [rbp + mc_genmcl.inithandlers.av_1],	rax
    mov       rax,	[rbp + mc_genmcl.inithandlers.av_1]
    cmp       rax,	0
    jl        L2149
L2146:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	[rbp + mc_genmcl.inithandlers.k]
    mov       r11,	[rax + r10*8]
    mov       [rbp + mc_genmcl.inithandlers.s],	r11
    mov       rax,	[rbp + mc_genmcl.inithandlers.s]
    movzx     r10,	byte [rax]
    cmp       r10,	107
    jnz       L2151
    inc       qword [rbp + mc_genmcl.inithandlers.s]
L2151:
L2150:
    mov       rax,	[rbp + mc_genmcl.inithandlers.name]
    lea       rax,	[rax+3]
    mov       rcx,	[rbp + mc_genmcl.inithandlers.s]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2153
    lea       rax,	[$procaddr]
    mov       r10,	[rbp + mc_genmcl.inithandlers.i]
    mov       r11,	[rax + r10*8-8]
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       r10,	[rbp + mc_genmcl.inithandlers.k]
    mov       [rax + r10*8],	r11
    jmp       L2148
L2153:
L2152:
L2147:
    mov       rax,	[rbp + mc_genmcl.inithandlers.k]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    cmp       rax,	[rbp + mc_genmcl.inithandlers.av_1]
    jle       L2146
L2149:
    lea       rcx,	[rel L5715]
    mov       rdx,	[rbp + mc_genmcl.inithandlers.name]
    call      mc_libmcl.merror
L2148:
L2145:
L2144:
L2142:
    mov       rax,	[rbp + mc_genmcl.inithandlers.i]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.i],	rax
    cmp       rax,	[rbp + mc_genmcl.inithandlers.n]
    jle       L2141
L2143:
    mov       rax,	1
    mov       [rbp + mc_genmcl.inithandlers.i],	rax
    mov       rax,	9
    mov       [rbp + mc_genmcl.inithandlers.av_2],	rax
    mov       rax,	[rbp + mc_genmcl.inithandlers.av_2]
    cmp       rax,	1
    jl        L2156
L2154:
    lea       rax,	[mc_genmcl.inithandlers.dupltable]
    mov       r10,	[rbp + mc_genmcl.inithandlers.i]
    lea       rax,	[rax + r10*2-2]
    movzx     r10,	byte [rax+1]
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       r11,	[rax + r10*8]
    lea       rax,	[mc_genmcl.inithandlers.dupltable]
    mov       r10,	[rbp + mc_genmcl.inithandlers.i]
    lea       rax,	[rax + r10*2-2]
    movzx     r10,	byte [rax]
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       [rax + r10*8],	r11
L2155:
    mov       rax,	[rbp + mc_genmcl.inithandlers.i]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.i],	rax
    cmp       rax,	[rbp + mc_genmcl.inithandlers.av_2]
    jle       L2154
L2156:
    xor       eax,	eax
    mov       [rbp + mc_genmcl.inithandlers.i],	rax
    mov       rax,	139
    mov       [rbp + mc_genmcl.inithandlers.av_3],	rax
    mov       rax,	[rbp + mc_genmcl.inithandlers.av_3]
    cmp       rax,	0
    jl        L2159
L2157:
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       r10,	[rbp + mc_genmcl.inithandlers.i]
    mov       r11,	[rax + r10*8]
    test      r11,	r11
    jnz       L2161
    lea       rax,	[mc_genmcl.unimpl]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r11,	[rbp + mc_genmcl.inithandlers.i]
    mov       [r10 + r11*8],	rax
L2161:
L2160:
L2158:
    mov       rax,	[rbp + mc_genmcl.inithandlers.i]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.i],	rax
    cmp       rax,	[rbp + mc_genmcl.inithandlers.av_3]
    jle       L2157
L2159:
    mov       al,	1
    mov       [mc_genmcl.inithandlers.initdone],	al
L2138:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc doshowpcl
mc_genmcl.doshowpcl:
;>>
    %define mc_genmcl.doshowpcl.p 16
    %define mc_genmcl.doshowpcl.str -1256
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1296
    mov       [rbp+16],	rcx
;---------------
    jmp       L2162
    mov       rax,	[rbp + mc_genmcl.doshowpcl.p]
    movzx     r10,	byte [rax]
    cmp       r10,	119
    jz        L2164
    cmp       r10,	120
    jz        L2164
    cmp       r10,	19
    jz        L2164
    cmp       r10,	121
    jz        L2164
    cmp       r10,	122
    jz        L2164
    cmp       r10,	123
    jz        L2164
    cmp       r10,	124
    jz        L2164
    jmp       L2165
L2164:
    jmp       L2163
L2165:
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    lea       rdx,	[rel L5716]
    call      strcpy
    mov       rcx,	[rbp + mc_genmcl.doshowpcl.p]
    call      pc_diags.strpclstr
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
L2163:
L2162:
;---------------
    add       rsp,	1296
    pop       rbp
    ret       
;End 
;Proc unimpl
mc_genmcl.unimpl:
;>>
    %define mc_genmcl.unimpl.p 16
    %define mc_genmcl.unimpl.str -104
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
    mov       [rbp+16],	rcx
;---------------
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5717]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mc_genmcl.unimpl.p]
    movzx     r10,	byte [rax]
    lea       rax,	[pc_tables.pclnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
L2166:
;---------------
    add       rsp,	144
    pop       rbp
    ret       
;End 
;Proc px_nop
mc_genmcl.px_nop:
;>>
    %define mc_genmcl.px_nop.p 16
    push      rbp
    mov       rbp,	rsp
;---------------
L2167:
;---------------
    pop       rbp
    ret       
;End 
;Proc px_dupl
mc_genmcl.px_dupl:
;>>
    %define mc_genmcl.px_dupl.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mc_stackmcl.duplpcl
L2168:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_double
mc_genmcl.px_double:
;>>
    %define mc_genmcl.px_double.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[mc_decls.ncalldepth]
    test      rax,	rax
    jz        L2171
    call      mc_stackmcl.duplpcl
    jmp       L2170
L2171:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    inc       byte [rax]
L2170:
L2169:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_opnd
mc_genmcl.px_opnd:
;>>
    %define mc_genmcl.px_opnd.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_opnd.p]
    call      mc_genmcl.unimpl
L2172:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_type
mc_genmcl.px_type:
;>>
    %define mc_genmcl.px_type.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_type.p]
    call      mc_genmcl.unimpl
L2173:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_comment
mc_genmcl.px_comment:
;>>
    %define mc_genmcl.px_comment.p 16
    push      rbp
    mov       rbp,	rsp
;---------------
L2174:
;---------------
    pop       rbp
    ret       
;End 
;Proc px_defproc
mc_genmcl.px_defproc:
;>>
    %define mc_genmcl.px_defproc.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_defproc.p]
    mov       r10,	[rax+8]
    mov       [pc_decls.currfunc],	r10
    xor       eax,	eax
    mov       [mc_decls.nblocktemps],	rax
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	[pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	6
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.currfunc]
    call      mc_auxmcl.initpass
    lea       rcx,	[rel L5718]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mclprocentry],	rax
    mov       rax,	[pc_decls.currfunc]
    movzx     r10,	byte [rax+97]
    cmp       r10,	2
    jnz       L2177
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L5719]
    call      mlib.eqstring
    test      rax,	rax
    jz        L2177
    call      mc_auxmcl.fixmain
L2177:
L2176:
L2175:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_endproc
mc_genmcl.px_endproc:
;>>
    %define mc_genmcl.px_endproc.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[mc_decls.noperands]
    test      rax,	rax
    jz        L2180
    call      msys.m$print_startcon
    lea       rcx,	[rel L5720]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2180:
L2179:
    mov       rcx,	2
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.fppeephole]
    test      rax,	rax
    jz        L2182
L2182:
L2181:
L2178:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_endprog
mc_genmcl.px_endprog:
;>>
    %define mc_genmcl.px_endprog.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_endprog.p]
    call      mc_genmcl.unimpl
L2183:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_istatic
mc_genmcl.px_istatic:
;>>
    %define mc_genmcl.px_istatic.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_istatic.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	73
    mov       rdx,	r10
    call      mc_libmcl.setsegment
    mov       rax,	[rbp + mc_genmcl.px_istatic.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	6
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2184:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_zstatic
mc_genmcl.px_zstatic:
;>>
    %define mc_genmcl.px_zstatic.p 16
    %define mc_genmcl.px_zstatic.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_zstatic.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_zstatic.d],	r10
    mov       rax,	[rbp + mc_genmcl.px_zstatic.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	90
    mov       rdx,	r10
    call      mc_libmcl.setsegment
    mov       rcx,	[rbp + mc_genmcl.px_zstatic.d]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	6
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_zstatic.p]
    mov       r10d,	[rax+4]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2185:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_data
mc_genmcl.px_data:
;>>
    %define mc_genmcl.px_data.p 16
    %define mc_genmcl.px_data.ax -8
    %define mc_genmcl.px_data.opc -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	11
    jnz       L2188
    mov       rcx,	[rbp + mc_genmcl.px_data.p]
    call      mc_auxmcl.do_blockdata
    jmp       L2186
L2188:
L2187:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jz        L2190
    cmp       r10,	10
    jz        L2191
    cmp       r10,	11
    jz        L2192
    cmp       r10,	6
    jz        L2193
    cmp       r10,	7
    jz        L2194
    cmp       r10,	2
    jz        L2195
    cmp       r10,	3
    jz        L2196
    jmp       L2197
L2190:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    jmp       L2189
L2191:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    jmp       L2189
L2192:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    jmp       L2189
L2193:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    jmp       L2189
L2194:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    jmp       L2189
L2195:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenmemaddr
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movsxd    r10,	dword [rax+20]
    mov       rax,	[rbp + mc_genmcl.px_data.ax]
    mov       [rax+12],	r10d
    jmp       L2189
L2196:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       [rbp + mc_genmcl.px_data.ax],	rax
    jmp       L2189
L2197:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movzx     r10,	byte [rax+1]
    lea       rax,	[pc_tables.opndnames]
    mov       r11,	[rax + r10*8]
    lea       rcx,	[rel L5721]
    mov       rdx,	r11
    call      mc_libmcl.merror
L2189:
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    mov       r10d,	[rax+4]
    cmp       r10,	1
    jz        L2199
    cmp       r10,	2
    jz        L2200
    cmp       r10,	4
    jz        L2201
    cmp       r10,	8
    jz        L2202
    jmp       L2203
L2199:
    mov       rax,	116
    mov       [rbp + mc_genmcl.px_data.opc],	rax
    jmp       L2198
L2200:
    mov       rax,	117
    mov       [rbp + mc_genmcl.px_data.opc],	rax
    jmp       L2198
L2201:
    mov       rax,	118
    mov       [rbp + mc_genmcl.px_data.opc],	rax
    jmp       L2198
L2202:
    mov       rax,	119
    mov       [rbp + mc_genmcl.px_data.opc],	rax
    jmp       L2198
L2203:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5722]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    mov       r10d,	[rax+4]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    lea       rcx,	[rel L5723]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genmcl.px_data.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	r10
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5724]
    lea       rdx,	[rel L5725]
    call      mc_libmcl.merror
L2198:
    mov       rcx,	[rbp + mc_genmcl.px_data.opc]
    mov       rdx,	[rbp + mc_genmcl.px_data.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2186:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_label
mc_genmcl.px_label:
;>>
    %define mc_genmcl.px_label.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_label.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2204:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_load
mc_genmcl.px_load:
;>>
    %define mc_genmcl.px_load.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_load.p]
    call      mc_stackmcl.pushpcl
L2205:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_store
mc_genmcl.px_store:
;>>
    %define mc_genmcl.px_store.p 16
    %define mc_genmcl.px_store.ax -8
    %define mc_genmcl.px_store.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_store.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_store.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_store.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	11
    jz        L2208
    mov       rax,	[rbp + mc_genmcl.px_store.p]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + mc_genmcl.px_store.p]
    mov       r11,	[rax+8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_genmcl.px_store.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_store.ax]
    mov       r8,	[rbp + mc_genmcl.px_store.bx]
    call      mc_libmcl.genmc
    jmp       L2207
L2208:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_store.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_store.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_genmcl.px_store.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_store.ax]
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       [rbp + mc_genmcl.px_store.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_store.bx]
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       [rbp + mc_genmcl.px_store.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_store.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_genmcl.px_store.ax]
    mov       rdx,	[rbp + mc_genmcl.px_store.bx]
    mov       r8,	r10
    mov       r9,	1
    call      mc_auxmcl.copyblock
L2207:
    call      mc_stackmcl.poppcl
L2206:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_add
mc_genmcl.px_add:
;>>
    %define mc_genmcl.px_add.p 16
    %define mc_genmcl.px_add.ax -8
    %define mc_genmcl.px_add.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_add.p]
    movzx     r10,	byte [rax+3]
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_add.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_add.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_add.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_add.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L2211
    mov       rax,	[rbp + mc_genmcl.px_add.p]
    movzx     r10,	byte [rax+3]
    sub       r10,	1
    mov       rax,	66
    add       rax,	r10
    jmp       L2210
L2211:
    mov       rax,	29
L2210:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_add.ax]
    mov       r8,	[rbp + mc_genmcl.px_add.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2209:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_sub
mc_genmcl.px_sub:
;>>
    %define mc_genmcl.px_sub.p 16
    %define mc_genmcl.px_sub.ax -8
    %define mc_genmcl.px_sub.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_sub.p]
    movzx     r10,	byte [rax+3]
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_sub.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_sub.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_sub.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_sub.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L2214
    mov       rax,	[rbp + mc_genmcl.px_sub.p]
    movzx     r10,	byte [rax+3]
    sub       r10,	1
    mov       rax,	68
    add       rax,	r10
    jmp       L2213
L2214:
    mov       rax,	30
L2213:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_sub.ax]
    mov       r8,	[rbp + mc_genmcl.px_sub.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2212:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_mul
mc_genmcl.px_mul:
;>>
    %define mc_genmcl.px_mul.p 16
    %define mc_genmcl.px_mul.ax -8
    %define mc_genmcl.px_mul.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_mul.p]
    movzx     r10,	byte [rax+3]
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_mul.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_mul.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_mul.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_mul.p]
    movzx     r10,	byte [rax+3]
    cmp       r10,	2
    jg        L2217
    mov       rax,	[rbp + mc_genmcl.px_mul.p]
    movzx     r10,	byte [rax+3]
    sub       r10,	1
    mov       rax,	70
    add       rax,	r10
    jmp       L2216
L2217:
    mov       rax,	35
L2216:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_mul.ax]
    mov       r8,	[rbp + mc_genmcl.px_mul.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2215:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_div
mc_genmcl.px_div:
;>>
    %define mc_genmcl.px_div.p 16
    %define mc_genmcl.px_div.ax -8
    %define mc_genmcl.px_div.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_div.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_div.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	72
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_div.ax]
    mov       r8,	[rbp + mc_genmcl.px_div.bx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2218:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_eval
mc_genmcl.px_eval:
;>>
    %define mc_genmcl.px_eval.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_eval.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
L2219:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_widen
mc_genmcl.px_widen:
;>>
    %define mc_genmcl.px_widen.p 16
    %define mc_genmcl.px_widen.ax -8
    %define mc_genmcl.px_widen.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_widen.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_widen.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_widen.bx]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L2222
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_widen.ax],	rax
    jmp       L2221
L2222:
    mov       rax,	[rbp + mc_genmcl.px_widen.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_widen.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_widen.bx]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_libmcl.mgenregi
    mov       [rbp + mc_genmcl.px_widen.ax],	rax
L2221:
    mov       rax,	[rbp + mc_genmcl.px_widen.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    lea       rax,	[pc_tables.psigned]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L2224
    mov       rax,	19
    jmp       L2223
L2224:
    mov       rax,	20
L2223:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_widen.ax]
    mov       r8,	[rbp + mc_genmcl.px_widen.bx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_widen.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2220:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_jump
mc_genmcl.px_jump:
;>>
    %define mc_genmcl.px_jump.p 16
    %define mc_genmcl.px_jump.labno -8
    %define mc_genmcl.px_jump.q -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_jump.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_jump.labno],	r10
    mov       rax,	[rbp + mc_genmcl.px_jump.p]
    lea       rax,	[rax+32]
    mov       [rbp + mc_genmcl.px_jump.q],	rax
    jmp       L2227
L2226:
    add       qword [rbp + mc_genmcl.px_jump.q],	32
L2227:
    mov       rax,	[rbp + mc_genmcl.px_jump.q]
    movzx     r10,	byte [rax]
    cmp       r10,	133
    jz        L2226
L2228:
    mov       rax,	[rbp + mc_genmcl.px_jump.q]
    movzx     r10,	byte [rax]
    cmp       r10,	125
    jz        L2230
    cmp       r10,	23
    jz        L2231
    jmp       L2232
L2230:
    mov       rax,	[rbp + mc_genmcl.px_jump.q]
    mov       r10,	[rax+8]
    cmp       r10,	[rbp + mc_genmcl.px_jump.labno]
    jnz       L2234
    jmp       L2225
L2234:
L2233:
    add       qword [rbp + mc_genmcl.px_jump.q],	32
    mov       rax,	[rbp + mc_genmcl.px_jump.q]
    movzx     r10,	byte [rax]
    cmp       r10,	125
    jnz       L2236
    mov       rax,	[rbp + mc_genmcl.px_jump.q]
    mov       r10,	[rax+8]
    cmp       r10,	[rbp + mc_genmcl.px_jump.labno]
    jnz       L2236
    jmp       L2225
L2236:
L2235:
    jmp       L2229
L2231:
    xor       eax,	eax
    mov       r10,	[rbp + mc_genmcl.px_jump.q]
    mov       [r10],	al
L2232:
L2229:
    mov       rcx,	[rbp + mc_genmcl.px_jump.labno]
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2225:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_neg
mc_genmcl.px_neg:
;>>
    %define mc_genmcl.px_neg.p 16
    %define mc_genmcl.px_neg.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_neg.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2239
    mov       rcx,	51
    mov       rdx,	[rbp + mc_genmcl.px_neg.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2238
L2239:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_genmcl.px_neg.ax]
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
L2238:
L2237:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_abs
mc_genmcl.px_abs:
;>>
    %define mc_genmcl.px_abs.p 16
    %define mc_genmcl.px_abs.ax -8
    %define mc_genmcl.px_abs.lx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_abs.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2242
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_abs.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_abs.lx],	r10
    mov       rcx,	27
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	51
    mov       rdx,	[rbp + mc_genmcl.px_abs.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_genmcl.px_abs.lx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2241
L2242:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_genmcl.px_abs.ax]
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L2241:
L2240:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_bitnot
mc_genmcl.px_bitnot:
;>>
    %define mc_genmcl.px_bitnot.p 16
    %define mc_genmcl.px_bitnot.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_bitnot.ax],	rax
    mov       rcx,	52
    mov       rdx,	[rbp + mc_genmcl.px_bitnot.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2243:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_not
mc_genmcl.px_not:
;>>
    %define mc_genmcl.px_not.p 16
    %define mc_genmcl.px_not.ax -8
    %define mc_genmcl.px_not.$T1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_not.ax],	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_not.$T1],	rax
    mov       rcx,	[rbp + mc_genmcl.px_not.ax]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	41
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
L2244:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_toboolt
mc_genmcl.px_toboolt:
;>>
    %define mc_genmcl.px_toboolt.p 16
    %define mc_genmcl.px_toboolt.ax -8
    %define mc_genmcl.px_toboolt.bx -16
    %define mc_genmcl.px_toboolt.cx -24
    %define mc_genmcl.px_toboolt.pmode2 -32
    %define mc_genmcl.px_toboolt.$T2 -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_toboolt.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       [rbp + mc_genmcl.px_toboolt.pmode2],	r10b
    movzx     rax,	byte [rbp + mc_genmcl.px_toboolt.pmode2]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_toboolt.ax],	rax
    movzx     rax,	byte [rbp + mc_genmcl.px_toboolt.pmode2]
    cmp       rax,	2
    jg        L2247
    movzx     rax,	byte [rbp + mc_genmcl.px_toboolt.pmode2]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_toboolt.bx],	rax
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_toboolt.cx],	rax
    movzx     rax,	byte [rbp + mc_genmcl.px_toboolt.pmode2]
    sub       rax,	1
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_toboolt.bx]
    mov       r8,	[rbp + mc_genmcl.px_toboolt.bx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [rbp + mc_genmcl.px_toboolt.pmode2]
    sub       rax,	1
    mov       r10,	74
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_toboolt.ax]
    mov       r8,	[rbp + mc_genmcl.px_toboolt.bx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_toboolt.p]
    movzx     r10,	byte [rax]
    cmp       r10,	63
    jnz       L2249
    mov       rax,	5
    jmp       L2248
L2249:
    mov       rax,	4
L2248:
    mov       rcx,	59
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.cx]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	[rbp + mc_genmcl.px_toboolt.cx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	20
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.cx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_toboolt.cx]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    jmp       L2246
L2247:
    mov       rcx,	42
    mov       rdx,	[rbp + mc_genmcl.px_toboolt.ax]
    mov       r8,	[rbp + mc_genmcl.px_toboolt.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_toboolt.ax]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_toboolt.bx],	r10
    mov       [rbp + mc_genmcl.px_toboolt.$T2],	rax
    mov       rax,	[rbp + mc_genmcl.px_toboolt.p]
    movzx     r10,	byte [rax]
    cmp       r10,	63
    jnz       L2251
    mov       rax,	5
    jmp       L2250
L2251:
    mov       rax,	4
L2250:
    mov       rcx,	59
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.$T2]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	[rbp + mc_genmcl.px_toboolt.ax]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	20
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.bx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-3],	al
L2246:
L2245:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc px_sqr
mc_genmcl.px_sqr:
;>>
    %define mc_genmcl.px_sqr.p 16
    %define mc_genmcl.px_sqr.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_sqr.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2254
    mov       rcx,	35
    mov       rdx,	[rbp + mc_genmcl.px_sqr.ax]
    mov       r8,	[rbp + mc_genmcl.px_sqr.ax]
    call      mc_libmcl.genmc
    jmp       L2253
L2254:
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	70
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_sqr.ax]
    mov       r8,	[rbp + mc_genmcl.px_sqr.ax]
    call      mc_libmcl.genmc
L2253:
L2252:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_sqrt
mc_genmcl.px_sqrt:
;>>
    %define mc_genmcl.px_sqrt.p 16
    %define mc_genmcl.px_sqrt.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_sqrt.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	64
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_sqrt.ax]
    mov       r8,	[rbp + mc_genmcl.px_sqrt.ax]
    call      mc_libmcl.genmc
L2255:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_jumpcc
mc_genmcl.px_jumpcc:
;>>
    %define mc_genmcl.px_jumpcc.p 16
    %define mc_genmcl.px_jumpcc.mcond -8
    %define mc_genmcl.px_jumpcc.ax -16
    %define mc_genmcl.px_jumpcc.bx -24
    %define mc_genmcl.px_jumpcc.lx -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_jumpcc.p]
    movzx     r10,	byte [rax+2]
    lea       rax,	[mc_genmcl.ucondcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_genmcl.px_jumpcc.mcond],	r11
    mov       rax,	[rbp + mc_genmcl.px_jumpcc.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       [rbp + mc_genmcl.px_jumpcc.lx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2258
    lea       rcx,	[rel L5726]
    lea       rdx,	[rel L5727]
    call      mc_libmcl.merror
    jmp       L2257
L2258:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_jumpcc.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_jumpcc.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2260
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2262
    mov       rax,	[rbp + mc_genmcl.px_jumpcc.p]
    movzx     r10,	byte [rax+2]
    lea       rax,	[mc_genmcl.scondcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_genmcl.px_jumpcc.mcond],	r11
L2262:
L2261:
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_jumpcc.ax]
    mov       r8,	[rbp + mc_genmcl.px_jumpcc.bx]
    call      mc_libmcl.genmc
    jmp       L2259
L2260:
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	74
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_jumpcc.ax]
    mov       r8,	[rbp + mc_genmcl.px_jumpcc.bx]
    call      mc_libmcl.genmc
L2259:
    mov       rcx,	27
    mov       rdx,	[rbp + mc_genmcl.px_jumpcc.mcond]
    mov       r8,	[rbp + mc_genmcl.px_jumpcc.lx]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       rax,	[rbp + mc_genmcl.px_jumpcc.p]
    movsxd    r10,	dword [rax+16]
    test      r10,	r10
    jnz       L2264
    call      mc_stackmcl.poppcl
L2264:
L2263:
L2257:
L2256:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_jumpt
mc_genmcl.px_jumpt:
;>>
    %define mc_genmcl.px_jumpt.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_jumpt.p]
    mov       rdx,	5
    call      mc_auxmcl.do_jumptruefalse
L2265:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_jumpf
mc_genmcl.px_jumpf:
;>>
    %define mc_genmcl.px_jumpf.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_jumpf.p]
    mov       rdx,	4
    call      mc_auxmcl.do_jumptruefalse
L2266:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_bitand
mc_genmcl.px_bitand:
;>>
    %define mc_genmcl.px_bitand.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_bitand.p]
    mov       rdx,	39
    call      mc_auxmcl.do_bitwise
L2267:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_bitor
mc_genmcl.px_bitor:
;>>
    %define mc_genmcl.px_bitor.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_bitor.p]
    mov       rdx,	40
    call      mc_auxmcl.do_bitwise
L2268:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_bitxor
mc_genmcl.px_bitxor:
;>>
    %define mc_genmcl.px_bitxor.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_bitxor.p]
    mov       rdx,	41
    call      mc_auxmcl.do_bitwise
L2269:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_shl
mc_genmcl.px_shl:
;>>
    %define mc_genmcl.px_shl.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_shl.p]
    mov       rdx,	44
    call      mc_auxmcl.do_shift
L2270:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_shr
mc_genmcl.px_shr:
;>>
    %define mc_genmcl.px_shr.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2273
    mov       rax,	45
    jmp       L2272
L2273:
    mov       rax,	46
L2272:
    mov       rcx,	[rbp + mc_genmcl.px_shr.p]
    mov       rdx,	rax
    call      mc_auxmcl.do_shift
L2271:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_retproc
mc_genmcl.px_retproc:
;>>
    %define mc_genmcl.px_retproc.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_retproc.p]
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
L2274:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_retfn
mc_genmcl.px_retfn:
;>>
    %define mc_genmcl.px_retfn.p 16
    %define mc_genmcl.px_retfn.ax -8
    %define mc_genmcl.px_retfn.bx -16
    %define mc_genmcl.px_retfn.$T1 -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2277
    mov       rcx,	1
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_genmcl.px_retfn.bx],	rax
    mov       al,	1
    mov       [mc_decls.regset],	al
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_retfn.ax],	rax
    mov       rcx,	[pc_decls.blockretname]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_retfn.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_retfn.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_genmcl.px_retfn.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_retfn.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_genmcl.px_retfn.ax]
    mov       rdx,	[rbp + mc_genmcl.px_retfn.bx]
    mov       r8,	r10
    mov       r9,	1
    call      mc_auxmcl.copyblock
    mov       rcx,	[pc_decls.blockretname]
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_genmcl.px_retfn.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L2277:
L2276:
    mov       rcx,	[rbp + mc_genmcl.px_retfn.p]
    call      mc_genmcl.px_retproc
L2275:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_setcall
mc_genmcl.px_setcall:
;>>
    %define mc_genmcl.px_setcall.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
    mov       rax,	[mc_decls.ncalldepth]
    cmp       rax,	16
    jl        L2280
    lea       rcx,	[rel L5728]
    lea       rdx,	[rel L5729]
    call      mc_libmcl.merror
L2280:
L2279:
    inc       qword [mc_decls.ncalldepth]
    mov       rax,	[rbp + mc_genmcl.px_setcall.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	4
    jg        L2282
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    lea       r10,	[mc_decls.callalign]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    jmp       L2281
L2282:
    mov       rax,	[rbp + mc_genmcl.px_setcall.p]
    movsxd    r10,	dword [rax+16]
    and       r10d,	1
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    xor       r10,	rax
    lea       rax,	[mc_decls.callalign]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [rax + r11-1],	r10b
L2281:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    setz      al
    movzx     eax,	al
    lea       r10,	[mc_decls.callblockret]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_genmcl.px_setcall.p]
    mov       r10d,	[rax+4]
    lea       rax,	[mc_decls.callblocksize]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [rax + r11*4-4],	r10d
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L2284
    mov       rcx,	1
    call      mc_libmcl.pushslots
L2284:
L2283:
L2278:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_setarg
mc_genmcl.px_setarg:
;>>
    %define mc_genmcl.px_setarg.p 16
    %define mc_genmcl.px_setarg.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_setarg.p]
    movsxd    r10,	dword [rax+16]
    lea       rax,	[mc_decls.callblockret]
    mov       r11,	[mc_decls.ncalldepth]
    movzx     rdi,	byte [rax + r11-1]
    add       r10,	rdi
    mov       [rbp + mc_genmcl.px_setarg.n],	r10
    mov       rax,	[rbp + mc_genmcl.px_setarg.n]
    cmp       rax,	4
    jle       L2287
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2289
    mov       rax,	[rbp + mc_genmcl.px_setarg.p]
    mov       r10d,	[rax+4]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	[rbp + mc_genmcl.px_setarg.n]
    call      mc_auxmcl.copyblockarg
L2289:
L2288:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.pushopnd
    jmp       L2286
L2287:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2290
    mov       rax,	[rbp + mc_genmcl.px_setarg.p]
    mov       r10d,	[rax+4]
    lea       rax,	[mc_decls.callargsize]
    mov       r11,	[mc_decls.ncalldepth]
    shl       r11,	4
    lea       rax,	[rax + r11-16]
    mov       r11,	[rbp + mc_genmcl.px_setarg.n]
    mov       [rax + r11*4-4],	r10d
L2290:
L2286:
L2285:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_callp
mc_genmcl.px_callp:
;>>
    %define mc_genmcl.px_callp.p 16
    %define mc_genmcl.px_callp.nargs -8
    %define mc_genmcl.px_callp.nregargs -16
    %define mc_genmcl.px_callp.slots -24
    %define mc_genmcl.px_callp.isptr -32
    %define mc_genmcl.px_callp.shadow -40
    %define mc_genmcl.px_callp.blockret -48
    %define mc_genmcl.px_callp.av_1 -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mc_genmcl.px_callp.isptr],	rax
    xor       eax,	eax
    mov       [rbp + mc_genmcl.px_callp.shadow],	rax
    lea       rax,	[mc_decls.callblockret]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_genmcl.px_callp.blockret],	r11
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    r10,	dword [rax+16]
    add       r10,	[rbp + mc_genmcl.px_callp.blockret]
    mov       [rbp + mc_genmcl.px_callp.nargs],	r10
    mov       rax,	[rbp + mc_genmcl.px_callp.nargs]
    mov       r10,	4
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_genmcl.px_callp.nregargs],	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movzx     r10,	byte [rax]
    cmp       r10,	18
    jz        L2294
    cmp       r10,	21
    jnz       L2293
L2294:
    mov       rax,	1
    mov       [rbp + mc_genmcl.px_callp.isptr],	rax
L2293:
L2292:
    mov       rax,	[rbp + mc_genmcl.px_callp.nargs]
    cmp       [pc_decls.highargs],	rax
    jge       L5730
    mov       [pc_decls.highargs],	rax
L5730:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    r10,	dword [rax+20]
    mov       rcx,	[rbp + mc_genmcl.px_callp.nregargs]
    mov       rdx,	r10
    mov       r8,	[rbp + mc_genmcl.px_callp.isptr]
    call      mc_auxmcl.do_pushlowargs
    xor       eax,	eax
    mov       [rbp + mc_genmcl.px_callp.slots],	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.nargs]
    cmp       rax,	4
    jg        L2296
    mov       rax,	[mc_decls.mstackdepth]
    test      rax,	rax
    jz        L2298
    mov       rax,	4
    add       [rbp + mc_genmcl.px_callp.slots],	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     r11,	byte [rax + r10-1]
    add       [rbp + mc_genmcl.px_callp.slots],	r11
    jmp       L2297
L2298:
    mov       al,	1
    mov       [pc_decls.localshadow],	al
L2297:
    jmp       L2295
L2296:
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[rbp + mc_genmcl.px_callp.nargs]
    add       rax,	r11
    mov       [rbp + mc_genmcl.px_callp.slots],	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
L2295:
    mov       rax,	[rbp + mc_genmcl.px_callp.isptr]
    test      rax,	rax
    jz        L2300
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	22
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2299
L2300:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	22
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2299:
    mov       rax,	[rbp + mc_genmcl.px_callp.nregargs]
    sub       rax,	[rbp + mc_genmcl.px_callp.blockret]
    mov       [rbp + mc_genmcl.px_callp.av_1],	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.av_1]
    cmp       rax,	0
    jle       L2303
L2301:
    call      mc_stackmcl.poppcl
L2302:
    dec       qword [rbp + mc_genmcl.px_callp.av_1]
    jnz       L2301
L2303:
    mov       rax,	[rbp + mc_genmcl.px_callp.slots]
    test      rax,	rax
    jz        L2305
    mov       rcx,	[rbp + mc_genmcl.px_callp.slots]
    call      mc_libmcl.popslots
L2305:
L2304:
    movzx     rax,	byte [mc_decls.pmode]
    test      rax,	rax
    jz        L2307
    mov       rcx,	[rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L2307:
L2306:
    dec       qword [mc_decls.ncalldepth]
L2291:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc px_jumpret
mc_genmcl.px_jumpret:
;>>
    %define mc_genmcl.px_jumpret.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    test      rax,	rax
    jz        L2310
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    mov       r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L2310:
L2309:
    mov       rcx,	[rbp + mc_genmcl.px_jumpret.p]
    call      mc_genmcl.px_jump
L2308:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_jumpretm
mc_genmcl.px_jumpretm:
;>>
    %define mc_genmcl.px_jumpretm.p 16
    %define mc_genmcl.px_jumpretm.n -8
    %define mc_genmcl.px_jumpretm.av_1 -16
    %define mc_genmcl.px_jumpretm.i -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mc_genmcl.px_jumpretm.i],	rax
    mov       rax,	[rbp + mc_genmcl.px_jumpretm.p]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + mc_genmcl.px_jumpretm.av_1],	r10
    mov       rax,	[rbp + mc_genmcl.px_jumpretm.av_1]
    cmp       rax,	1
    jl        L2314
L2312:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	[rbp + mc_genmcl.px_jumpretm.i]
    add       rax,	1
    mov       [rbp + mc_genmcl.px_jumpretm.n],	rax
    mov       rax,	1
    add       rax,	[rbp + mc_genmcl.px_jumpretm.i]
    sub       rax,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[rbp + mc_genmcl.px_jumpretm.n]
    movzx     rdi,	byte [r10 + r11-1]
    mov       rcx,	[rbp + mc_genmcl.px_jumpretm.n]
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_stackmcl.loadparam
L2313:
    mov       rax,	[rbp + mc_genmcl.px_jumpretm.i]
    inc       rax
    mov       [rbp + mc_genmcl.px_jumpretm.i],	rax
    cmp       rax,	[rbp + mc_genmcl.px_jumpretm.av_1]
    jle       L2312
L2314:
    mov       rcx,	[rbp + mc_genmcl.px_jumpretm.p]
    call      mc_genmcl.px_jump
L2311:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_startmx
mc_genmcl.px_startmx:
;>>
    %define mc_genmcl.px_startmx.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
L2315:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_resetmx
mc_genmcl.px_resetmx:
;>>
    %define mc_genmcl.px_resetmx.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    mov       rax,	[rbp + mc_genmcl.px_resetmx.p]
    movzx     r10,	byte [rax]
    cmp       r10,	117
    jnz       L2318
    call      mc_stackmcl.poppcl
L2318:
L2317:
L2316:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_stop
mc_genmcl.px_stop:
;>>
    %define mc_genmcl.px_stop.p 16
    %define mc_genmcl.px_stop.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    mov       r8,	11
    call      mc_stackmcl.loadparam
    lea       rcx,	[rel L5731]
    call      mc_libmcl.findnamesym
    mov       [rbp + mc_genmcl.px_stop.d],	rax
    mov       rax,	[rbp + mc_genmcl.px_stop.d]
    test      rax,	rax
    jnz       L2321
    lea       rcx,	[rel L5731]
    xor       edx,	edx
    call      pc_api.pc_makesymbol
    mov       [rbp + mc_genmcl.px_stop.d],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_genmcl.px_stop.d]
    mov       [r10+56],	al
    mov       rcx,	[rbp + mc_genmcl.px_stop.d]
    call      mc_libmcl.addnamesym
L2321:
L2320:
    mov       rcx,	[rbp + mc_genmcl.px_stop.d]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	22
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [pc_decls.localshadow],	al
    mov       rax,	1
    cmp       [pc_decls.highargs],	rax
    jge       L5732
    mov       [pc_decls.highargs],	rax
L5732:
    call      mc_stackmcl.poppcl
L2319:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_incrto
mc_genmcl.px_incrto:
;>>
    %define mc_genmcl.px_incrto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_incrto.p]
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incr
L2322:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_decrto
mc_genmcl.px_decrto:
;>>
    %define mc_genmcl.px_decrto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_decrto.p]
    mov       rdx,	54
    mov       r8,	30
    call      mc_auxmcl.do_incr
L2323:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_incrload
mc_genmcl.px_incrload:
;>>
    %define mc_genmcl.px_incrload.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_incrload.p]
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incrload
L2324:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_decrload
mc_genmcl.px_decrload:
;>>
    %define mc_genmcl.px_decrload.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_decrload.p]
    mov       rdx,	54
    mov       r8,	30
    call      mc_auxmcl.do_incrload
L2325:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_loadincr
mc_genmcl.px_loadincr:
;>>
    %define mc_genmcl.px_loadincr.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_loadincr.p]
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_loadincr
L2326:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_loaddecr
mc_genmcl.px_loaddecr:
;>>
    %define mc_genmcl.px_loaddecr.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_loaddecr.p]
    mov       rdx,	54
    mov       r8,	30
    call      mc_auxmcl.do_loadincr
L2327:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_forup
mc_genmcl.px_forup:
;>>
    %define mc_genmcl.px_forup.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_forup.p]
    mov       rdx,	53
    mov       r8,	29
    mov       r9,	14
    call      mc_auxmcl.do_for
L2328:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_fordown
mc_genmcl.px_fordown:
;>>
    %define mc_genmcl.px_fordown.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_fordown.p]
    mov       rdx,	54
    mov       r8,	30
    mov       r9,	13
    call      mc_auxmcl.do_for
L2329:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_iload
mc_genmcl.px_iload:
;>>
    %define mc_genmcl.px_iload.p 16
    %define mc_genmcl.px_iload.ax -8
    %define mc_genmcl.px_iload.px -16
    %define mc_genmcl.px_iload.nextpcl -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jz        L2332
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_iload.px],	rax
    mov       rax,	[rbp + mc_genmcl.px_iload.p]
    movzx     r10,	byte [rax]
    cmp       r10,	2
    jz        L2334
    mov       rcx,	[rbp + mc_genmcl.px_iload.px]
    mov       rdx,	[mc_genmcl.pxoffset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       [rbp + mc_genmcl.px_iload.px],	rax
L2334:
L2333:
    mov       rax,	[mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       [rbp + mc_genmcl.px_iload.nextpcl],	rax
    mov       rax,	[rbp + mc_genmcl.px_iload.nextpcl]
    movzx     r10,	byte [rax]
    cmp       r10,	113
    jnz       L2336
    mov       rax,	[rbp + mc_genmcl.px_iload.nextpcl]
    movzx     r10,	byte [rax+3]
    xor       ecx,	ecx
    mov       rdx,	r10
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_iload.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_iload.nextpcl]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    lea       rax,	[mc_decls.ploadop]
    movzx     r11,	byte [rax + r10]
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_genmcl.px_iload.ax]
    mov       r8,	[rbp + mc_genmcl.px_iload.px]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_iload.nextpcl]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + mc_genmcl.px_iload.ax]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_stackmcl.setnewzz
    mov       rax,	[rbp + mc_genmcl.px_iload.nextpcl]
    mov       [mc_decls.currpcl],	rax
    jmp       L2335
L2336:
    movzx     rax,	byte [mc_decls.pmode]
    xor       ecx,	ecx
    mov       rdx,	rax
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_iload.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_iload.ax]
    mov       r8,	[rbp + mc_genmcl.px_iload.px]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_iload.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2335:
    jmp       L2331
L2332:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       [rbp + mc_genmcl.px_iload.px],	rax
    mov       rax,	[rbp + mc_genmcl.px_iload.p]
    movzx     r10,	byte [rax]
    cmp       r10,	2
    jz        L2338
    mov       rcx,	[rbp + mc_genmcl.px_iload.px]
    mov       rdx,	[mc_genmcl.pxoffset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       [rbp + mc_genmcl.px_iload.px],	rax
L2338:
L2337:
    mov       rax,	[rbp + mc_genmcl.px_iload.px]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_iload.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_iload.ax]
    mov       rdx,	[rbp + mc_genmcl.px_iload.px]
    call      mc_auxmcl.dolea
L2331:
L2330:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_iloadx
mc_genmcl.px_iloadx:
;>>
    %define mc_genmcl.px_iloadx.p 16
    %define mc_genmcl.px_iloadx.z -8
    %define mc_genmcl.px_iloadx.nextpcl -16
    %define mc_genmcl.px_iloadx.ax -24
    %define mc_genmcl.px_iloadx.bx -32
    %define mc_genmcl.px_iloadx.px -40
    %define mc_genmcl.px_iloadx.fx -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_iloadx.z],	rax
    test      rax,	rax
    jz        L2341
    mov       rax,	[rbp + mc_genmcl.px_iloadx.z]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_iloadx.p]
    movsxd    r11,	dword [rax+16]
    imul      r10,	r11
    mov       rax,	[rbp + mc_genmcl.px_iloadx.p]
    movsxd    r11,	dword [rax+20]
    add       r10,	r11
    mov       [mc_genmcl.pxoffset],	r10
    call      mc_stackmcl.poppcl
    mov       rcx,	[rbp + mc_genmcl.px_iloadx.p]
    call      mc_genmcl.px_iload
    jmp       L2339
L2341:
L2340:
    mov       rcx,	[rbp + mc_genmcl.px_iloadx.p]
    call      mc_auxmcl.do_addrmode
    mov       [rbp + mc_genmcl.px_iloadx.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2343
    mov       rax,	[rbp + mc_genmcl.px_iloadx.px]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_iloadx.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_iloadx.ax]
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.px]
    call      mc_auxmcl.dolea
    mov       rax,	[rbp + mc_genmcl.px_iloadx.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L2342
L2343:
    mov       rax,	[mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       [rbp + mc_genmcl.px_iloadx.nextpcl],	rax
    mov       rax,	[rbp + mc_genmcl.px_iloadx.nextpcl]
    movzx     r10,	byte [rax]
    cmp       r10,	113
    jnz       L2345
    mov       rax,	[rbp + mc_genmcl.px_iloadx.nextpcl]
    movzx     r10,	byte [rax+3]
    xor       ecx,	ecx
    mov       rdx,	r10
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_iloadx.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_iloadx.nextpcl]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    lea       rax,	[mc_decls.ploadop]
    movzx     r11,	byte [rax + r10]
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.ax]
    mov       r8,	[rbp + mc_genmcl.px_iloadx.px]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       rax,	[rbp + mc_genmcl.px_iloadx.nextpcl]
    movzx     r10,	byte [rax+3]
    mov       rax,	[rbp + mc_genmcl.px_iloadx.ax]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_stackmcl.setnewzz
    mov       rax,	[rbp + mc_genmcl.px_iloadx.nextpcl]
    mov       [mc_decls.currpcl],	rax
    jmp       L2344
L2345:
    movzx     rax,	byte [mc_decls.pmode]
    xor       ecx,	ecx
    mov       rdx,	rax
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_iloadx.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.ax]
    mov       r8,	[rbp + mc_genmcl.px_iloadx.px]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_iloadx.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2344:
L2342:
L2339:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc px_istore
mc_genmcl.px_istore:
;>>
    %define mc_genmcl.px_istore.p 16
    %define mc_genmcl.px_istore.bx -8
    %define mc_genmcl.px_istore.px -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_istore.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_istore.px],	rax
    mov       rax,	[rbp + mc_genmcl.px_istore.p]
    movzx     r10,	byte [rax]
    cmp       r10,	5
    jz        L2348
    mov       rcx,	[rbp + mc_genmcl.px_istore.px]
    mov       rdx,	[mc_genmcl.pxoffset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       [rbp + mc_genmcl.px_istore.px],	rax
L2348:
L2347:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2350
    mov       rcx,	[rbp + mc_genmcl.px_istore.px]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_genmcl.px_istore.px],	rax
    mov       rcx,	[rbp + mc_genmcl.px_istore.bx]
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       [rbp + mc_genmcl.px_istore.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_istore.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_genmcl.px_istore.px]
    mov       rdx,	[rbp + mc_genmcl.px_istore.bx]
    mov       r8,	r10
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2349
L2350:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_istore.px]
    mov       r8,	[rbp + mc_genmcl.px_istore.bx]
    call      mc_libmcl.genmc
L2349:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2346:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_istorex
mc_genmcl.px_istorex:
;>>
    %define mc_genmcl.px_istorex.p 16
    %define mc_genmcl.px_istorex.ax -8
    %define mc_genmcl.px_istorex.cx -16
    %define mc_genmcl.px_istorex.px -24
    %define mc_genmcl.px_istorex.z -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_istorex.z],	rax
    test      rax,	rax
    jz        L2353
    mov       rax,	[rbp + mc_genmcl.px_istorex.z]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_istorex.p]
    movsxd    r11,	dword [rax+16]
    imul      r10,	r11
    mov       rax,	[rbp + mc_genmcl.px_istorex.p]
    movsxd    r11,	dword [rax+20]
    add       r10,	r11
    mov       [mc_genmcl.pxoffset],	r10
    call      mc_stackmcl.poppcl
    mov       rcx,	[rbp + mc_genmcl.px_istorex.p]
    call      mc_genmcl.px_istore
    jmp       L2351
L2353:
L2352:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_istorex.cx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_istorex.p]
    call      mc_auxmcl.do_addrmode
    mov       [rbp + mc_genmcl.px_istorex.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2355
    mov       rcx,	[rbp + mc_genmcl.px_istorex.px]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_genmcl.px_istorex.px],	rax
    mov       rcx,	[rbp + mc_genmcl.px_istorex.cx]
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       [rbp + mc_genmcl.px_istorex.cx],	rax
    mov       rax,	[rbp + mc_genmcl.px_istorex.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_genmcl.px_istorex.px]
    mov       rdx,	[rbp + mc_genmcl.px_istorex.cx]
    mov       r8,	r10
    mov       r9,	1
    call      mc_auxmcl.copyblock
    mov       rax,	[rbp + mc_genmcl.px_istorex.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_genmcl.px_istorex.px]
    mov       rdx,	[rbp + mc_genmcl.px_istorex.cx]
    mov       r8,	r10
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2354
L2355:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_istorex.px]
    mov       r8,	[rbp + mc_genmcl.px_istorex.cx]
    call      mc_libmcl.genmc
L2354:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2351:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_addpx
mc_genmcl.px_addpx:
;>>
    %define mc_genmcl.px_addpx.p 16
    %define mc_genmcl.px_addpx.ax -8
    %define mc_genmcl.px_addpx.cx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_addpx.p]
    call      mc_auxmcl.do_addrmode
    mov       [rbp + mc_genmcl.px_addpx.cx],	rax
    mov       rax,	[rbp + mc_genmcl.px_addpx.cx]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_genmcl.px_addpx.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_addpx.ax]
    mov       rdx,	[rbp + mc_genmcl.px_addpx.cx]
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    mov       rax,	[rbp + mc_genmcl.px_addpx.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
L2356:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_subpx
mc_genmcl.px_subpx:
;>>
    %define mc_genmcl.px_subpx.p 16
    %define mc_genmcl.px_subpx.scale -8
    %define mc_genmcl.px_subpx.extra -16
    %define mc_genmcl.px_subpx.offset -24
    %define mc_genmcl.px_subpx.ax -32
    %define mc_genmcl.px_subpx.bx -40
    %define mc_genmcl.px_subpx.z -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_subpx.p]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + mc_genmcl.px_subpx.scale],	r10
    mov       rax,	[rbp + mc_genmcl.px_subpx.p]
    movsxd    r10,	dword [rax+20]
    mov       [rbp + mc_genmcl.px_subpx.extra],	r10
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_subpx.ax],	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_subpx.z],	rax
    test      rax,	rax
    jz        L2359
    mov       rax,	[rbp + mc_genmcl.px_subpx.z]
    mov       r10,	[rax+8]
    imul      r10,	[rbp + mc_genmcl.px_subpx.scale]
    add       r10,	[rbp + mc_genmcl.px_subpx.extra]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	30
    mov       rdx,	[rbp + mc_genmcl.px_subpx.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2358
L2359:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_subpx.bx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_subpx.bx]
    mov       rdx,	[rbp + mc_genmcl.px_subpx.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_genmcl.px_subpx.scale],	rax
    mov       rax,	[rbp + mc_genmcl.px_subpx.scale]
    cmp       rax,	1
    jle       L2361
    mov       rcx,	[rbp + mc_genmcl.px_subpx.bx]
    mov       rdx,	[rbp + mc_genmcl.px_subpx.scale]
    call      mc_auxmcl.mulimm
L2361:
L2360:
    mov       rcx,	30
    mov       rdx,	[rbp + mc_genmcl.px_subpx.ax]
    mov       r8,	[rbp + mc_genmcl.px_subpx.bx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_subpx.extra]
    test      rax,	rax
    jz        L2363
    call      msys.m$print_startcon
    lea       rcx,	[rel L5733]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_genmcl.px_subpx.extra]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5734]
    lea       rdx,	[rel L5735]
    call      mc_libmcl.merror
L2363:
L2362:
L2358:
    call      mc_stackmcl.poppcl
L2357:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc px_to
mc_genmcl.px_to:
;>>
    %define mc_genmcl.px_to.p 16
    %define mc_genmcl.px_to.q -8
    %define mc_genmcl.px_to.ax -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_to.p]
    lea       rax,	[rax+32]
    mov       [mc_decls.currpcl],	rax
    mov       [rbp + mc_genmcl.px_to.q],	rax
    mov       rax,	[rbp + mc_genmcl.px_to.q]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_genmcl.px_to.ax],	rax
    mov       rcx,	54
    mov       rdx,	[rbp + mc_genmcl.px_to.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_to.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
L2364:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_iswap
mc_genmcl.px_iswap:
;>>
    %define mc_genmcl.px_iswap.p 16
    %define mc_genmcl.px_iswap.ax -8
    %define mc_genmcl.px_iswap.bx -16
    %define mc_genmcl.px_iswap.px -24
    %define mc_genmcl.px_iswap.qx -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_iswap.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_iswap.qx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_iswap.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_iswap.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jz        L2367
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_iswap.ax]
    mov       r8,	[rbp + mc_genmcl.px_iswap.px]
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_iswap.bx]
    mov       r8,	[rbp + mc_genmcl.px_iswap.qx]
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_iswap.qx]
    mov       r8,	[rbp + mc_genmcl.px_iswap.ax]
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_iswap.px]
    mov       r8,	[rbp + mc_genmcl.px_iswap.bx]
    call      mc_libmcl.genmc
    jmp       L2366
L2367:
    lea       rcx,	[rel L5736]
    lea       rdx,	[rel L5737]
    call      mc_libmcl.merror
L2366:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2365:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_swapstk
mc_genmcl.px_swapstk:
;>>
    %define mc_genmcl.px_swapstk.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_swapstk.p]
    movsxd    r10,	dword [rax+20]
    mov       rax,	[mc_decls.noperands]
    sub       rax,	r10
    add       rax,	1
    mov       r10,	[rbp + mc_genmcl.px_swapstk.p]
    movsxd    r11,	dword [r10+16]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	r11
    add       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.swapopnds
L2368:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_labeldef
mc_genmcl.px_labeldef:
;>>
    %define mc_genmcl.px_labeldef.p 16
    %define mc_genmcl.px_labeldef.str -104
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_labeldef.p]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    lea       rdx,	[rel L5738]
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
L2369:
;---------------
    add       rsp,	144
    pop       rbp
    ret       
;End 
;Proc px_addto
mc_genmcl.px_addto:
;>>
    %define mc_genmcl.px_addto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_addto.p]
    mov       rdx,	29
    mov       r8,	66
    call      mc_auxmcl.do_binto
L2370:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_subto
mc_genmcl.px_subto:
;>>
    %define mc_genmcl.px_subto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_subto.p]
    mov       rdx,	30
    mov       r8,	68
    call      mc_auxmcl.do_binto
L2371:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_multo
mc_genmcl.px_multo:
;>>
    %define mc_genmcl.px_multo.p 16
    %define mc_genmcl.px_multo.ax -8
    %define mc_genmcl.px_multo.bx -16
    %define mc_genmcl.px_multo.cx -24
    %define mc_genmcl.px_multo.x -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2374
    mov       rcx,	[rbp + mc_genmcl.px_multo.p]
    mov       rdx,	70
    call      mc_auxmcl.do_binto_float
    jmp       L2372
L2374:
L2373:
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r11,	byte [r10 + rax]
    cmp       r11,	1
    jnz       L2376
    lea       rcx,	[rel L5739]
    lea       rdx,	[rel L5740]
    call      mc_libmcl.merror
L2376:
L2375:
    mov       rcx,	10
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_multo.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_multo.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_multo.cx],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_multo.cx]
    mov       r8,	[rbp + mc_genmcl.px_multo.ax]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_multo.x],	rax
    test      rax,	rax
    jz        L2378
    mov       rax,	[rbp + mc_genmcl.px_multo.x]
    mov       r10,	[rax+8]
    mov       rcx,	[rbp + mc_genmcl.px_multo.cx]
    mov       rdx,	r10
    call      mc_auxmcl.mulimm
    jmp       L2377
L2378:
    mov       rcx,	35
    mov       rdx,	[rbp + mc_genmcl.px_multo.cx]
    mov       r8,	[rbp + mc_genmcl.px_multo.bx]
    call      mc_libmcl.genmc
L2377:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_multo.ax]
    mov       r8,	[rbp + mc_genmcl.px_multo.cx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2372:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_bitandto
mc_genmcl.px_bitandto:
;>>
    %define mc_genmcl.px_bitandto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_bitandto.p]
    mov       rdx,	39
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
L2379:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_bitorto
mc_genmcl.px_bitorto:
;>>
    %define mc_genmcl.px_bitorto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_bitorto.p]
    mov       rdx,	40
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
L2380:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_bitxorto
mc_genmcl.px_bitxorto:
;>>
    %define mc_genmcl.px_bitxorto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_bitxorto.p]
    mov       rdx,	41
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
L2381:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_shlto
mc_genmcl.px_shlto:
;>>
    %define mc_genmcl.px_shlto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_shlto.p]
    mov       rdx,	44
    call      mc_auxmcl.do_shiftnto
L2382:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_shrto
mc_genmcl.px_shrto:
;>>
    %define mc_genmcl.px_shrto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2385
    mov       rax,	45
    jmp       L2384
L2385:
    mov       rax,	46
L2384:
    mov       rcx,	[rbp + mc_genmcl.px_shrto.p]
    mov       rdx,	rax
    call      mc_auxmcl.do_shiftnto
L2383:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_fix
mc_genmcl.px_fix:
;>>
    %define mc_genmcl.px_fix.p 16
    %define mc_genmcl.px_fix.fx -8
    %define mc_genmcl.px_fix.ax -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_fix.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_fix.fx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.pmin]
    movzx     r11,	byte [r10 + rax]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r11
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_fix.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_fix.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    sub       r10,	1
    mov       rax,	84
    add       rax,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_fix.ax]
    mov       r8,	[rbp + mc_genmcl.px_fix.fx]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_fix.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2386:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_float
mc_genmcl.px_float:
;>>
    %define mc_genmcl.px_float.p 16
    %define mc_genmcl.px_float.ax -8
    %define mc_genmcl.px_float.fx -16
    %define mc_genmcl.px_float.lab -24
    %define mc_genmcl.px_float.lab2 -32
    %define mc_genmcl.px_float.pmode2 -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_float.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       [rbp + mc_genmcl.px_float.pmode2],	r10b
    movzx     rax,	byte [rbp + mc_genmcl.px_float.pmode2]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_float.ax],	rax
    movzx     rax,	byte [rbp + mc_genmcl.px_float.pmode2]
    lea       r10,	[pc_tables.psize]
    movzx     r11,	byte [r10 + rax]
    cmp       r11,	4
    jge       L2389
    lea       rcx,	[rel L5741]
    lea       rdx,	[rel L5742]
    call      mc_libmcl.merror
L2389:
L2388:
    movzx     rax,	byte [rbp + mc_genmcl.px_float.pmode2]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2391
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rax,	[rbp + mc_genmcl.px_float.p]
    movzx     r10,	byte [rax+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_float.fx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	86
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_float.fx]
    mov       r8,	[rbp + mc_genmcl.px_float.ax]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2390
L2391:
    movzx     rax,	byte [rbp + mc_genmcl.px_float.pmode2]
    cmp       rax,	6
    jnz       L2392
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_float.fx],	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       [rbp + mc_genmcl.px_float.lab],	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       [rbp + mc_genmcl.px_float.lab2],	rax
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_float.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_float.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	87
    mov       rdx,	[rbp + mc_genmcl.px_float.fx]
    mov       r8,	[rbp + mc_genmcl.px_float.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_float.lab2]
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_float.lab]
    call      mc_libmcl.mdefinefwdlabel
    mov       rax,	[mc_decls.labmask63]
    test      rax,	rax
    jnz       L2394
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [mc_decls.labmask63],	rax
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [mc_decls.laboffset64],	rax
L2394:
L2393:
    mov       rcx,	[mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	39
    mov       rdx,	[rbp + mc_genmcl.px_float.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	87
    mov       rdx,	[rbp + mc_genmcl.px_float.fx]
    mov       r8,	[rbp + mc_genmcl.px_float.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	67
    mov       rdx,	[rbp + mc_genmcl.px_float.fx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_float.lab2]
    call      mc_libmcl.mdefinefwdlabel
;reduce:
L2395:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	1
    jnz       L2397
    mov       rcx,	[rbp + mc_genmcl.px_float.fx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_float.fx]
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L2397:
L2396:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2390
L2392:
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_float.fx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_float.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_genmcl.px_float.ax],	rax
    mov       rcx,	87
    mov       rdx,	[rbp + mc_genmcl.px_float.fx]
    mov       r8,	[rbp + mc_genmcl.px_float.ax]
    call      mc_libmcl.genmc
    jmp       L2395
L2390:
    call      mc_stackmcl.poppcl
L2387:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc px_idiv
mc_genmcl.px_idiv:
;>>
    %define mc_genmcl.px_idiv.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    mov       rcx,	[rbp + mc_genmcl.px_idiv.p]
    mov       rdx,	r11
    mov       r8,	1
    call      mc_auxmcl.do_divrem
L2398:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_irem
mc_genmcl.px_irem:
;>>
    %define mc_genmcl.px_irem.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    mov       rcx,	[rbp + mc_genmcl.px_irem.p]
    mov       rdx,	r11
    xor       r8d,	r8d
    call      mc_auxmcl.do_divrem
L2399:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_idivrem
mc_genmcl.px_idivrem:
;>>
    %define mc_genmcl.px_idivrem.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    mov       rcx,	[rbp + mc_genmcl.px_idivrem.p]
    mov       rdx,	r11
    mov       r8,	2
    call      mc_auxmcl.do_divrem
L2400:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_clear
mc_genmcl.px_clear:
;>>
    %define mc_genmcl.px_clear.p 16
    %define mc_genmcl.px_clear.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       [rbp + mc_genmcl.px_clear.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_clear.p]
    mov       r10d,	[rax+4]
    mov       rcx,	[rbp + mc_genmcl.px_clear.ax]
    mov       rdx,	r10
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
L2401:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_subp
mc_genmcl.px_subp:
;>>
    %define mc_genmcl.px_subp.p 16
    %define mc_genmcl.px_subp.ax -8
    %define mc_genmcl.px_subp.bx -16
    %define mc_genmcl.px_subp.n -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_subp.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_subp.bx],	rax
    mov       rcx,	30
    mov       rdx,	[rbp + mc_genmcl.px_subp.ax]
    mov       r8,	[rbp + mc_genmcl.px_subp.bx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_subp.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jle       L2404
    mov       rax,	[rbp + mc_genmcl.px_subp.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    call      mc_libmcl.ispoweroftwo
    mov       [rbp + mc_genmcl.px_subp.n],	rax
    mov       rax,	[rbp + mc_genmcl.px_subp.n]
    test      rax,	rax
    jz        L2406
    mov       rcx,	[rbp + mc_genmcl.px_subp.n]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	46
    mov       rdx,	[rbp + mc_genmcl.px_subp.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2405
L2406:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_genmcl.px_subp.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5743]
    lea       rdx,	[rel L5744]
    call      mc_libmcl.merror
L2405:
L2404:
L2403:
    call      mc_stackmcl.poppcl
L2402:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_switch
mc_genmcl.px_switch:
;>>
    %define mc_genmcl.px_switch.p 16
    %define mc_genmcl.px_switch.minlab -8
    %define mc_genmcl.px_switch.maxlab -16
    %define mc_genmcl.px_switch.jumplab -24
    %define mc_genmcl.px_switch.elselab -32
    %define mc_genmcl.px_switch.reg -40
    %define mc_genmcl.px_switch.ax -48
    %define mc_genmcl.px_switch.bx -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + mc_genmcl.px_switch.minlab],	r10
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    r10,	dword [rax+20]
    mov       [rbp + mc_genmcl.px_switch.maxlab],	r10
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_switch.jumplab],	r10
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    lea       rax,	[rax+32]
    mov       [mc_decls.currpcl],	rax
    mov       rax,	[mc_decls.currpcl]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_switch.elselab],	r10
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_switch.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.minlab]
    cmp       rax,	0
    jz        L2409
    mov       rcx,	[rbp + mc_genmcl.px_switch.minlab]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	30
    mov       rdx,	[rbp + mc_genmcl.px_switch.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2409:
L2408:
    mov       rax,	[rbp + mc_genmcl.px_switch.maxlab]
    sub       rax,	[rbp + mc_genmcl.px_switch.minlab]
    add       rax,	1
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_switch.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_switch.elselab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	27
    mov       rdx,	3
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    movzx     rax,	byte [mc_decls.phighmem]
    test      rax,	rax
    jz        L2411
    call      mc_stackmcl.getworkireg
    mov       [rbp + mc_genmcl.px_switch.reg],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_genmcl.px_switch.reg]
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_genmcl.px_switch.bx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_switch.jumplab]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_genmcl.px_switch.bx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_genmcl.px_switch.ax]
    movzx     r10,	byte [rax+10]
    mov       rcx,	[rbp + mc_genmcl.px_switch.reg]
    mov       rdx,	r10
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2410
L2411:
    sub       rsp,	8
    push      0
    push      qword [rbp + mc_genmcl.px_switch.jumplab]
    push      0
    mov       rax,	[rbp + mc_genmcl.px_switch.ax]
    movzx     r10,	byte [rax+10]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2410:
    call      mc_stackmcl.poppcl
    mov       rcx,	73
    mov       rdx,	1
    call      mc_libmcl.setsegment
L2407:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc px_switchu
mc_genmcl.px_switchu:
;>>
    %define mc_genmcl.px_switchu.p 16
    %define mc_genmcl.px_switchu.minlab -8
    %define mc_genmcl.px_switchu.maxlab -16
    %define mc_genmcl.px_switchu.jumplab -24
    %define mc_genmcl.px_switchu.elselab -32
    %define mc_genmcl.px_switchu.reg -40
    %define mc_genmcl.px_switchu.ax -48
    %define mc_genmcl.px_switchu.bx -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    r10,	dword [rax+16]
    mov       [rbp + mc_genmcl.px_switchu.minlab],	r10
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    r10,	dword [rax+20]
    mov       [rbp + mc_genmcl.px_switchu.maxlab],	r10
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_switchu.jumplab],	r10
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    lea       rax,	[rax+32]
    mov       [mc_decls.currpcl],	rax
    mov       rax,	[mc_decls.currpcl]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_switchu.elselab],	r10
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_switchu.ax],	rax
    movzx     rax,	byte [mc_decls.phighmem]
    test      rax,	rax
    jz        L2414
    call      mc_stackmcl.getworkireg
    mov       [rbp + mc_genmcl.px_switchu.reg],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_genmcl.px_switchu.reg]
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_genmcl.px_switchu.bx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_switchu.jumplab]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_genmcl.px_switchu.bx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_genmcl.px_switchu.minlab]
    neg       rax
    imul      rax,	8
    mov       r10,	[rbp + mc_genmcl.px_switchu.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	[rbp + mc_genmcl.px_switchu.reg]
    mov       rdx,	r11
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2413
L2414:
    sub       rsp,	8
    push      0
    push      qword [rbp + mc_genmcl.px_switchu.jumplab]
    push      0
    mov       rax,	[rbp + mc_genmcl.px_switchu.minlab]
    neg       rax
    imul      rax,	8
    mov       r10,	[rbp + mc_genmcl.px_switchu.ax]
    movzx     r11,	byte [r10+10]
    xor       ecx,	ecx
    mov       rdx,	r11
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2413:
    call      mc_stackmcl.poppcl
L2412:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc px_swlabel
mc_genmcl.px_swlabel:
;>>
    %define mc_genmcl.px_swlabel.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_swlabel.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.mgenlabel
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2415:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_endsw
mc_genmcl.px_endsw:
;>>
    %define mc_genmcl.px_endsw.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
L2416:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_fwiden
mc_genmcl.px_fwiden:
;>>
    %define mc_genmcl.px_fwiden.p 16
    %define mc_genmcl.px_fwiden.fx -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_fwiden.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_fwiden.fx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_fwiden.fx]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	89
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_fwiden.fx]
    call      mc_libmcl.genmc
    mov       al,	2
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L2417:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_fnarrow
mc_genmcl.px_fnarrow:
;>>
    %define mc_genmcl.px_fnarrow.p 16
    %define mc_genmcl.px_fnarrow.fx -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_fnarrow.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_fnarrow.fx],	rax
    mov       rcx,	[rbp + mc_genmcl.px_fnarrow.fx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_fnarrow.fx]
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L2418:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_truncate
mc_genmcl.px_truncate:
;>>
    %define mc_genmcl.px_truncate.p 16
    %define mc_genmcl.px_truncate.ax -8
    %define mc_genmcl.px_truncate.pmode2 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_truncate.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       [rbp + mc_genmcl.px_truncate.pmode2],	r10b
    movzx     rax,	byte [rbp + mc_genmcl.px_truncate.pmode2]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_truncate.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_truncate.p]
    mov       r10d,	[rax+4]
    movzx     rax,	byte [rbp + mc_genmcl.px_truncate.pmode2]
    lea       r11,	[pc_tables.psize]
    movzx     rdi,	byte [r11 + rax]
    cmp       r10,	rdi
    jz        L2421
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r11,	byte [r10 + rax]
    mov       rcx,	[rbp + mc_genmcl.px_truncate.ax]
    mov       rdx,	r11
    call      mc_libmcl.changeopndsize
    movzx     r10,	byte [rbp + mc_genmcl.px_truncate.pmode2]
    lea       r11,	[mc_decls.ploadop]
    movzx     rdi,	byte [r11 + r10]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_truncate.ax]
    call      mc_libmcl.genmc
L2421:
L2420:
L2419:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_typepun
mc_genmcl.px_typepun:
;>>
    %define mc_genmcl.px_typepun.p 16
    %define mc_genmcl.px_typepun.ax -8
    %define mc_genmcl.px_typepun.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_typepun.p]
    movsxd    r10,	dword [rax+28]
    and       r10,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_typepun.bx],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_typepun.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_typepun.ax]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	[rbp + mc_genmcl.px_typepun.bx]
    mov       rdx,	r10
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_typepun.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_genmcl.px_typepun.ax]
    movzx     r11,	byte [r10+10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2422:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_unload
mc_genmcl.px_unload:
;>>
    %define mc_genmcl.px_unload.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mc_stackmcl.poppcl
L2423:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_loadbit
mc_genmcl.px_loadbit:
;>>
    %define mc_genmcl.px_loadbit.p 16
    %define mc_genmcl.px_loadbit.ax -8
    %define mc_genmcl.px_loadbit.z -16
    %define mc_genmcl.px_loadbit.i -24
    %define mc_genmcl.px_loadbit.m -32
    %define mc_genmcl.px_loadbit.$T1 -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_loadbit.z],	rax
    test      rax,	rax
    jz        L2426
    mov       rax,	[rbp + mc_genmcl.px_loadbit.z]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genmcl.px_loadbit.i],	r10
    mov       rax,	[rbp + mc_genmcl.px_loadbit.i]
    cmp       rax,	0
    jl        L2428
    cmp       rax,	31
    jg        L2428
    mov       rax,	5
    jmp       L2427
L2428:
    mov       rax,	6
L2427:
    mov       [rbp + mc_genmcl.px_loadbit.m],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_loadbit.m]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_loadbit.ax],	rax
    mov       rax,	[rbp + mc_genmcl.px_loadbit.i]
    test      rax,	rax
    jz        L2430
    mov       rcx,	[rbp + mc_genmcl.px_loadbit.i]
    mov       rdx,	[rbp + mc_genmcl.px_loadbit.m]
    call      mc_libmcl.mgenint
    mov       rcx,	46
    mov       rdx,	[rbp + mc_genmcl.px_loadbit.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_loadbit.i]
    cmp       rax,	63
    jnz       L2432
    jmp       L2433
L2432:
L2431:
L2430:
L2429:
    jmp       L2425
L2426:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_loadbit.ax],	rax
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L2435
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2435:
L2434:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rcx,	46
    mov       rdx,	[rbp + mc_genmcl.px_loadbit.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [pc_decls.r10used]
    test      rax,	rax
    jz        L2437
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2437:
L2436:
L2425:
    mov       rcx,	1
    mov       rdx,	5
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_loadbit.$T1],	rax
    mov       rcx,	[rbp + mc_genmcl.px_loadbit.ax]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	39
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
;skip:
L2433:
    call      mc_stackmcl.poppcl
L2424:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc px_assem
mc_genmcl.px_assem:
;>>
    %define mc_genmcl.px_assem.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.idomcl_assem]
    test      rax,	rax
    jz        L2440
    mov       rax,	[rbp + mc_genmcl.px_assem.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rax,	[mc_decls.idomcl_assem]
    call      rax
    jmp       L2439
L2440:
    lea       rcx,	[rel L5745]
    lea       rdx,	[rel L5746]
    call      mc_libmcl.merror
L2439:
L2438:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_sin
mc_genmcl.px_sin:
;>>
    %define mc_genmcl.px_sin.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_sin.p]
    lea       rdx,	[rel L5747]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2441:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_cos
mc_genmcl.px_cos:
;>>
    %define mc_genmcl.px_cos.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_cos.p]
    lea       rdx,	[rel L5748]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2442:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_tan
mc_genmcl.px_tan:
;>>
    %define mc_genmcl.px_tan.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_tan.p]
    lea       rdx,	[rel L5749]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2443:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_asin
mc_genmcl.px_asin:
;>>
    %define mc_genmcl.px_asin.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_asin.p]
    lea       rdx,	[rel L5750]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2444:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_acos
mc_genmcl.px_acos:
;>>
    %define mc_genmcl.px_acos.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_acos.p]
    lea       rdx,	[rel L5751]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2445:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_atan
mc_genmcl.px_atan:
;>>
    %define mc_genmcl.px_atan.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_atan.p]
    lea       rdx,	[rel L5752]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2446:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_log
mc_genmcl.px_log:
;>>
    %define mc_genmcl.px_log.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_log.p]
    lea       rdx,	[rel L5753]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2447:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_log10
mc_genmcl.px_log10:
;>>
    %define mc_genmcl.px_log10.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_log10.p]
    lea       rdx,	[rel L5754]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2448:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_exp
mc_genmcl.px_exp:
;>>
    %define mc_genmcl.px_exp.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_exp.p]
    lea       rdx,	[rel L5755]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2449:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_round
mc_genmcl.px_round:
;>>
    %define mc_genmcl.px_round.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_round.p]
    lea       rdx,	[rel L5756]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2450:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_floor
mc_genmcl.px_floor:
;>>
    %define mc_genmcl.px_floor.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_floor.p]
    lea       rdx,	[rel L5757]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2451:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_ceil
mc_genmcl.px_ceil:
;>>
    %define mc_genmcl.px_ceil.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_ceil.p]
    lea       rdx,	[rel L5758]
    mov       r8,	1
    call      mc_auxmcl.do_maths
L2452:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_atan2
mc_genmcl.px_atan2:
;>>
    %define mc_genmcl.px_atan2.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	[rbp + mc_genmcl.px_atan2.p]
    lea       rdx,	[rel L5759]
    mov       r8,	2
    call      mc_auxmcl.do_maths
L2453:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_fmod
mc_genmcl.px_fmod:
;>>
    %define mc_genmcl.px_fmod.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	[rbp + mc_genmcl.px_fmod.p]
    lea       rdx,	[rel L5760]
    mov       r8,	2
    call      mc_auxmcl.do_maths
L2454:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_setcc
mc_genmcl.px_setcc:
;>>
    %define mc_genmcl.px_setcc.p 16
    %define mc_genmcl.px_setcc.cond -8
    %define mc_genmcl.px_setcc.ax -16
    %define mc_genmcl.px_setcc.bx -24
    %define mc_genmcl.px_setcc.cx -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_setcc.ax],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_setcc.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_setcc.p]
    movzx     r10,	byte [rax+2]
    lea       rax,	[mc_genmcl.ucondcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_genmcl.px_setcc.cond],	r11
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2457
    lea       rcx,	[rel L5761]
    lea       rdx,	[rel L5762]
    call      mc_libmcl.merror
    jmp       L2456
L2457:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2458
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2460
    mov       rax,	[rbp + mc_genmcl.px_setcc.p]
    movzx     r10,	byte [rax+2]
    lea       rax,	[mc_genmcl.scondcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_genmcl.px_setcc.cond],	r11
L2460:
L2459:
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_setcc.ax]
    mov       r8,	[rbp + mc_genmcl.px_setcc.bx]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_setcc.ax]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_genmcl.px_setcc.cx],	rax
    jmp       L2456
L2458:
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	74
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genmcl.px_setcc.ax]
    mov       r8,	[rbp + mc_genmcl.px_setcc.bx]
    call      mc_libmcl.genmc
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_setcc.cx],	rax
    mov       rax,	[rbp + mc_genmcl.px_setcc.cx]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L2456:
    mov       rcx,	59
    mov       rdx,	[rbp + mc_genmcl.px_setcc.cond]
    mov       r8,	[rbp + mc_genmcl.px_setcc.cx]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	[rbp + mc_genmcl.px_setcc.cx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	20
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_setcc.cx]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2455:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_min
mc_genmcl.px_min:
;>>
    %define mc_genmcl.px_min.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2463
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2465
    mov       rax,	15
    jmp       L2464
L2465:
    mov       rax,	7
L2464:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2462
L2463:
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	112
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2462:
L2461:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_max
mc_genmcl.px_max:
;>>
    %define mc_genmcl.px_max.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2468
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2470
    mov       rax,	12
    jmp       L2469
L2470:
    mov       rax,	2
L2469:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2467
L2468:
    movzx     rax,	byte [mc_decls.pmode]
    sub       rax,	1
    mov       r10,	113
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2467:
L2466:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_power
mc_genmcl.px_power:
;>>
    %define mc_genmcl.px_power.p 16
    %define mc_genmcl.px_power.ax -8
    %define mc_genmcl.px_power.bx -16
    %define mc_genmcl.px_power.d -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2473
    mov       rcx,	81
    call      mc_auxmcl.gethostfn
    mov       [rbp + mc_genmcl.px_power.d],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	[rbp + mc_genmcl.px_power.p]
    mov       rdx,	[rbp + mc_genmcl.px_power.d]
    mov       r8,	2
    call      mc_auxmcl.do_host
    jmp       L2472
L2473:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	[rbp + mc_genmcl.px_power.p]
    lea       rdx,	[rel L5763]
    mov       r8,	2
    call      mc_auxmcl.do_maths
L2472:
L2471:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_minto
mc_genmcl.px_minto:
;>>
    %define mc_genmcl.px_minto.p 16
    %define mc_genmcl.px_minto.$T1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2476
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_minto.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2478
    mov       rax,	14
    jmp       L2477
L2478:
    mov       rax,	6
L2477:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2475
L2476:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	6
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2475:
L2474:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_maxto
mc_genmcl.px_maxto:
;>>
    %define mc_genmcl.px_maxto.p 16
    %define mc_genmcl.px_maxto.$T1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2481
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_maxto.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r11,	byte [r10 + rax]
    test      r11,	r11
    jz        L2483
    mov       rax,	13
    jmp       L2482
L2483:
    mov       rax,	3
L2482:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2480
L2481:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	3
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2480:
L2479:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_negto
mc_genmcl.px_negto:
;>>
    %define mc_genmcl.px_negto.p 16
    %define mc_genmcl.px_negto.px -8
    %define mc_genmcl.px_negto.fx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_negto.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2486
    mov       rcx,	51
    mov       rdx,	[rbp + mc_genmcl.px_negto.px]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2485
L2486:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_negto.fx],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_negto.fx]
    mov       r8,	[rbp + mc_genmcl.px_negto.px]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_genmcl.px_negto.fx]
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_negto.px]
    mov       r8,	[rbp + mc_genmcl.px_negto.fx]
    call      mc_libmcl.genmc
L2485:
    call      mc_stackmcl.poppcl
L2484:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_absto
mc_genmcl.px_absto:
;>>
    %define mc_genmcl.px_absto.p 16
    %define mc_genmcl.px_absto.px -8
    %define mc_genmcl.px_absto.ax -16
    %define mc_genmcl.px_absto.lx -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_absto.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_absto.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_absto.ax]
    mov       r8,	[rbp + mc_genmcl.px_absto.px]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2489
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_absto.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_absto.lx],	r10
    mov       rcx,	27
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	51
    mov       rdx,	[rbp + mc_genmcl.px_absto.ax]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_genmcl.px_absto.lx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2488
L2489:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_genmcl.px_absto.ax]
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L2488:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_absto.px]
    mov       r8,	[rbp + mc_genmcl.px_absto.ax]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2487:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_addpxto
mc_genmcl.px_addpxto:
;>>
    %define mc_genmcl.px_addpxto.p 16
    %define mc_genmcl.px_addpxto.ax -8
    %define mc_genmcl.px_addpxto.bx -16
    %define mc_genmcl.px_addpxto.z -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_addpxto.ax],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_addpxto.z],	rax
    test      rax,	rax
    jz        L2492
    mov       rax,	[rbp + mc_genmcl.px_addpxto.z]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_addpxto.p]
    movsxd    r11,	dword [rax+16]
    imul      r10,	r11
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[rbp + mc_genmcl.px_addpxto.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2491
L2492:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_addpxto.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_addpxto.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	[rbp + mc_genmcl.px_addpxto.bx]
    mov       rdx,	r10
    call      mc_auxmcl.mulimm
    mov       rcx,	29
    mov       rdx,	[rbp + mc_genmcl.px_addpxto.ax]
    mov       r8,	[rbp + mc_genmcl.px_addpxto.bx]
    call      mc_libmcl.genmc
L2491:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2490:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_subpxto
mc_genmcl.px_subpxto:
;>>
    %define mc_genmcl.px_subpxto.p 16
    %define mc_genmcl.px_subpxto.ax -8
    %define mc_genmcl.px_subpxto.bx -16
    %define mc_genmcl.px_subpxto.z -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_subpxto.ax],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_subpxto.z],	rax
    test      rax,	rax
    jz        L2495
    mov       rax,	[rbp + mc_genmcl.px_subpxto.z]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_subpxto.p]
    movsxd    r11,	dword [rax+16]
    imul      r10,	r11
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	30
    mov       rdx,	[rbp + mc_genmcl.px_subpxto.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2494
L2495:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_subpxto.bx],	rax
    mov       rax,	[rbp + mc_genmcl.px_subpxto.p]
    movsxd    r10,	dword [rax+16]
    mov       rcx,	[rbp + mc_genmcl.px_subpxto.bx]
    mov       rdx,	r10
    call      mc_auxmcl.mulimm
    mov       rcx,	30
    mov       rdx,	[rbp + mc_genmcl.px_subpxto.ax]
    mov       r8,	[rbp + mc_genmcl.px_subpxto.bx]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_subpxto.p]
    movsxd    r10,	dword [rax+20]
    test      r10,	r10
    jz        L2497
    lea       rcx,	[rel L5764]
    lea       rdx,	[rel L5765]
    call      mc_libmcl.merror
L2497:
L2496:
L2494:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2493:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_divto
mc_genmcl.px_divto:
;>>
    %define mc_genmcl.px_divto.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_divto.p]
    mov       rdx,	72
    call      mc_auxmcl.do_binto_float
L2498:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_bitnotto
mc_genmcl.px_bitnotto:
;>>
    %define mc_genmcl.px_bitnotto.p 16
    %define mc_genmcl.px_bitnotto.px -8
    %define mc_genmcl.px_bitnotto.fx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_bitnotto.px],	rax
    mov       rcx,	52
    mov       rdx,	[rbp + mc_genmcl.px_bitnotto.px]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2499:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_notto
mc_genmcl.px_notto:
;>>
    %define mc_genmcl.px_notto.p 16
    %define mc_genmcl.px_notto.px -8
    %define mc_genmcl.px_notto.$T1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_notto.px],	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_notto.$T1],	rax
    mov       rcx,	[rbp + mc_genmcl.px_notto.px]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	41
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
L2500:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_toboolto
mc_genmcl.px_toboolto:
;>>
    %define mc_genmcl.px_toboolto.p 16
    %define mc_genmcl.px_toboolto.ax -8
    %define mc_genmcl.px_toboolto.bx -16
    %define mc_genmcl.px_toboolto.px -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_toboolto.px],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_toboolto.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_toboolto.ax]
    mov       r8,	[rbp + mc_genmcl.px_toboolto.px]
    call      mc_libmcl.genmc
    mov       rcx,	42
    mov       rdx,	[rbp + mc_genmcl.px_toboolto.ax]
    mov       r8,	[rbp + mc_genmcl.px_toboolto.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_toboolto.ax]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_toboolto.bx],	r10
    mov       rcx,	59
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	[rbp + mc_genmcl.px_toboolto.ax]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	20
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolto.bx]
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_toboolto.px]
    mov       r8,	[rbp + mc_genmcl.px_toboolto.ax]
    call      mc_libmcl.genmc
L2501:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_sign
mc_genmcl.px_sign:
;>>
    %define mc_genmcl.px_sign.p 16
    %define mc_genmcl.px_sign.ax -8
    %define mc_genmcl.px_sign.bx -16
    %define mc_genmcl.px_sign.lx1 -24
    %define mc_genmcl.px_sign.lx2 -32
    %define mc_genmcl.px_sign.lx3 -40
    %define mc_genmcl.px_sign.gtop -48
    %define mc_genmcl.px_sign.ltop -56
    %define mc_genmcl.px_sign.$T1 -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_sign.ax],	rax
    mov       rcx,	10
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_genmcl.px_sign.bx],	rax
    mov       rcx,	41
    mov       rdx,	[rbp + mc_genmcl.px_sign.bx]
    mov       r8,	[rbp + mc_genmcl.px_sign.bx]
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2504
    mov       al,	7
    mov       [rbp + mc_genmcl.px_sign.gtop],	al
    mov       al,	2
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte [mc_decls.pmode]
    movq      XMM0,	[rel L5766]
    mov       rdx,	rax
    call      mc_libmcl.mgenrealmem
    movzx     r10,	byte [mc_decls.pmode]
    sub       r10,	1
    mov       r11,	74
    add       r11,	r10
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_genmcl.px_sign.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2503
L2504:
    mov       al,	15
    mov       [rbp + mc_genmcl.px_sign.gtop],	al
    mov       al,	12
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte [mc_decls.pmode]
    xor       ecx,	ecx
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	[rbp + mc_genmcl.px_sign.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2503:
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_sign.lx1],	r10
    movzx     r10,	byte [rbp + mc_genmcl.px_sign.gtop]
    mov       rcx,	27
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_sign.lx2],	r10
    movzx     r10,	byte [rbp + mc_genmcl.px_sign.ltop]
    mov       rcx,	27
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_sign.lx3],	r10
    mov       rcx,	26
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_genmcl.px_sign.lx1]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_sign.$T1],	rax
    mov       rcx,	[rbp + mc_genmcl.px_sign.bx]
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	26
    mov       rdx,	[rbp + mc_genmcl.px_sign.lx3]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_genmcl.px_sign.lx2]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	54
    mov       rdx,	[rbp + mc_genmcl.px_sign.bx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	[rbp + mc_genmcl.px_sign.lx3]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_sign.bx]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
L2502:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc px_loadbf
mc_genmcl.px_loadbf:
;>>
    %define mc_genmcl.px_loadbf.p 16
    %define mc_genmcl.px_loadbf.y -8
    %define mc_genmcl.px_loadbf.z -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_loadbf.y],	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_genmcl.px_loadbf.z],	rax
    mov       rax,	[rbp + mc_genmcl.px_loadbf.y]
    test      rax,	rax
    jz        L2507
    mov       rax,	[rbp + mc_genmcl.px_loadbf.z]
    test      rax,	rax
    jz        L2507
    mov       rax,	[rbp + mc_genmcl.px_loadbf.z]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_loadbf.y]
    mov       r11,	[rax+8]
    mov       rcx,	[rbp + mc_genmcl.px_loadbf.p]
    mov       rdx,	r11
    mov       r8,	r10
    call      mc_auxmcl.do_loadbf_const
    jmp       L2506
L2507:
    mov       rcx,	[rbp + mc_genmcl.px_loadbf.p]
    call      mc_auxmcl.do_loadbf_var
L2506:
L2505:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_storebit
mc_genmcl.px_storebit:
;>>
    %define mc_genmcl.px_storebit.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_storebit.p]
    call      mc_auxmcl.do_storebit
L2508:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_storebf
mc_genmcl.px_storebf:
;>>
    %define mc_genmcl.px_storebf.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genmcl.px_storebf.p]
    call      mc_auxmcl.do_storebf
L2509:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_slicelen
mc_genmcl.px_slicelen:
;>>
    %define mc_genmcl.px_slicelen.p 16
    %define mc_genmcl.px_slicelen.ax -8
    %define mc_genmcl.px_slicelen.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_slicelen.bx],	rax
    mov       rcx,	10
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_slicelen.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_slicelen.bx]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_slicelen.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_genmcl.px_slicelen.p]
    movzx     r10,	byte [rax]
    cmp       r10,	137
    jnz       L2512
    mov       rax,	[rbp + mc_genmcl.px_slicelen.p]
    movsxd    r10,	dword [rax+16]
    cmp       r10,	1
    jz        L2512
    mov       rax,	[rbp + mc_genmcl.px_slicelen.p]
    movsxd    r10,	dword [rax+16]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[rbp + mc_genmcl.px_slicelen.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2512:
L2511:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
L2510:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_sliceptr
mc_genmcl.px_sliceptr:
;>>
    %define mc_genmcl.px_sliceptr.p 16
    %define mc_genmcl.px_sliceptr.ax -8
    %define mc_genmcl.px_sliceptr.bx -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_sliceptr.bx],	rax
    mov       rcx,	10
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_sliceptr.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_sliceptr.ax]
    mov       r8,	[rbp + mc_genmcl.px_sliceptr.bx]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
L2513:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc px_loadall
mc_genmcl.px_loadall:
;>>
    %define mc_genmcl.px_loadall.p 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mc_stackmcl.checkallloaded
L2514:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc px_setjmp
mc_genmcl.px_setjmp:
;>>
    %define mc_genmcl.px_setjmp.p 16
    %define mc_genmcl.px_setjmp.ax -8
    %define mc_genmcl.px_setjmp.bx -16
    %define mc_genmcl.px_setjmp.lab -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    call      mc_libmcl.mcreatefwdlabel
    mov       [rbp + mc_genmcl.px_setjmp.lab],	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_setjmp.bx],	rax
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_setjmp.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_setjmp.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_setjmp.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_setjmp.bx]
    mov       r8,	[rbp + mc_genmcl.px_setjmp.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_setjmp.bx]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_setjmp.bx]
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	41
    mov       rdx,	[rbp + mc_genmcl.px_setjmp.ax]
    mov       r8,	[rbp + mc_genmcl.px_setjmp.ax]
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_setjmp.p]
    call      mc_stackmcl.freeworkregs
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    mov       rcx,	[rbp + mc_genmcl.px_setjmp.lab]
    call      mc_libmcl.mdefinefwdlabel
L2515:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc px_longjmp
mc_genmcl.px_longjmp:
;>>
    %define mc_genmcl.px_longjmp.p 16
    %define mc_genmcl.px_longjmp.ax -8
    %define mc_genmcl.px_longjmp.bx -16
    %define mc_genmcl.px_longjmp.cx -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_genmcl.px_longjmp.bx],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       [rbp + mc_genmcl.px_longjmp.ax],	rax
    mov       rcx,	[rbp + mc_genmcl.px_longjmp.ax]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	[rbp + mc_genmcl.px_longjmp.ax]
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	12
    mov       rdx,	[mc_decls.dframeopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_genmcl.px_longjmp.cx],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_genmcl.px_longjmp.cx]
    mov       r8,	[rbp + mc_genmcl.px_longjmp.ax]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       rcx,	26
    mov       rdx,	[rbp + mc_genmcl.px_longjmp.cx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
L2516:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc genss
mc_genss.genss:
;>>
    %define mc_genss.genss.obj 16
    %define mc_genss.genss.index -8
    %define mc_genss.genss.m -16
    %define mc_genss.genss.pr -24
    %define mc_genss.genss.codeaddr -32
    %define mc_genss.genss.offsetptr -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    movzx     rax,	byte [pc_decls.ssdone]
    test      rax,	rax
    jz        L2519
    jmp       L2517
L2519:
L2518:
    mov       rcx,	[mc_decls.mlabelno]
    call      mc_genss.initlib
    xor       eax,	eax
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_zdata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_idata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_code],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_idatarelocs],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_coderelocs],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_nsymbols],	rax
    mov       rcx,	1
    call      mc_genss.switchseg
    mov       rax,	9999
    mov       [mc_decls.aaseqno],	rax
    xor       eax,	eax
    mov       [mc_genss.extraparam],	rax
    mov       rax,	[mc_decls.mccode]
    mov       [rbp + mc_genss.genss.m],	rax
    xor       eax,	eax
    mov       [rbp + mc_genss.genss.index],	rax
    jmp       L2521
L2520:
    inc       qword [rbp + mc_genss.genss.index]
    mov       rax,	[rbp + mc_genss.genss.index]
    mov       rcx,	[rbp + mc_genss.genss.m]
    mov       rdx,	rax
    call      mc_genss.doinstr
    mov       rax,	[rbp + mc_genss.genss.m]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.genss.m],	r10
L2521:
    mov       rax,	[rbp + mc_genss.genss.m]
    test      rax,	rax
    jnz       L2520
L2522:
    xor       ecx,	ecx
    call      mc_genss.switchseg
    mov       rcx,	[mc_decls.ss_zdata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jz        L2524
    lea       rcx,	[rel L5767]
    call      mc_libmcl.axerror
L2524:
L2523:
    mov       rax,	[rbp + mc_genss.genss.obj]
    test      rax,	rax
    jz        L2526
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_genss.genss.codeaddr],	rax
    mov       rax,	[mc_decls.riplist]
    mov       [rbp + mc_genss.genss.pr],	rax
    jmp       L2530
L2527:
    mov       rax,	[rbp + mc_genss.genss.pr]
    mov       r10d,	[rax+8]
    mov       rax,	[rbp + mc_genss.genss.codeaddr]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_genss.genss.offsetptr],	rax
    mov       rax,	[rbp + mc_genss.genss.pr]
    movsxd    r10,	dword [rax+12]
    mov       rax,	[rbp + mc_genss.genss.offsetptr]
    sub       [rax],	r10d
L2528:
    mov       rax,	[rbp + mc_genss.genss.pr]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.genss.pr],	r10
L2530:
    mov       rax,	[rbp + mc_genss.genss.pr]
    test      rax,	rax
    jnz       L2527
L2529:
L2526:
L2525:
    mov       al,	1
    mov       [pc_decls.ssdone],	al
L2517:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc doinstr
mc_genss.doinstr:
;>>
    %define mc_genss.doinstr.m 16
    %define mc_genss.doinstr.index 24
    %define mc_genss.doinstr.a -8
    %define mc_genss.doinstr.b -16
    %define mc_genss.doinstr.d -24
    %define mc_genss.doinstr.e -32
    %define mc_genss.doinstr.x -40
    %define mc_genss.doinstr.offset -48
    %define mc_genss.doinstr.shortjmp -56
    %define mc_genss.doinstr.n -64
    %define mc_genss.doinstr.av_1 -72
    %define mc_genss.doinstr.av_2 -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	1024
    call      mc_genss.buffercheck
    xor       eax,	eax
    mov       [mc_genss.usesizeb],	al
    mov       [mc_genss.nowmask],	al
    mov       [mc_genss.f3override],	al
    mov       [mc_genss.f2override],	al
    mov       [mc_genss.addroverride],	al
    mov       [mc_genss.sizeoverride],	al
    mov       [mc_genss.rex],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       r10,	[rax+8]
    mov       [rbp + mc_genss.doinstr.a],	r10
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       r10,	[rax+16]
    mov       [rbp + mc_genss.doinstr.b],	r10
    inc       qword [mc_genss.instrno]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       r10,	[rax+27]
    mov       [mc_decls.aaseqno],	r10
    xor       eax,	eax
    mov       [mc_genss.ripentry],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       [mc_genss.currmcl],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    sub       r10,	1
    cmp       r10,	150
    jae       L2534
    lea       rax,	[rel L2533]
    jmp       [rax + r10*8]
    segment .data
L2533:
    dq  L2535
    dq  L2536
    dq  L2656
    dq  L2657
    dq  L2539
    dq  L2540
    dq  L2537
    dq  L2538
    dq  L2547
    dq  L2564
    dq  L2637
    dq  L2578
    dq  L2573
    dq  L2574
    dq  L2579
    dq  L2638
    dq  L2621
    dq  L2622
    dq  L2580
    dq  L2581
    dq  L2582
    dq  L2548
    dq  L2569
    dq  L2534
    dq  L2570
    dq  L2549
    dq  L2550
    dq  L2583
    dq  L2577
    dq  L2577
    dq  L2577
    dq  L2577
    dq  L2576
    dq  L2576
    dq  L2584
    dq  L2534
    dq  L2576
    dq  L2576
    dq  L2577
    dq  L2577
    dq  L2577
    dq  L2615
    dq  L2577
    dq  L2614
    dq  L2614
    dq  L2614
    dq  L2614
    dq  L2614
    dq  L2614
    dq  L2614
    dq  L2576
    dq  L2576
    dq  L2575
    dq  L2575
    dq  L2565
    dq  L2566
    dq  L2567
    dq  L2568
    dq  L2620
    dq  L2652
    dq  L2652
    dq  L2655
    dq  L2655
    dq  L2623
    dq  L2624
    dq  L2623
    dq  L2624
    dq  L2623
    dq  L2624
    dq  L2623
    dq  L2624
    dq  L2623
    dq  L2624
    dq  L2627
    dq  L2628
    dq  L2625
    dq  L2626
    dq  L2625
    dq  L2626
    dq  L2626
    dq  L2626
    dq  L2631
    dq  L2632
    dq  L2633
    dq  L2634
    dq  L2635
    dq  L2636
    dq  L2630
    dq  L2629
    dq  L2648
    dq  L2648
    dq  L2534
    dq  L2534
    dq  L2640
    dq  L2640
    dq  L2640
    dq  L2641
    dq  L2641
    dq  L2641
    dq  L2642
    dq  L2642
    dq  L2642
    dq  L2642
    dq  L2639
    dq  L2639
    dq  L2639
    dq  L2639
    dq  L2639
    dq  L2639
    dq  L2639
    dq  L2639
    dq  L2623
    dq  L2623
    dq  L2624
    dq  L2624
    dq  L2557
    dq  L2558
    dq  L2559
    dq  L2560
    dq  L2562
    dq  L2563
    dq  L2561
    dq  L2598
    dq  L2585
    dq  L2585
    dq  L2585
    dq  L2585
    dq  L2619
    dq  L2616
    dq  L2616
    dq  L2616
    dq  L2617
    dq  L2618
    dq  L2643
    dq  L2644
    dq  L2645
    dq  L2646
    dq  L2647
    dq  L2651
    dq  L2654
    dq  L2649
    dq  L2650
    dq  L2650
    dq  L2650
    dq  L2650
    dq  L2650
    dq  L2650
    dq  L2650
    dq  L2653
    dq  L2564
    segment .text
L2535:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    mov       [mc_decls.currasmproc],	rax
    jmp       L2532
L2536:
    jmp       L2532
L2537:
    jmp       L2532
L2538:
    jmp       L2532
L2539:
    jmp       L2532
L2540:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	4
    jz        L2542
    cmp       r10,	5
    jz        L2543
    jmp       L2544
L2542:
    jmp       L2541
L2543:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.doinstr.d],	r10
    mov       al,	2
    mov       r10,	[rbp + mc_genss.doinstr.d]
    mov       [r10+69],	al
    mov       al,	[mc_genss.currseg]
    mov       r10,	[rbp + mc_genss.doinstr.d]
    mov       [r10+70],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       r10,	[rbp + mc_genss.doinstr.d]
    mov       [r10+52],	eax
    mov       rax,	[rbp + mc_genss.doinstr.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L2546
    mov       rcx,	[rbp + mc_genss.doinstr.d]
    call      mc_genss.getstindex
L2546:
L2545:
    mov       rcx,	[rbp + mc_genss.doinstr.d]
    call      mc_genss.dofwdrefs
L2544:
L2541:
    jmp       L2532
L2547:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    mov       r10,	[rax]
    mov       rax,	[mc_decls.labeldeftable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_genss.doinstr.d],	r11
    mov       al,	2
    mov       r10,	[rbp + mc_genss.doinstr.d]
    mov       [r10+69],	al
    mov       al,	[mc_genss.currseg]
    mov       r10,	[rbp + mc_genss.doinstr.d]
    mov       [r10+70],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       r10,	[rbp + mc_genss.doinstr.d]
    mov       [r10+52],	eax
    mov       rcx,	[rbp + mc_genss.doinstr.d]
    call      mc_genss.dofwdrefs
    jmp       L2532
L2548:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.do_call
    jmp       L2532
L2549:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.m]
    call      mc_genss.do_jmp
    jmp       L2532
L2550:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	1
    call      mc_genss.getdef
    mov       [rbp + mc_genss.doinstr.d],	rax
    mov       rcx,	7
    call      mc_genss.getcurrdatalen
    add       rax,	1
    mov       rcx,	[rbp + mc_genss.doinstr.d]
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       [rbp + mc_genss.doinstr.offset],	rax
    mov       rax,	[rbp + mc_genss.doinstr.offset]
    cmp       rax,	0
    jge       L2552
    mov       rax,	[rbp + mc_genss.doinstr.offset]
    cmp       rax,	-126
    jge       L2554
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+25]
    mov       rax,	128
    add       rax,	r10
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rax,	[rbp + mc_genss.doinstr.offset]
    sub       rax,	4
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L2553
L2554:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+25]
    mov       rax,	112
    add       rax,	r10
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.doinstr.offset]
    mov       [r10],	al
L2553:
    jmp       L2551
L2552:
    mov       rcx,	[rbp + mc_genss.doinstr.m]
    mov       rdx,	[rbp + mc_genss.doinstr.d]
    call      mc_genss.checkshortjump
    mov       [rbp + mc_genss.doinstr.shortjmp],	rax
    mov       rax,	[rbp + mc_genss.doinstr.shortjmp]
    test      rax,	rax
    jnz       L2556
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+25]
    mov       rax,	128
    add       rax,	r10
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.genrel32
    jmp       L2555
L2556:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+25]
    mov       rax,	112
    add       rax,	r10
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.genrel8
L2555:
L2551:
    jmp       L2532
L2557:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	1
    call      mc_genss.genopnd
    jmp       L2532
L2558:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	2
    call      mc_genss.genopnd
    jmp       L2532
L2559:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L2532
L2560:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L2532
L2561:
    mov       rcx,	1
    call      mc_genss.switchseg
    jmp       L2532
L2562:
    mov       rcx,	2
    call      mc_genss.switchseg
    jmp       L2532
L2563:
    mov       rcx,	3
    call      mc_genss.switchseg
    jmp       L2532
L2564:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r11b
    jmp       L2532
L2565:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	152
    mov       [r10],	al
    jmp       L2532
L2566:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L2532
L2567:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L2532
L2568:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L2532
L2569:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	195
    mov       [r10],	al
    jmp       L2532
L2570:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jz        L2572
    lea       rcx,	[rel L5768]
    call      mc_libmcl.axerror
L2572:
L2571:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	194
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.genword
    jmp       L2532
L2573:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.do_push
    jmp       L2532
L2574:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.do_pop
    jmp       L2532
L2575:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	r11
    call      mc_genss.do_inc
    jmp       L2532
L2576:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	r11
    call      mc_genss.do_neg
    jmp       L2532
L2577:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r11
    call      mc_genss.do_arith
    jmp       L2532
L2578:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_mov
    jmp       L2532
L2579:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_lea
    jmp       L2532
L2580:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	190
    call      mc_genss.do_movsx
    jmp       L2532
L2581:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	182
    call      mc_genss.do_movsx
    jmp       L2532
L2582:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_movsxd
    jmp       L2532
L2583:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_exch
    jmp       L2532
L2584:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_imul2
    jmp       L2532
L2585:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jnz       L2587
    mov       rax,	[rbp + mc_genss.doinstr.a]
    mov       r10,	[rax]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r11,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     rdi,	byte [rax + r11-1]
    imul      r10,	rdi
    mov       [rbp + mc_genss.doinstr.n],	r10
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L2589
    cmp       rax,	2
    jz        L2590
    jmp       L2591
L2589:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_1],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_1]
    cmp       rax,	0
    jle       L2594
L2592:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	144
    mov       [r10],	al
L2593:
    dec       qword [rbp + mc_genss.doinstr.av_1]
    jnz       L2592
L2594:
    jmp       L2588
L2590:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_2],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_2]
    cmp       rax,	0
    jle       L2597
L2595:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    xor       eax,	eax
    mov       [r10],	al
L2596:
    dec       qword [rbp + mc_genss.doinstr.av_2]
    jnz       L2595
L2597:
    jmp       L2588
L2591:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    add       [mc_decls.ss_zdatalen],	rax
L2588:
    jmp       L2586
L2587:
    lea       rcx,	[rel L5769]
    call      mc_libmcl.axerror
L2586:
    jmp       L2532
L2598:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jnz       L2600
    mov       rax,	[rbp + mc_genss.doinstr.a]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.doinstr.x],	r10
    mov       rax,	[rbp + mc_genss.doinstr.x]
    cmp       rax,	1
    jl        L2603
    mov       rax,	[rbp + mc_genss.doinstr.x]
    cmp       rax,	16384
    jle       L2602
L2603:
    lea       rcx,	[rel L5770]
    call      mc_libmcl.axerror
L2602:
L2601:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	3
    jz        L2605
    jmp       L2607
L2606:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jnz       L2610
    mov       rax,	144
    jmp       L2609
L2610:
    xor       eax,	eax
L2609:
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2607:
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferlength
    mov       r10,	[rbp + mc_genss.doinstr.x]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L2606
L2608:
    jmp       L2604
L2605:
    jmp       L2612
L2611:
    inc       qword [mc_decls.ss_zdatalen]
L2612:
    mov       rax,	[mc_decls.ss_zdatalen]
    mov       r10,	[rbp + mc_genss.doinstr.x]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L2611
L2613:
L2604:
    jmp       L2599
L2600:
    lea       rcx,	[rel L5771]
    call      mc_libmcl.axerror
L2599:
    jmp       L2532
L2614:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r11
    call      mc_genss.do_shift
    jmp       L2532
L2615:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_test
    jmp       L2532
L2616:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	r11
    call      mc_genss.do_loop
    jmp       L2532
L2617:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	4
    call      mc_genss.do_jcxz
    jmp       L2532
L2618:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	8
    call      mc_genss.do_jcxz
    jmp       L2532
L2619:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	215
    mov       [r10],	al
    jmp       L2532
L2620:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+25]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.do_setcc
    jmp       L2532
L2621:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	4
    call      mc_genss.do_movxmm
    jmp       L2532
L2622:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	8
    call      mc_genss.do_movxmm
    jmp       L2532
L2623:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	243
    mov       r9,	r11
    call      mc_genss.do_arithxmm
    jmp       L2532
L2624:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	242
    mov       r9,	r11
    call      mc_genss.do_arithxmm
    jmp       L2532
L2625:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r11
    mov       r9,	4
    call      mc_genss.do_logicxmm
    jmp       L2532
L2626:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r11
    mov       r9,	8
    call      mc_genss.do_logicxmm
    jmp       L2532
L2627:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    xor       r8d,	r8d
    mov       r9,	47
    call      mc_genss.do_arithxmm
    jmp       L2532
L2628:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	102
    mov       r9,	47
    call      mc_genss.do_arithxmm
    jmp       L2532
L2629:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	243
    call      mc_genss.do_convertfloat
    jmp       L2532
L2630:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	242
    call      mc_genss.do_convertfloat
    jmp       L2532
L2631:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	243
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L2532
L2632:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	242
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L2532
L2633:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	243
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L2532
L2634:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	242
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L2532
L2635:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	243
    call      mc_genss.do_float
    jmp       L2532
L2636:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	242
    call      mc_genss.do_float
    jmp       L2532
L2637:
    mov       rax,	[rbp + mc_genss.doinstr.a]
    mov       [mc_genss.extraparam],	rax
    jmp       L2532
L2638:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+25]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genss.doinstr.a]
    mov       r8,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_cmovcc
    jmp       L2532
L2639:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r11b
    jmp       L2532
L2640:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	1
    mov       r8,	r11
    call      mc_genss.do_fmem
    jmp       L2532
L2641:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    xor       edx,	edx
    mov       r8,	r11
    call      mc_genss.do_fmem
    jmp       L2532
L2642:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	222
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r11b
    jmp       L2532
L2643:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	166
    mov       [r10],	al
    jmp       L2532
L2644:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L2532
L2645:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L2532
L2646:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L2532
L2647:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r11b
    jmp       L2532
L2648:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r11
    call      mc_genss.do_movdqx
    jmp       L2532
L2649:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	219
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	227
    mov       [r10],	al
    jmp       L2532
L2650:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r11b
    jmp       L2532
L2651:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    call      mc_genss.do_popcnt
    jmp       L2532
L2652:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r11
    call      mc_genss.do_bsf
    jmp       L2532
L2653:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	162
    mov       [r10],	al
    jmp       L2532
L2654:
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    call      mc_genss.do_bswap
    jmp       L2532
L2655:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclcodes]
    movzx     r11,	byte [rax + r10-1]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+26]
    mov       rcx,	[rbp + mc_genss.doinstr.a]
    mov       rdx,	[rbp + mc_genss.doinstr.b]
    mov       r8,	r10
    mov       r9,	r11
    call      mc_genss.do_dshift
    jmp       L2532
L2656:
    jmp       L2532
L2657:
    jmp       L2532
L2534:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5772]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    lea       rax,	[mc_decls.mclnames]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5773]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       rcx,	[rel L5774]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [rax+24]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    lea       rcx,	[rel L5775]
    call      msys.m$print_str_nf
    mov       rcx,	150
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5776]
    call      mc_libmcl.axerror
L2532:
L2531:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc start
mc_genss.start:
;>>
;---------------
    mov       al,	64
    mov       [mc_genss.ishighreg+3],	al
    mov       al,	64
    mov       [mc_genss.ishighreg+5],	al
    mov       al,	64
    mov       [mc_genss.ishighreg+14],	al
    mov       al,	64
    mov       [mc_genss.ishighreg+15],	al
L2658:
;---------------
    ret       
;End 
;Proc genword
mc_genss.genword:
;>>
    %define mc_genss.genword.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	[rbp + mc_genss.genword.x]
    call      mc_genss.addword
L2659:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gendword
mc_genss.gendword:
;>>
    %define mc_genss.gendword.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	[rbp + mc_genss.gendword.x]
    call      mc_genss.adddword
L2660:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genqword
mc_genss.genqword:
;>>
    %define mc_genss.genqword.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	[rbp + mc_genss.genqword.x]
    call      mc_genss.addqword
L2661:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genopnd
mc_genss.genopnd:
;>>
    %define mc_genss.genopnd.a 16
    %define mc_genss.genopnd.size 24
    %define mc_genss.genopnd.s -8
    %define mc_genss.genopnd.x -16
    %define mc_genss.genopnd.length -24
    %define mc_genss.genopnd.x32 -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.genopnd.size]
    cmp       rax,	0
    jnz       L2664
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       [rbp + mc_genss.genopnd.size],	r10
L2664:
L2663:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	4
    jz        L2666
    cmp       r10,	7
    jz        L2667
    jmp       L2668
L2666:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.genopnd.s],	r10
    mov       rcx,	[rbp + mc_genss.genopnd.s]
    call      strlen
    mov       [rbp + mc_genss.genopnd.length],	rax
    mov       rax,	[rbp + mc_genss.genopnd.length]
    cmp       rax,	100
    jle       L2670
    mov       rax,	[rbp + mc_genss.genopnd.length]
    add       rax,	1
    mov       r10,	1024
    cmp       r10,	rax
    cmovl     r10,	rax
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	r10
    call      mc_genss.buffercheck
L2670:
L2669:
    jmp       L2672
L2671:
    mov       rax,	[rbp + mc_genss.genopnd.s]
    inc       qword [rbp + mc_genss.genopnd.s]
    movzx     r10,	byte [rax]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
L2672:
    mov       rax,	[rbp + mc_genss.genopnd.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L2671
L2673:
    jmp       L2662
L2667:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5777]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2668:
L2665:
    mov       rcx,	[rbp + mc_genss.genopnd.a]
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L2675
    mov       rax,	[rbp + mc_genss.genopnd.size]
    cmp       rax,	2
    jg        L2675
    lea       rcx,	[rel L5778]
    call      mc_libmcl.axerror
L2675:
L2674:
    mov       rax,	[rbp + mc_genss.genopnd.size]
    cmp       rax,	1
    jz        L2677
    cmp       rax,	2
    jz        L2678
    cmp       rax,	4
    jz        L2679
    cmp       rax,	8
    jz        L2680
    jmp       L2681
L2677:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    mov       r10,	[rax]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L2676
L2678:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.genword
    jmp       L2676
L2679:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	1
    jz        L2683
    cmp       r10,	2
    jz        L2684
    cmp       r10,	5
    jz        L2685
    cmp       r10,	6
    jz        L2685
    jmp       L2686
L2683:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L2682
L2684:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movq      XMM4,	[rax]
    cvtsd2ss  XMM4,	XMM4
    movd      [rbp + mc_genss.genopnd.x32],	XMM4
    movd      XMM4,	[rbp + mc_genss.genopnd.x32]
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L2682
L2685:
    mov       rcx,	[rbp + mc_genss.genopnd.a]
    call      mc_genss.genabs32
    jmp       L2682
L2686:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    lea       rax,	[mc_decls.valtypenames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5779]
    call      mc_libmcl.axerror
L2682:
    jmp       L2676
L2680:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	1
    jz        L2688
    cmp       r10,	2
    jz        L2689
    cmp       r10,	5
    jz        L2690
    cmp       r10,	6
    jz        L2690
    jmp       L2691
L2688:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.genqword
    jmp       L2687
L2689:
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movq      XMM4,	[rax]
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L2687
L2690:
    mov       rcx,	[rbp + mc_genss.genopnd.a]
    call      mc_genss.genabs64
    jmp       L2687
L2691:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_genss.genopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    lea       rax,	[mc_decls.valtypenames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5780]
    call      mc_libmcl.axerror
L2687:
L2681:
L2676:
L2662:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc addrelocitem
mc_genss.addrelocitem:
;>>
    %define mc_genss.addrelocitem.reloctype 16
    %define mc_genss.addrelocitem.d 24
    %define mc_genss.addrelocitem.r -8
    %define mc_genss.addrelocitem.stindex -16
    %define mc_genss.addrelocitem.adjust -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_genss.addrelocitem.d]
    call      mc_genss.getstindex
    mov       [rbp + mc_genss.addrelocitem.stindex],	rax
    mov       rax,	4
    mov       [rbp + mc_genss.addrelocitem.adjust],	rax
    mov       rax,	[rbp + mc_genss.addrelocitem.reloctype]
    cmp       rax,	1
    jnz       L2694
    mov       rax,	8
    mov       [rbp + mc_genss.addrelocitem.adjust],	rax
L2694:
L2693:
    mov       rcx,	32
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_genss.addrelocitem.r],	rax
    mov       rax,	[mc_genss.currrelocs]
    mov       r10,	[rbp + mc_genss.addrelocitem.r]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_genss.addrelocitem.reloctype]
    mov       r10,	[rbp + mc_genss.addrelocitem.r]
    mov       [r10+8],	rax
    mov       rcx,	1
    call      mc_genss.getcurrdatalen
    sub       rax,	[rbp + mc_genss.addrelocitem.adjust]
    mov       r10,	[rbp + mc_genss.addrelocitem.r]
    mov       [r10+16],	rax
    mov       rax,	[rbp + mc_genss.addrelocitem.stindex]
    mov       r10,	[rbp + mc_genss.addrelocitem.r]
    mov       [r10+24],	rax
    inc       qword [mc_genss.nrelocs]
    mov       rax,	[rbp + mc_genss.addrelocitem.r]
    mov       [mc_genss.currrelocs],	rax
L2692:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc getstindex
mc_genss.getstindex:
;>>
    %define mc_genss.getstindex.d 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.getstindex.d]
    movsx     r10,	word [rax+72]
    cmp       r10,	0
    jnz       L2697
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	[mc_decls.ss_symboltablesize]
    jl        L2699
    call      mc_genss.extendsymboltable
L2699:
L2698:
    inc       qword [mc_decls.ss_nsymbols]
    mov       rax,	[mc_decls.ss_nsymbols]
    mov       r10,	[rbp + mc_genss.getstindex.d]
    mov       [r10+72],	ax
    mov       rax,	[rbp + mc_genss.getstindex.d]
    movsx     r10,	word [rax+72]
    mov       rax,	[rbp + mc_genss.getstindex.d]
    mov       r11,	[mc_decls.ss_symboltable]
    mov       [r11 + r10*8-8],	rax
    mov       rax,	[rbp + mc_genss.getstindex.d]
    movzx     r10,	byte [rax+70]
    cmp       r10,	0
    jnz       L2701
    mov       rax,	[rbp + mc_genss.getstindex.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L2703
    mov       al,	1
    mov       r10,	[rbp + mc_genss.getstindex.d]
    mov       [r10+70],	al
L2703:
L2702:
L2701:
L2700:
L2697:
L2696:
    mov       rax,	[rbp + mc_genss.getstindex.d]
    movsx     r10,	word [rax+72]
    mov       rax,	r10
L2695:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genrel32
mc_genss.genrel32:
;>>
    %define mc_genss.genrel32.a 16
    %define mc_genss.genrel32.d -8
    %define mc_genss.genrel32.$T1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genss.genrel32.a]
    xor       edx,	edx
    call      mc_genss.getdef
    mov       [rbp + mc_genss.genrel32.d],	rax
    mov       rax,	[rbp + mc_genss.genrel32.d]
    cmp       rax,	0
    jnz       L2706
    mov       rax,	[rbp + mc_genss.genrel32.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L2704
L2706:
L2705:
    mov       rax,	[rbp + mc_genss.genrel32.d]
    movzx     r10,	byte [rax+69]
    cmp       r10,	2
    jz        L2708
    cmp       r10,	1
    jz        L2709
    jmp       L2710
L2708:
    mov       rax,	[rbp + mc_genss.genrel32.d]
    movzx     r10,	byte [rax+70]
    cmp       r10,	[mc_genss.currseg]
    jz        L2712
    lea       rcx,	[rel L5781]
    call      mc_libmcl.axerror
L2712:
L2711:
    mov       rax,	[rbp + mc_genss.genrel32.d]
    movsxd    r10,	dword [rax+52]
    mov       [rbp + mc_genss.genrel32.$T1],	r10
    mov       rcx,	2
    call      mc_genss.getcurrdatalen
    add       rax,	4
    mov       r10,	[rbp + mc_genss.genrel32.$T1]
    sub       r10,	rax
    mov       rax,	[rbp + mc_genss.genrel32.a]
    movsxd    r11,	dword [rax+12]
    add       r10,	r11
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L2707
L2709:
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rbp + mc_genss.genrel32.d]
    mov       r11,	[r10+88]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	4
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       r10,	[rbp + mc_genss.genrel32.d]
    mov       [r10+88],	rax
    mov       rax,	[rbp + mc_genss.genrel32.a]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L2707
L2710:
    mov       rax,	[rbp + mc_genss.genrel32.a]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    call      mc_genss.gendword
    mov       rcx,	4
    mov       rdx,	[rbp + mc_genss.genrel32.d]
    call      mc_genss.addrelocitem
L2707:
L2704:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getdef
mc_genss.getdef:
;>>
    %define mc_genss.getdef.a 16
    %define mc_genss.getdef.dneeded 24
    %define mc_genss.getdef.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.getdef.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L2716
    cmp       r10,	2
    jnz       L2715
L2716:
    mov       rax,	[rbp + mc_genss.getdef.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	6
    jz        L2718
    cmp       r10,	5
    jz        L2719
    jmp       L2720
L2718:
    mov       rax,	[rbp + mc_genss.getdef.a]
    mov       r10,	[rax]
    mov       rax,	[mc_decls.labeldeftable]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
    jmp       L2713
L2719:
    mov       rax,	[rbp + mc_genss.getdef.a]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.getdef.d],	r10
    mov       rax,	[rbp + mc_genss.getdef.d]
    movzx     r10,	byte [rax+69]
    cmp       r10,	0
    jnz       L2722
    mov       rax,	[rbp + mc_genss.getdef.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jnz       L2724
    mov       al,	1
    mov       r10,	[rbp + mc_genss.getdef.d]
    mov       [r10+69],	al
L2724:
L2723:
L2722:
L2721:
    mov       rax,	[rbp + mc_genss.getdef.d]
    jmp       L2713
L2720:
L2717:
L2715:
L2714:
    mov       rax,	[rbp + mc_genss.getdef.dneeded]
    test      rax,	rax
    jz        L2726
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_genss.getdef.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    lea       rax,	[mc_decls.opndnames_ma]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.getdef.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    lea       rax,	[mc_decls.valtypenames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5782]
    call      mc_libmcl.axerror
L2726:
L2725:
    xor       eax,	eax
L2713:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genabs32
mc_genss.genabs32:
;>>
    %define mc_genss.genabs32.a 16
    %define mc_genss.genabs32.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genss.genabs32.a]
    mov       rdx,	1
    call      mc_genss.getdef
    mov       [rbp + mc_genss.genabs32.d],	rax
    mov       rax,	[rbp + mc_genss.genabs32.d]
    movzx     r10,	byte [rax+69]
    cmp       r10,	2
    jz        L2729
    cmp       r10,	1
    jz        L2730
    jmp       L2731
L2729:
    mov       rax,	[rbp + mc_genss.genabs32.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mc_genss.genabs32.a]
    movsxd    r11,	dword [rax+12]
    add       r10,	r11
    mov       rcx,	r10
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	[rbp + mc_genss.genabs32.d]
    call      mc_genss.addrelocitem
    jmp       L2728
L2730:
    mov       rcx,	4
    call      mc_genss.getcurrdatalen
    mov       r10,	[rbp + mc_genss.genabs32.d]
    mov       r11,	[r10+88]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	2
    mov       r9,	[mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       r10,	[rbp + mc_genss.genabs32.d]
    mov       [r10+88],	rax
    mov       rax,	[rbp + mc_genss.genabs32.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	4
    jz        L2734
    cmp       r10,	5
    jnz       L2733
L2734:
    mov       rax,	[rbp + mc_genss.genabs32.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mc_genss.genabs32.a]
    movsxd    r11,	dword [rax+12]
    add       r10,	r11
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L2732
L2733:
    mov       rax,	[rbp + mc_genss.genabs32.a]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	[rbp + mc_genss.genabs32.d]
    call      mc_genss.addrelocitem
L2732:
    jmp       L2728
L2731:
    mov       rax,	[rbp + mc_genss.genabs32.a]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	[rbp + mc_genss.genabs32.d]
    call      mc_genss.addrelocitem
L2728:
L2727:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genabs64
mc_genss.genabs64:
;>>
    %define mc_genss.genabs64.a 16
    %define mc_genss.genabs64.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genss.genabs64.a]
    mov       rdx,	1
    call      mc_genss.getdef
    mov       [rbp + mc_genss.genabs64.d],	rax
    mov       rax,	[rbp + mc_genss.genabs64.d]
    movzx     r10,	byte [rax+69]
    cmp       r10,	2
    jz        L2737
    cmp       r10,	1
    jz        L2738
    jmp       L2739
L2737:
    mov       rax,	[rbp + mc_genss.genabs64.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mc_genss.genabs64.a]
    movsxd    r11,	dword [rax+12]
    add       r10,	r11
    mov       rcx,	r10
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	[rbp + mc_genss.genabs64.d]
    call      mc_genss.addrelocitem
    jmp       L2736
L2738:
    mov       rcx,	5
    call      mc_genss.getcurrdatalen
    mov       r10,	[rbp + mc_genss.genabs64.d]
    mov       r11,	[r10+88]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       r10,	[rbp + mc_genss.genabs64.d]
    mov       [r10+88],	rax
    mov       rax,	[rbp + mc_genss.genabs64.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	4
    jz        L2742
    cmp       r10,	5
    jnz       L2741
L2742:
    mov       rax,	[rbp + mc_genss.genabs64.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mc_genss.genabs64.a]
    movsxd    r11,	dword [rax+12]
    add       r10,	r11
    mov       rcx,	r10
    call      mc_genss.genqword
    jmp       L2740
L2741:
    mov       rax,	[rbp + mc_genss.genabs64.a]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	[rbp + mc_genss.genabs64.d]
    call      mc_genss.addrelocitem
L2740:
    jmp       L2736
L2739:
    mov       rax,	[rbp + mc_genss.genabs64.a]
    movsxd    r10,	dword [rax+12]
    mov       rcx,	r10
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	[rbp + mc_genss.genabs64.d]
    call      mc_genss.addrelocitem
L2736:
L2735:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getrel32
mc_genss.getrel32:
;>>
    %define mc_genss.getrel32.d 16
    %define mc_genss.getrel32.offset 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.getrel32.d]
    movzx     r10,	byte [rax+69]
    cmp       r10,	2
    jnz       L2745
    mov       rax,	[rbp + mc_genss.getrel32.d]
    movzx     r10,	byte [rax+70]
    cmp       r10,	[mc_genss.currseg]
    jz        L2747
    lea       rcx,	[rel L5783]
    call      mc_libmcl.axerror
L2747:
L2746:
    mov       rax,	[rbp + mc_genss.getrel32.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mc_genss.getrel32.offset]
    add       rax,	1
    sub       r10,	rax
    mov       rax,	r10
    jmp       L2744
L2745:
    mov       rax,	2147483647
L2744:
L2743:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc dofwdrefs
mc_genss.dofwdrefs:
;>>
    %define mc_genss.dofwdrefs.d 16
    %define mc_genss.dofwdrefs.f -8
    %define mc_genss.dofwdrefs.offset -16
    %define mc_genss.dofwdrefs.seg -24
    %define mc_genss.dofwdrefs.p8 -32
    %define mc_genss.dofwdrefs.p32 -40
    %define mc_genss.dofwdrefs.p64 -48
    %define mc_genss.dofwdrefs.data -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    mov       r10,	[rax+88]
    cmp       r10,	0
    jnz       L2750
    jmp       L2748
L2750:
L2749:
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    mov       r10,	[rax+88]
    mov       [rbp + mc_genss.dofwdrefs.f],	r10
    jmp       L2752
L2751:
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    movsxd    r10,	dword [rax+8]
    mov       [rbp + mc_genss.dofwdrefs.offset],	r10
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    movsx     r10,	word [rax+12]
    cmp       r10,	4
    jz        L2755
    cmp       r10,	2
    jz        L2756
    cmp       r10,	1
    jz        L2756
    cmp       r10,	6
    jz        L2757
    jmp       L2758
L2755:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	[rbp + mc_genss.dofwdrefs.offset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_genss.dofwdrefs.p32],	rax
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    movsxd    r10,	dword [rax+52]
    sub       r10,	[rbp + mc_genss.dofwdrefs.offset]
    sub       r10,	4
    mov       rax,	[rbp + mc_genss.dofwdrefs.p32]
    mov       [rax],	r10d
    jmp       L2754
L2756:
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    movsx     r10,	word [rax+14]
    cmp       r10,	1
    jz        L2760
    cmp       r10,	3
    jz        L2761
    cmp       r10,	2
    jz        L2762
    jmp       L2763
L2760:
    mov       rax,	[mc_decls.ss_code]
    mov       [rbp + mc_genss.dofwdrefs.data],	rax
    jmp       L2759
L2761:
    lea       rcx,	[rel L5784]
    call      mc_libmcl.axerror
    jmp       L2759
L2762:
    mov       rax,	[mc_decls.ss_idata]
    mov       [rbp + mc_genss.dofwdrefs.data],	rax
L2763:
L2759:
    mov       rcx,	[rbp + mc_genss.dofwdrefs.data]
    mov       rdx,	[rbp + mc_genss.dofwdrefs.offset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_genss.dofwdrefs.p32],	rax
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    movsx     r10,	word [rax+12]
    cmp       r10,	2
    jnz       L2765
    mov       rax,	[rbp + mc_genss.dofwdrefs.p32]
    movsxd    r10,	dword [rax]
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    movsxd    r11,	dword [rax+52]
    add       r10,	r11
    mov       rax,	[rbp + mc_genss.dofwdrefs.p32]
    mov       [rax],	r10d
    jmp       L2764
L2765:
    mov       rax,	[rbp + mc_genss.dofwdrefs.p32]
    mov       [rbp + mc_genss.dofwdrefs.p64],	rax
    mov       rax,	[rbp + mc_genss.dofwdrefs.p64]
    mov       r10,	[rax]
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    movsxd    r11,	dword [rax+52]
    add       r10,	r11
    mov       rax,	[rbp + mc_genss.dofwdrefs.p64]
    mov       [rax],	r10
L2764:
    jmp       L2754
L2757:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	[rbp + mc_genss.dofwdrefs.offset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_genss.dofwdrefs.p8],	rax
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    movsxd    r10,	dword [rax+52]
    sub       r10,	[rbp + mc_genss.dofwdrefs.offset]
    sub       r10,	1
    mov       rax,	[rbp + mc_genss.dofwdrefs.p8]
    mov       [rax],	r10b
    jmp       L2754
L2758:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    movsx     r10,	word [rax+12]
    lea       rax,	[mc_objdecls.relocnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.dofwdrefs.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5785]
    call      mc_libmcl.axerror
L2754:
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.dofwdrefs.f],	r10
L2752:
    mov       rax,	[rbp + mc_genss.dofwdrefs.f]
    test      rax,	rax
    jnz       L2751
L2753:
L2748:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc genrex
mc_genss.genrex:
;>>
;---------------
    movzx     rax,	byte [mc_genss.f2override]
    test      rax,	rax
    jz        L2768
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	242
    mov       [r10],	al
L2768:
L2767:
    movzx     rax,	byte [mc_genss.f3override]
    test      rax,	rax
    jz        L2770
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	243
    mov       [r10],	al
L2770:
L2769:
    movzx     rax,	byte [mc_genss.sizeoverride]
    test      rax,	rax
    jz        L2772
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
L2772:
L2771:
    movzx     rax,	byte [mc_genss.addroverride]
    test      rax,	rax
    jz        L2774
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	103
    mov       [r10],	al
L2774:
L2773:
    movzx     rax,	byte [mc_genss.nowmask]
    test      rax,	rax
    jz        L2776
    and       byte [mc_genss.rex],	247
L2776:
L2775:
    movzx     rax,	byte [mc_genss.rex]
    test      rax,	rax
    jz        L2778
    movzx     rax,	byte [mc_genss.rex]
    and       rax,	15
    add       rax,	64
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2778:
L2777:
L2766:
;---------------
    ret       
;End 
;Proc isbytesized
mc_genss.isbytesized:
;>>
    %define mc_genss.isbytesized.x 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.isbytesized.x]
    cmp       rax,	-128
    jl        L2780
    cmp       rax,	127
    jg        L2780
    mov       rax,	1
    jmp       L2781
L2780:
    xor       eax,	eax
L2781:
L2779:
;---------------
    pop       rbp
    ret       
;End 
;Proc isdwordsized
mc_genss.isdwordsized:
;>>
    %define mc_genss.isdwordsized.x 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.isdwordsized.x]
    cmp       rax,	-2147483648
    jl        L2783
    cmp       rax,	2147483647
    jg        L2783
    mov       rax,	1
    jmp       L2784
L2783:
    xor       eax,	eax
L2784:
L2782:
;---------------
    pop       rbp
    ret       
;End 
;Proc genamode
mc_genss.genamode:
;>>
    %define mc_genss.genamode.a 16
    %define mc_genss.genamode.am 24
    %define mc_genss.genamode.d -8
    %define mc_genss.genamode.pr -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [rbp + mc_genss.genamode.am]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    movsx     rax,	byte [rbp + mc_genss.genamode.am+2]
    cmp       rax,	1
    jnz       L2787
    movzx     rax,	byte [rbp + mc_genss.genamode.am+1]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2787:
L2786:
    movzx     rax,	byte [rbp + mc_genss.genamode.am+3]
    cmp       rax,	0
    jz        L2789
    cmp       rax,	1
    jz        L2790
    cmp       rax,	4
    jz        L2791
    jmp       L2792
L2789:
    jmp       L2788
L2790:
    movsxd    rax,	dword [rbp + mc_genss.genamode.am+4]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L2788
L2791:
    movsx     rax,	byte [rbp + mc_genss.genamode.am+2]
    cmp       rax,	-1
    jnz       L2794
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       [rbp + mc_genss.genamode.pr],	rax
    mov       rax,	[mc_decls.riplist]
    mov       r10,	[rbp + mc_genss.genamode.pr]
    mov       [r10],	rax
    mov       rax,	[mc_genss.currdata]
    mov       r10,	[rax+8]
    mov       rax,	[mc_genss.currdata]
    mov       r11,	[rax]
    sub       r10,	r11
    mov       rax,	[rbp + mc_genss.genamode.pr]
    mov       [rax+8],	r10d
    mov       rax,	[rbp + mc_genss.genamode.pr]
    mov       [mc_decls.riplist],	rax
    mov       [mc_genss.ripentry],	rax
L2794:
L2793:
    mov       rax,	[rbp + mc_genss.genamode.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L2796
    jmp       L2797
L2796:
    mov       rax,	[rbp + mc_genss.genamode.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	5
    jz        L2799
    cmp       r10,	6
    jz        L2799
    cmp       r10,	0
    jz        L2800
    cmp       r10,	8
    jz        L2800
    jmp       L2801
L2799:
    mov       rcx,	[rbp + mc_genss.genamode.a]
    call      mc_genss.genabs32
    jmp       L2798
L2800:
    movsxd    rax,	dword [rbp + mc_genss.genamode.am+4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L2798
L2801:
    lea       rcx,	[rel L5786]
    call      mc_libmcl.axerror
L2798:
    jmp       L2795
L2797:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_genss.genamode.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    lea       rax,	[mc_decls.opndnames_ma]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5787]
    call      mc_libmcl.axerror
L2795:
    jmp       L2788
L2792:
    lea       rcx,	[rel L5788]
    call      mc_libmcl.axerror
L2788:
L2785:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc setopsize
mc_genss.setopsize:
;>>
    %define mc_genss.setopsize.a 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.setopsize.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jz        L2804
    cmp       r10,	4
    jz        L2805
    cmp       r10,	1
    jz        L2806
    cmp       r10,	2
    jz        L2807
    jmp       L2808
L2804:
    mov       al,	8
    or        [mc_genss.rex],	al
    jmp       L2803
L2805:
    jmp       L2803
L2806:
    jmp       L2803
L2807:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    jmp       L2803
L2808:
    lea       rcx,	[rel L5789]
    call      mc_libmcl.axerror
L2803:
L2802:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getdispsize
mc_genss.getdispsize:
;>>
    %define mc_genss.getdispsize.a 16
    %define mc_genss.getdispsize.offset 24
    %define mc_genss.getdispsize.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_genss.getdispsize.a]
    xor       edx,	edx
    call      mc_genss.getdef
    mov       [rbp + mc_genss.getdispsize.d],	rax
    mov       rax,	[rbp + mc_genss.getdispsize.a]
    movsxd    r10,	dword [rax+12]
    mov       rax,	[rbp + mc_genss.getdispsize.offset]
    mov       [rax],	r10d
    mov       rax,	[rbp + mc_genss.getdispsize.d]
    test      rax,	rax
    jz        L2811
    mov       rax,	[rbp + mc_genss.getdispsize.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	4
    jz        L2814
    cmp       r10,	5
    jnz       L2813
L2814:
    mov       rax,	[rbp + mc_genss.getdispsize.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mc_genss.getdispsize.offset]
    add       [rax],	r10d
    jmp       L2812
L2813:
    mov       rax,	4
    jmp       L2809
L2812:
L2811:
L2810:
    mov       rax,	[rbp + mc_genss.getdispsize.offset]
    movsxd    r10,	dword [rax]
    test      r10,	r10
    jz        L2816
    mov       rax,	[rbp + mc_genss.getdispsize.offset]
    movsxd    r10,	dword [rax]
    mov       rcx,	r10
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L2818
    mov       rax,	1
    jmp       L2817
L2818:
    mov       rax,	4
L2817:
    jmp       L2815
L2816:
    xor       eax,	eax
L2815:
L2809:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc checkhighreg
mc_genss.checkhighreg:
;>>
    %define mc_genss.checkhighreg.a 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.checkhighreg.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L2821
    mov       rax,	[rbp + mc_genss.checkhighreg.a]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_genss.ishighreg]
    movzx     r11,	byte [rax + r10-1]
    or        [mc_genss.rex],	r11b
L2821:
L2820:
L2819:
;---------------
    pop       rbp
    ret       
;End 
;Proc do_loop
mc_genss.do_loop:
;>>
    %define mc_genss.do_loop.a 16
    %define mc_genss.do_loop.opc 24
    %define mc_genss.do_loop.offset -8
    %define mc_genss.do_loop.$T1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	9
    call      mc_genss.getcurrdatalen
    add       rax,	1
    mov       [rbp + mc_genss.do_loop.$T1],	rax
    mov       rcx,	[rbp + mc_genss.do_loop.a]
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_loop.$T1]
    call      mc_genss.getrel32
    mov       [rbp + mc_genss.do_loop.offset],	rax
    mov       rax,	[rbp + mc_genss.do_loop.offset]
    cmp       rax,	0
    jge       L2824
    mov       rax,	[rbp + mc_genss.do_loop.offset]
    cmp       rax,	-126
    jge       L2826
    lea       rcx,	[rel L5790]
    call      mc_libmcl.axerror
L2826:
L2825:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_loop.opc]
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_loop.offset]
    mov       [r10],	al
    jmp       L2823
L2824:
    lea       rcx,	[rel L5791]
    call      mc_libmcl.axerror
L2823:
L2822:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_jcxz
mc_genss.do_jcxz:
;>>
    %define mc_genss.do_jcxz.a 16
    %define mc_genss.do_jcxz.opsize 24
    %define mc_genss.do_jcxz.offset -8
    %define mc_genss.do_jcxz.$T1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	10
    call      mc_genss.getcurrdatalen
    add       rax,	1
    mov       [rbp + mc_genss.do_jcxz.$T1],	rax
    mov       rcx,	[rbp + mc_genss.do_jcxz.a]
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_jcxz.$T1]
    call      mc_genss.getrel32
    mov       [rbp + mc_genss.do_jcxz.offset],	rax
    mov       rax,	[rbp + mc_genss.do_jcxz.offset]
    cmp       rax,	0
    jge       L2829
    mov       rax,	[rbp + mc_genss.do_jcxz.offset]
    cmp       rax,	-126
    jge       L2831
    lea       rcx,	[rel L5792]
    call      mc_libmcl.axerror
L2831:
L2830:
    mov       rax,	[rbp + mc_genss.do_jcxz.opsize]
    cmp       rax,	4
    jnz       L2833
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	103
    mov       [r10],	al
L2833:
L2832:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	227
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_jcxz.offset]
    mov       [r10],	al
    jmp       L2828
L2829:
    lea       rcx,	[rel L5793]
    call      mc_libmcl.axerror
L2828:
L2827:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_call
mc_genss.do_call:
;>>
    %define mc_genss.do_call.a 16
    %define mc_genss.do_call.am -8
    %define mc_genss.do_call.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.do_call.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jz        L2836
    jmp       L2837
L2836:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	232
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_call.a]
    call      mc_genss.genrel32
    jmp       L2835
L2837:
    mov       rax,	[rbp + mc_genss.do_call.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jz        L2839
    cmp       r10,	1
    jz        L2840
    cmp       r10,	2
    jz        L2840
    cmp       r10,	4
    jz        L2840
    jmp       L2841
L2839:
    mov       rax,	[rbp + mc_genss.do_call.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    jmp       L2838
L2840:
    lea       rcx,	[rel L5794]
    call      mc_libmcl.axerror
L2841:
L2838:
    mov       rcx,	255
    mov       rdx,	2
    mov       r8,	[rbp + mc_genss.do_call.a]
    call      mc_genss.genxrm
L2835:
L2834:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_jmp
mc_genss.do_jmp:
;>>
    %define mc_genss.do_jmp.a 16
    %define mc_genss.do_jmp.m 24
    %define mc_genss.do_jmp.am -8
    %define mc_genss.do_jmp.regcode -16
    %define mc_genss.do_jmp.offset -24
    %define mc_genss.do_jmp.shortjmp -32
    %define mc_genss.do_jmp.d -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_genss.do_jmp.a]
    xor       edx,	edx
    call      mc_genss.getdef
    mov       [rbp + mc_genss.do_jmp.d],	rax
    mov       rax,	[rbp + mc_genss.do_jmp.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jz        L2844
    jmp       L2845
L2844:
    mov       rcx,	11
    call      mc_genss.getcurrdatalen
    add       rax,	1
    mov       rcx,	[rbp + mc_genss.do_jmp.d]
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       [rbp + mc_genss.do_jmp.offset],	rax
    mov       rax,	[rbp + mc_genss.do_jmp.offset]
    cmp       rax,	0
    jge       L2847
    mov       rax,	[rbp + mc_genss.do_jmp.offset]
    cmp       rax,	-126
    jle       L2847
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	235
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_jmp.offset]
    mov       [r10],	al
    jmp       L2846
L2847:
    xor       eax,	eax
    mov       [rbp + mc_genss.do_jmp.shortjmp],	rax
    mov       rax,	[rbp + mc_genss.do_jmp.offset]
    cmp       rax,	0
    jle       L2849
    mov       rcx,	[rbp + mc_genss.do_jmp.m]
    mov       rdx,	[rbp + mc_genss.do_jmp.d]
    call      mc_genss.checkshortjump
    mov       [rbp + mc_genss.do_jmp.shortjmp],	rax
L2849:
L2848:
    mov       rax,	[rbp + mc_genss.do_jmp.shortjmp]
    test      rax,	rax
    jnz       L2851
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	233
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_jmp.a]
    call      mc_genss.genrel32
    jmp       L2850
L2851:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	235
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_jmp.a]
    call      mc_genss.genrel8
L2850:
L2846:
    jmp       L2843
L2845:
    mov       rax,	[rbp + mc_genss.do_jmp.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jz        L2853
    cmp       r10,	1
    jz        L2854
    cmp       r10,	2
    jz        L2854
    cmp       r10,	4
    jz        L2854
    jmp       L2855
L2853:
    mov       rax,	[rbp + mc_genss.do_jmp.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    jmp       L2852
L2854:
    lea       rcx,	[rel L5795]
    call      mc_libmcl.axerror
L2855:
L2852:
    mov       rcx,	255
    mov       rdx,	4
    mov       r8,	[rbp + mc_genss.do_jmp.a]
    call      mc_genss.genxrm
L2843:
L2842:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc getcurrdatalen
mc_genss.getcurrdatalen:
;>>
    %define mc_genss.getcurrdatalen.id 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	3
    jnz       L2858
    mov       rax,	[mc_decls.ss_zdatalen]
    jmp       L2856
L2858:
L2857:
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferlength
L2856:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_cmovcc
mc_genss.do_cmovcc:
;>>
    %define mc_genss.do_cmovcc.cond 16
    %define mc_genss.do_cmovcc.a 24
    %define mc_genss.do_cmovcc.b 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_cmovcc.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_cmovcc.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L2861
    mov       rax,	[rbp + mc_genss.do_cmovcc.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    test      r10,	r10
    jz        L2861
    lea       rcx,	[rel L5796]
    call      mc_libmcl.axerror
L2861:
L2860:
    mov       rax,	[rbp + mc_genss.do_cmovcc.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L2863
    lea       rcx,	[rel L5797]
    call      mc_libmcl.axerror
L2863:
L2862:
    mov       rax,	3904
    add       rax,	[rbp + mc_genss.do_cmovcc.cond]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_cmovcc.a]
    mov       r8,	[rbp + mc_genss.do_cmovcc.b]
    call      mc_genss.genrrm
L2859:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_fmem
mc_genss.do_fmem:
;>>
    %define mc_genss.do_fmem.a 16
    %define mc_genss.do_fmem.freal 24
    %define mc_genss.do_fmem.code 32
    %define mc_genss.do_fmem.am -8
    %define mc_genss.do_fmem.regcode -16
    %define mc_genss.do_fmem.mf -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_fmem.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L2866
    lea       rcx,	[rel L5798]
    call      mc_libmcl.axerror
L2866:
L2865:
    mov       rax,	[rbp + mc_genss.do_fmem.freal]
    test      rax,	rax
    jz        L2868
    mov       rax,	[rbp + mc_genss.do_fmem.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jz        L2870
    cmp       r10,	8
    jz        L2871
    cmp       r10,	10
    jz        L2872
    cmp       r10,	16
    jz        L2872
    jmp       L2873
L2870:
    xor       eax,	eax
    mov       [rbp + mc_genss.do_fmem.mf],	rax
    jmp       L2869
L2871:
    mov       rax,	2
    mov       [rbp + mc_genss.do_fmem.mf],	rax
    jmp       L2869
L2872:
    mov       rax,	1
    mov       [rbp + mc_genss.do_fmem.mf],	rax
    mov       rax,	[rbp + mc_genss.do_fmem.code]
    cmp       rax,	0
    jz        L2875
    cmp       rax,	3
    jz        L2876
    jmp       L2877
L2875:
    mov       rax,	5
    mov       [rbp + mc_genss.do_fmem.code],	rax
    jmp       L2874
L2876:
    mov       rax,	7
    mov       [rbp + mc_genss.do_fmem.code],	rax
    jmp       L2874
L2877:
    lea       rcx,	[rel L5799]
    call      mc_libmcl.axerror
L2874:
    jmp       L2869
L2873:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5800]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.do_fmem.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5801]
    call      mc_libmcl.axerror
L2869:
    jmp       L2867
L2868:
    mov       rax,	[rbp + mc_genss.do_fmem.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	2
    jz        L2879
    cmp       r10,	4
    jz        L2880
    cmp       r10,	8
    jz        L2881
    jmp       L2882
L2879:
    mov       rax,	3
    mov       [rbp + mc_genss.do_fmem.mf],	rax
    jmp       L2878
L2880:
    mov       rax,	1
    mov       [rbp + mc_genss.do_fmem.mf],	rax
    jmp       L2878
L2881:
    mov       rax,	3
    mov       [rbp + mc_genss.do_fmem.mf],	rax
    mov       rax,	[rbp + mc_genss.do_fmem.code]
    cmp       rax,	0
    jz        L2884
    cmp       rax,	3
    jz        L2885
    jmp       L2886
L2884:
    mov       rax,	5
    mov       [rbp + mc_genss.do_fmem.code],	rax
    jmp       L2883
L2885:
    mov       rax,	7
    mov       [rbp + mc_genss.do_fmem.code],	rax
    jmp       L2883
L2886:
    lea       rcx,	[rel L5802]
    call      mc_libmcl.axerror
L2883:
    jmp       L2878
L2882:
    lea       rcx,	[rel L5803]
    call      mc_libmcl.axerror
L2878:
L2867:
    mov       rax,	[rbp + mc_genss.do_fmem.mf]
    shl       rax,	1
    mov       r10,	217
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genss.do_fmem.code]
    mov       r8,	[rbp + mc_genss.do_fmem.a]
    call      mc_genss.genxrm
L2864:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc genrel8
mc_genss.genrel8:
;>>
    %define mc_genss.genrel8.a 16
    %define mc_genss.genrel8.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_genss.genrel8.a]
    mov       rdx,	1
    call      mc_genss.getdef
    mov       [rbp + mc_genss.genrel8.d],	rax
    mov       rax,	[rbp + mc_genss.genrel8.d]
    movzx     r10,	byte [rax+69]
    cmp       r10,	1
    jnz       L2889
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rbp + mc_genss.genrel8.d]
    mov       r11,	[r10+88]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	6
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       r10,	[rbp + mc_genss.genrel8.d]
    mov       [r10+88],	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    xor       eax,	eax
    mov       [r10],	al
    jmp       L2888
L2889:
    lea       rcx,	[rel L5804]
    call      mc_libmcl.axerror
L2888:
L2887:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc checkshortjump
mc_genss.checkshortjump:
;>>
    %define mc_genss.checkshortjump.m 16
    %define mc_genss.checkshortjump.d 24
    %define mc_genss.checkshortjump.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       eax,	eax
    mov       [rbp + mc_genss.checkshortjump.n],	rax
    mov       rax,	[rbp + mc_genss.checkshortjump.m]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.checkshortjump.m],	r10
    jmp       L2892
L2891:
    mov       rax,	[rbp + mc_genss.checkshortjump.m]
    movzx     r10,	byte [rax+24]
    cmp       r10,	9
    jz        L2895
    cmp       r10,	3
    jz        L2896
    cmp       r10,	4
    jz        L2896
    cmp       r10,	5
    jz        L2896
    jmp       L2897
L2895:
    mov       rax,	[rbp + mc_genss.checkshortjump.m]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    mov       r10,	[rbp + mc_genss.checkshortjump.d]
    movsxd    r11,	dword [r10+76]
    cmp       rax,	r11
    jnz       L2899
    mov       rax,	1
    jmp       L2890
L2899:
L2898:
    jmp       L2894
L2896:
    jmp       L2894
L2897:
    inc       qword [rbp + mc_genss.checkshortjump.n]
L2894:
    mov       rax,	[rbp + mc_genss.checkshortjump.m]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.checkshortjump.m],	r10
L2892:
    mov       rax,	[rbp + mc_genss.checkshortjump.m]
    test      rax,	rax
    jz        L2900
    mov       rax,	[rbp + mc_genss.checkshortjump.n]
    cmp       rax,	8
    jle       L2891
L2900:
L2893:
    xor       eax,	eax
L2890:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc addfwdref
mc_genss.addfwdref:
;>>
    %define mc_genss.addfwdref.p 16
    %define mc_genss.addfwdref.offset 24
    %define mc_genss.addfwdref.reltype 32
    %define mc_genss.addfwdref.seg 40
    %define mc_genss.addfwdref.q -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_genss.addfwdref.q],	rax
    mov       rax,	[rbp + mc_genss.addfwdref.p]
    mov       r10,	[rbp + mc_genss.addfwdref.q]
    mov       [r10],	rax
    mov       eax,	[rbp + mc_genss.addfwdref.offset]
    mov       r10,	[rbp + mc_genss.addfwdref.q]
    mov       [r10+8],	eax
    mov       ax,	[rbp + mc_genss.addfwdref.reltype]
    mov       r10,	[rbp + mc_genss.addfwdref.q]
    mov       [r10+12],	ax
    mov       ax,	[rbp + mc_genss.addfwdref.seg]
    mov       r10,	[rbp + mc_genss.addfwdref.q]
    mov       [r10+14],	ax
    mov       rax,	[rbp + mc_genss.addfwdref.q]
L2901:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc switchseg
mc_genss.switchseg:
;>>
    %define mc_genss.switchseg.newseg 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.switchseg.newseg]
    cmp       rax,	[mc_genss.currseg]
    jnz       L2904
    jmp       L2902
L2904:
L2903:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L2906
    cmp       rax,	2
    jz        L2907
    jmp       L2908
L2906:
    mov       rax,	[mc_genss.currrelocs]
    mov       [mc_decls.ss_coderelocs],	rax
    mov       rax,	[mc_genss.nrelocs]
    mov       [mc_decls.ss_ncoderelocs],	rax
    jmp       L2905
L2907:
    mov       rax,	[mc_genss.currrelocs]
    mov       [mc_decls.ss_idatarelocs],	rax
    mov       rax,	[mc_genss.nrelocs]
    mov       [mc_decls.ss_nidatarelocs],	rax
L2908:
L2905:
    mov       rax,	[rbp + mc_genss.switchseg.newseg]
    mov       [mc_genss.currseg],	rax
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L2910
    cmp       rax,	2
    jz        L2911
    cmp       rax,	3
    jz        L2912
    jmp       L2913
L2910:
    mov       rax,	[mc_decls.ss_code]
    mov       [mc_genss.currdata],	rax
    mov       rax,	[mc_decls.ss_coderelocs]
    mov       [mc_genss.currrelocs],	rax
    mov       rax,	[mc_decls.ss_ncoderelocs]
    mov       [mc_genss.nrelocs],	rax
    jmp       L2909
L2911:
    mov       rax,	[mc_decls.ss_idata]
    mov       [mc_genss.currdata],	rax
    mov       rax,	[mc_decls.ss_idatarelocs]
    mov       [mc_genss.currrelocs],	rax
    mov       rax,	[mc_decls.ss_nidatarelocs]
    mov       [mc_genss.nrelocs],	rax
    jmp       L2909
L2912:
    mov       rax,	[mc_decls.ss_zdata]
    mov       [mc_genss.currdata],	rax
L2913:
L2909:
L2902:
;---------------
    pop       rbp
    ret       
;End 
;Proc do_popcnt
mc_genss.do_popcnt:
;>>
    %define mc_genss.do_popcnt.a 16
    %define mc_genss.do_popcnt.b 24
    %define mc_genss.do_popcnt.am -8
    %define mc_genss.do_popcnt.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_popcnt.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L2916
    mov       rax,	[rbp + mc_genss.do_popcnt.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L2918
    mov       rax,	[rbp + mc_genss.do_popcnt.b]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L2918:
L2917:
L2916:
L2915:
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       rcx,	4024
    mov       rdx,	[rbp + mc_genss.do_popcnt.a]
    mov       r8,	[rbp + mc_genss.do_popcnt.b]
    call      mc_genss.genrrm
L2914:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_bsf
mc_genss.do_bsf:
;>>
    %define mc_genss.do_bsf.a 16
    %define mc_genss.do_bsf.b 24
    %define mc_genss.do_bsf.opc 32
    %define mc_genss.do_bsf.am -8
    %define mc_genss.do_bsf.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_bsf.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L2921
    mov       rax,	[rbp + mc_genss.do_bsf.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L2923
    mov       rax,	[rbp + mc_genss.do_bsf.b]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L2923:
L2922:
L2921:
L2920:
    mov       rax,	[rbp + mc_genss.do_bsf.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_bsf.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L2925
    lea       rcx,	[rel L5805]
    call      mc_libmcl.axerror
L2925:
L2924:
    mov       rax,	3840
    add       rax,	[rbp + mc_genss.do_bsf.opc]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_bsf.a]
    mov       r8,	[rbp + mc_genss.do_bsf.b]
    call      mc_genss.genrrm
L2919:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc extendsymboltable
mc_genss.extendsymboltable:
;>>
    %define mc_genss.extendsymboltable.oldsymboltable -8
    %define mc_genss.extendsymboltable.oldsymboltablesize -16
    %define mc_genss.extendsymboltable.i -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rax,	[mc_decls.ss_symboltablesize]
    mov       [rbp + mc_genss.extendsymboltable.oldsymboltablesize],	rax
    mov       rax,	[mc_decls.ss_symboltable]
    mov       [rbp + mc_genss.extendsymboltable.oldsymboltable],	rax
    mov       rax,	[mc_decls.ss_symboltablesize]
    shl       rax,	1
    mov       [mc_decls.ss_symboltablesize],	rax
    mov       rax,	8
    imul      rax,	[mc_decls.ss_symboltablesize]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [mc_decls.ss_symboltable],	rax
    mov       rax,	1
    mov       [rbp + mc_genss.extendsymboltable.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L2929
L2927:
    mov       rax,	[rbp + mc_genss.extendsymboltable.oldsymboltable]
    mov       r10,	[rbp + mc_genss.extendsymboltable.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mc_genss.extendsymboltable.i]
    mov       [rax + r10*8-8],	r11
L2928:
    mov       rax,	[rbp + mc_genss.extendsymboltable.i]
    inc       rax
    mov       [rbp + mc_genss.extendsymboltable.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L2927
L2929:
    mov       rax,	8
    imul      rax,	[rbp + mc_genss.extendsymboltable.oldsymboltablesize]
    mov       rcx,	[rbp + mc_genss.extendsymboltable.oldsymboltable]
    mov       rdx,	rax
    call      mlib.pcm_free
L2926:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc initlib
mc_genss.initlib:
;>>
    %define mc_genss.initlib.nlabels 16
    %define mc_genss.initlib.str -256
    %define mc_genss.initlib.i -264
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	304
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	262144
    call      mlib.pcm_alloc
    mov       [mc_decls.ss_symboltable],	rax
    mov       rax,	32768
    mov       [mc_decls.ss_symboltablesize],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_nsymbols],	rax
    mov       rax,	[rbp + mc_genss.initlib.nlabels]
    imul      rax,	8
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [mc_decls.labeldeftable],	rax
    mov       rax,	1
    mov       [rbp + mc_genss.initlib.i],	rax
    mov       rax,	[rbp + mc_genss.initlib.nlabels]
    cmp       rax,	1
    jl        L2933
L2931:
    mov       rcx,	112
    call      mlib.pcm_allocnfz
    mov       r10,	[mc_decls.labeldeftable]
    mov       r11,	[rbp + mc_genss.initlib.i]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mc_decls.labeldeftable]
    mov       r10,	[rbp + mc_genss.initlib.i]
    mov       r11,	[rax + r10*8-8]
    mov       eax,	[rbp + mc_genss.initlib.i]
    mov       [r11+76],	eax
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5806]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mc_genss.initlib.i]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[mc_decls.labeldeftable]
    mov       r11,	[rbp + mc_genss.initlib.i]
    mov       rdi,	[r10 + r11*8-8]
    mov       [rdi],	rax
    mov       rax,	[mc_decls.labeldeftable]
    mov       r10,	[rbp + mc_genss.initlib.i]
    mov       r11,	[rax + r10*8-8]
    mov       al,	1
    mov       [r11+69],	al
L2932:
    mov       rax,	[rbp + mc_genss.initlib.i]
    inc       rax
    mov       [rbp + mc_genss.initlib.i],	rax
    cmp       rax,	[rbp + mc_genss.initlib.nlabels]
    jle       L2931
L2933:
L2930:
;---------------
    add       rsp,	304
    pop       rbp
    ret       
;End 
;Proc buffercreate
mc_genss.buffercreate:
;>>
    %define mc_genss.buffercreate.size 16
    %define mc_genss.buffercreate.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	32
    call      mlib.pcm_alloc
    mov       [rbp + mc_genss.buffercreate.a],	rax
    mov       rax,	[rbp + mc_genss.buffercreate.size]
    mov       r10,	[rbp + mc_genss.buffercreate.a]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_genss.buffercreate.a]
    mov       r10,	[rax+24]
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mc_genss.buffercreate.a]
    mov       [r10+8],	rax
    mov       r10,	[rbp + mc_genss.buffercreate.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_genss.buffercreate.a]
    mov       r10,	[rax]
    mov       rax,	[rbp + mc_genss.buffercreate.a]
    mov       r11,	[rax+24]
    lea       r10,	[r10 + r11]
    mov       rax,	[rbp + mc_genss.buffercreate.a]
    mov       [rax+16],	r10
    mov       rax,	[rbp + mc_genss.buffercreate.a]
L2934:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc bufferexpand
mc_genss.bufferexpand:
;>>
    %define mc_genss.bufferexpand.a 16
    %define mc_genss.bufferexpand.newalloc -8
    %define mc_genss.bufferexpand.usedbytes -16
    %define mc_genss.bufferexpand.p -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.bufferexpand.a]
    mov       r10,	[rax+24]
    imul      r10,	2
    mov       [rbp + mc_genss.bufferexpand.newalloc],	r10
    mov       rax,	[rbp + mc_genss.bufferexpand.a]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genss.bufferexpand.a]
    mov       r11,	[rax]
    sub       r10,	r11
    mov       [rbp + mc_genss.bufferexpand.usedbytes],	r10
    mov       rax,	[rbp + mc_genss.bufferexpand.a]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_genss.bufferexpand.usedbytes]
    cmp       rax,	r10
    jle       L2937
    call      msys.m$print_startcon
    lea       rcx,	[rel L5807]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
L2937:
L2936:
    mov       rcx,	[rbp + mc_genss.bufferexpand.newalloc]
    call      mlib.pcm_alloc
    mov       [rbp + mc_genss.bufferexpand.p],	rax
    mov       rax,	[rbp + mc_genss.bufferexpand.a]
    mov       r10,	[rax]
    mov       rcx,	[rbp + mc_genss.bufferexpand.p]
    mov       rdx,	r10
    mov       r8,	[rbp + mc_genss.bufferexpand.usedbytes]
    call      memcpy
    mov       rax,	[rbp + mc_genss.bufferexpand.p]
    mov       r10,	[rbp + mc_genss.bufferexpand.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_genss.bufferexpand.p]
    mov       r10,	[rbp + mc_genss.bufferexpand.usedbytes]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_genss.bufferexpand.a]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mc_genss.bufferexpand.newalloc]
    mov       r10,	[rbp + mc_genss.bufferexpand.a]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_genss.bufferexpand.p]
    mov       r10,	[rbp + mc_genss.bufferexpand.newalloc]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_genss.bufferexpand.a]
    mov       [r10+16],	rax
L2935:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc buffercheck
mc_genss.buffercheck:
;>>
    %define mc_genss.buffercheck.a 16
    %define mc_genss.buffercheck.n 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    jmp       L2940
L2939:
    mov       rcx,	[rbp + mc_genss.buffercheck.a]
    call      mc_genss.bufferexpand
L2940:
    mov       rax,	[rbp + mc_genss.buffercheck.a]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_genss.buffercheck.a]
    mov       r11,	[rax+8]
    sub       r10,	r11
    cmp       r10,	[rbp + mc_genss.buffercheck.n]
    jl        L2939
L2941:
L2938:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc bufferlength
mc_genss.bufferlength:
;>>
    %define mc_genss.bufferlength.a 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.bufferlength.a]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genss.bufferlength.a]
    mov       r11,	[rax]
    sub       r10,	r11
    mov       rax,	r10
L2942:
;---------------
    pop       rbp
    ret       
;End 
;Proc bufferelemptr
mc_genss.bufferelemptr:
;>>
    %define mc_genss.bufferelemptr.a 16
    %define mc_genss.bufferelemptr.offset 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.bufferelemptr.a]
    mov       r10,	[rax]
    mov       rax,	[rbp + mc_genss.bufferelemptr.offset]
    lea       r10,	[r10 + rax]
    mov       rax,	r10
L2943:
;---------------
    pop       rbp
    ret       
;End 
;Proc addword
mc_genss.addword:
;>>
    %define mc_genss.addword.a 16
    %define mc_genss.addword.x 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.addword.a]
    mov       r10,	[rax+8]
    mov       ax,	[rbp + mc_genss.addword.x]
    mov       [r10],	ax
    mov       rax,	[rbp + mc_genss.addword.a]
    lea       rax,	[rax+8]
    add       qword [rax],	2
L2944:
;---------------
    pop       rbp
    ret       
;End 
;Proc adddword
mc_genss.adddword:
;>>
    %define mc_genss.adddword.a 16
    %define mc_genss.adddword.x 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.adddword.a]
    mov       r10,	[rax+8]
    mov       eax,	[rbp + mc_genss.adddword.x]
    mov       [r10],	eax
    mov       rax,	[rbp + mc_genss.adddword.a]
    lea       rax,	[rax+8]
    add       qword [rax],	4
L2945:
;---------------
    pop       rbp
    ret       
;End 
;Proc addqword
mc_genss.addqword:
;>>
    %define mc_genss.addqword.a 16
    %define mc_genss.addqword.x 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.addqword.a]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_genss.addqword.x]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_genss.addqword.a]
    lea       rax,	[rax+8]
    add       qword [rax],	8
L2946:
;---------------
    pop       rbp
    ret       
;End 
;Proc genxrm
mc_genss.genxrm:
;>>
    %define mc_genss.genxrm.opcode 16
    %define mc_genss.genxrm.code 24
    %define mc_genss.genxrm.b 32
    %define mc_genss.genxrm.am -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mc_genss.genxrm.b]
    call      mc_genss.setopsize
    xor       ecx,	ecx
    mov       rdx,	[rbp + mc_genss.genxrm.code]
    mov       r8,	[rbp + mc_genss.genxrm.b]
    xor       r9d,	r9d
    call      mc_genss.genrm
    mov       [rbp + mc_genss.genxrm.am],	rax
    mov       rax,	[mc_genss.currmcl]
    movzx     r10,	byte [rax+24]
    cmp       r10,	13
    jz        L2949
    cmp       r10,	14
    jz        L2949
    jmp       L2950
L2949:
    and       byte [mc_genss.rex],	247
L2950:
L2948:
    mov       rax,	[rbp + mc_genss.genxrm.opcode]
    shr       rax,	16
    and       rax,	255
    test      rax,	rax
    jz        L2952
    mov       rax,	[rbp + mc_genss.genxrm.opcode]
    shr       rax,	16
    and       rax,	511
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2952:
L2951:
    call      mc_genss.genrex
    mov       rax,	[rbp + mc_genss.genxrm.opcode]
    shr       rax,	8
    and       rax,	255
    test      rax,	rax
    jz        L2954
    mov       rax,	[rbp + mc_genss.genxrm.opcode]
    shr       rax,	8
    and       rax,	255
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2954:
L2953:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.genxrm.opcode]
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.genxrm.b]
    mov       rdx,	[rbp + mc_genss.genxrm.am]
    call      mc_genss.genamode
L2947:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc genrrm
mc_genss.genrrm:
;>>
    %define mc_genss.genrrm.opcode 16
    %define mc_genss.genrrm.a 24
    %define mc_genss.genrrm.b 32
    %define mc_genss.genrrm.am -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.genrrm.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L2957
    mov       rax,	[rbp + mc_genss.genrrm.a]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_genss.ishighreg]
    movzx     r11,	byte [rax + r10-1]
    or        [mc_genss.rex],	r11b
L2957:
L2956:
    mov       rcx,	[rbp + mc_genss.genrrm.a]
    call      mc_genss.setopsize
    movzx     rax,	byte [mc_genss.usesizeb]
    test      rax,	rax
    jz        L2959
    and       byte [mc_genss.rex],	247
    mov       rax,	[rbp + mc_genss.genrrm.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L2961
    mov       al,	8
    or        [mc_genss.rex],	al
L2961:
L2960:
L2959:
L2958:
    mov       rax,	[rbp + mc_genss.genrrm.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	[rbp + mc_genss.genrrm.a]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    xor       edx,	edx
    mov       r8,	[rbp + mc_genss.genrrm.b]
    mov       r9,	r10
    call      mc_genss.genrm
    mov       [rbp + mc_genss.genrrm.am],	rax
    mov       rax,	[rbp + mc_genss.genrrm.opcode]
    shr       rax,	16
    and       rax,	255
    test      rax,	rax
    jz        L2963
    mov       rax,	[rbp + mc_genss.genrrm.opcode]
    shr       rax,	16
    and       rax,	511
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2963:
L2962:
    call      mc_genss.genrex
    mov       rax,	[rbp + mc_genss.genrrm.opcode]
    shr       rax,	8
    and       rax,	255
    test      rax,	rax
    jz        L2965
    mov       rax,	[rbp + mc_genss.genrrm.opcode]
    shr       rax,	8
    and       rax,	255
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L2965:
L2964:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.genrrm.opcode]
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.genrrm.b]
    mov       rdx,	[rbp + mc_genss.genrrm.am]
    call      mc_genss.genamode
L2955:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getregcode
mc_genss.getregcode:
;>>
    %define mc_genss.getregcode.reg 16
    %define mc_genss.getregcode.mask 24
    %define mc_genss.getregcode.isxreg 32
    %define mc_genss.getregcode.regcode -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.getregcode.isxreg]
    test      rax,	rax
    jnz       L2968
    lea       rax,	[mc_decls.regcodes]
    mov       r10,	[rbp + mc_genss.getregcode.reg]
    movzx     r11,	byte [rax + r10]
    mov       [rbp + mc_genss.getregcode.regcode],	r11
    jmp       L2967
L2968:
    mov       rax,	[rbp + mc_genss.getregcode.reg]
    sub       rax,	1
    mov       [rbp + mc_genss.getregcode.regcode],	rax
L2967:
    mov       rax,	[rbp + mc_genss.getregcode.regcode]
    cmp       rax,	8
    jl        L2970
    mov       rax,	8
    sub       [rbp + mc_genss.getregcode.regcode],	rax
    mov       al,	[rbp + mc_genss.getregcode.mask]
    or        [mc_genss.rex],	al
L2970:
L2969:
    mov       rax,	[rbp + mc_genss.getregcode.regcode]
L2966:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc checkimmrange
mc_genss.checkimmrange:
;>>
    %define mc_genss.checkimmrange.value 16
    %define mc_genss.checkimmrange.size 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.checkimmrange.size]
    cmp       rax,	1
    jz        L2973
    cmp       rax,	2
    jz        L2974
    jmp       L2975
L2973:
    mov       rax,	[rbp + mc_genss.checkimmrange.value]
    cmp       rax,	-128
    jl        L2978
    cmp       rax,	255
    jle       L2977
L2978:
    lea       rcx,	[rel L5808]
    call      mc_libmcl.axerror
L2977:
L2976:
    jmp       L2972
L2974:
    mov       rax,	[rbp + mc_genss.checkimmrange.value]
    cmp       rax,	-32768
    jl        L2981
    cmp       rax,	65535
    jle       L2980
L2981:
    lea       rcx,	[rel L5809]
    call      mc_libmcl.axerror
L2980:
L2979:
    jmp       L2972
L2975:
    mov       rax,	[rbp + mc_genss.checkimmrange.value]
    cmp       rax,	-2147483648
    jl        L2984
    mov       r10,	4294967295
    cmp       rax,	r10
    jle       L2983
L2984:
    lea       rcx,	[rel L5810]
    call      mc_libmcl.axerror
L2983:
L2982:
L2972:
L2971:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genrm
mc_genss.genrm:
;>>
    %define mc_genss.genrm.reg 16
    %define mc_genss.genrm.opc 24
    %define mc_genss.genrm.b 32
    %define mc_genss.genrm.isxreg 40
    %define mc_genss.genrm.mode -8
    %define mc_genss.genrm.rm -16
    %define mc_genss.genrm.scale -24
    %define mc_genss.genrm.index -32
    %define mc_genss.genrm.base -40
    %define mc_genss.genrm.regix -48
    %define mc_genss.genrm.code -56
    %define mc_genss.genrm.ismem -64
    %define mc_genss.genrm.am -72
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    lea       rax,	[rbp + mc_genss.genrm.am]
    xor       r10,	r10
    mov       [rax],	r10
    mov       rax,	[rbp + mc_genss.genrm.reg]
    test      rax,	rax
    jz        L2987
    mov       rcx,	[rbp + mc_genss.genrm.reg]
    mov       rdx,	4
    mov       r8,	[rbp + mc_genss.genrm.isxreg]
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.opc],	rax
L2987:
L2986:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L2989
    cmp       r10,	5
    jz        L2989
    cmp       r10,	3
    jz        L2990
    jmp       L2991
L2989:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	1
    mov       r8,	r10
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.rm],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_genss.ishighreg]
    movzx     r11,	byte [rax + r10-1]
    or        [mc_genss.rex],	r11b
    mov       rax,	[rbp + mc_genss.genrm.opc]
    shl       rax,	3
    mov       r10,	192
    add       r10,	rax
    add       r10,	[rbp + mc_genss.genrm.rm]
    mov       [rbp + mc_genss.genrm.am],	r10b
    mov       rax,	[rbp + mc_genss.genrm.am]
    jmp       L2985
L2990:
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.ismem],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	5
    jz        L2993
    cmp       r10,	3
    jz        L2994
    cmp       r10,	6
    jz        L2995
    jmp       L2996
L2993:
    mov       rax,	[rbp + mc_genss.genrm.b]
    mov       r10,	[rax]
    movzx     rax,	byte [r10+49]
    cmp       rax,	3
    jnz       L2998
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L2998:
L2997:
    jmp       L2992
L2994:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
    jmp       L2992
L2995:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L2996:
L2992:
    jmp       L2988
L2991:
    lea       rcx,	[rel L5811]
    call      mc_libmcl.axerror
L2988:
    xor       eax,	eax
    mov       [rbp + mc_genss.genrm.rm],	rax
    mov       [rbp + mc_genss.genrm.mode],	rax
    xor       eax,	eax
    mov       [rbp + mc_genss.genrm.scale],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	byte [rax+10]
    mov       [rbp + mc_genss.genrm.reg],	r10
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	byte [rax+11]
    mov       [rbp + mc_genss.genrm.regix],	r10
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	[rbp + mc_genss.genrm.reg]
    jnz       L3000
    cmp       rax,	0
    jnz       L3000
    xor       eax,	eax
    mov       [rbp + mc_genss.genrm.mode],	rax
    mov       rax,	4
    mov       [rbp + mc_genss.genrm.rm],	rax
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.scale],	rax
    mov       rax,	4
    mov       [rbp + mc_genss.genrm.index],	rax
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    jmp       L2999
L3000:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    cmp       r10,	1
    jg        L3001
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	0
    jnz       L3001
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jz        L3003
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3005
    mov       rax,	1
    jmp       L3004
L3005:
    mov       rax,	2
L3004:
    mov       [rbp + mc_genss.genrm.mode],	rax
L3003:
L3002:
    mov       rcx,	[rbp + mc_genss.genrm.reg]
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       [rbp + mc_genss.genrm.rm],	rax
    mov       rax,	[rbp + mc_genss.genrm.rm]
    cmp       rax,	4
    jz        L3007
    mov       rax,	[rbp + mc_genss.genrm.rm]
    cmp       rax,	5
    jnz       L3009
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	0
    jnz       L3009
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.mode],	rax
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3009:
L3008:
    xor       eax,	eax
    mov       [rbp + mc_genss.genrm.index],	rax
    jmp       L3006
L3007:
    mov       rax,	4
    mov       [rbp + mc_genss.genrm.index],	rax
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.scale],	rax
L3006:
    jmp       L2999
L3001:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3010
    mov       rax,	[rbp + mc_genss.genrm.reg]
    cmp       rax,	0
    jnz       L3010
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    xor       eax,	eax
    mov       [rbp + mc_genss.genrm.mode],	rax
    mov       rax,	4
    mov       [rbp + mc_genss.genrm.rm],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    test      r10,	r10
    jz        L3012
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    mov       rax,	r10
    jmp       L3011
L3012:
    mov       rax,	1
L3011:
    mov       [rbp + mc_genss.genrm.scale],	rax
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.index],	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3014
    lea       rcx,	[rel L5812]
    call      mc_libmcl.axerror
L3014:
L3013:
    jmp       L2999
L3010:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jz        L3016
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3018
    mov       rax,	1
    jmp       L3017
L3018:
    mov       rax,	2
L3017:
    mov       [rbp + mc_genss.genrm.mode],	rax
L3016:
L3015:
    mov       rax,	4
    mov       [rbp + mc_genss.genrm.rm],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    test      r10,	r10
    jz        L3020
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    mov       rax,	r10
    jmp       L3019
L3020:
    mov       rax,	1
L3019:
    mov       [rbp + mc_genss.genrm.scale],	rax
    mov       rax,	[rbp + mc_genss.genrm.reg]
    cmp       rax,	0
    jnz       L3022
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    jmp       L3021
L3022:
    mov       rax,	[rbp + mc_genss.genrm.reg]
    cmp       rax,	15
    jz        L3025
    cmp       rax,	8
    jnz       L3024
L3025:
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	0
    jnz       L3024
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.mode],	rax
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3024:
L3023:
    mov       rcx,	[rbp + mc_genss.genrm.reg]
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
L3021:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	0
    jnz       L3027
    mov       rax,	4
    mov       [rbp + mc_genss.genrm.index],	rax
    jmp       L3026
L3027:
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.index],	rax
    mov       rax,	[rbp + mc_genss.genrm.reg]
    test      rax,	rax
    jnz       L3029
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
L3029:
L3028:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3031
    mov       rax,	[rbp + mc_genss.genrm.scale]
    cmp       rax,	1
    jle       L3031
    lea       rcx,	[rel L5813]
    call      mc_libmcl.axerror
L3031:
L3030:
L3026:
L2999:
    mov       rax,	[rbp + mc_genss.genrm.scale]
    test      rax,	rax
    jz        L3033
    lea       rax,	[mc_genss.genrm.scaletable]
    mov       r10,	[rbp + mc_genss.genrm.scale]
    mov       r11,	[rax + r10*8-8]
    shl       r11,	6
    mov       rax,	[rbp + mc_genss.genrm.index]
    shl       rax,	3
    add       r11,	rax
    add       r11,	[rbp + mc_genss.genrm.base]
    mov       [rbp + mc_genss.genrm.am+1],	r11b
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+2],	al
L3033:
L3032:
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	4
    jnz       L3035
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    test      rax,	rax
    jz        L3035
    mov       rax,	[rbp + mc_genss.genrm.reg]
    test      rax,	rax
    jnz       L3038
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3037
L3038:
    movzx     rax,	byte [mc_decls.phighmem]
    cmp       rax,	2
    jnz       L3040
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    cmp       rax,	2
    jnz       L3040
    call      msys.m$print_startcon
    lea       rcx,	[rel L5814]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    mov       rcx,	[mc_genss.currmcl]
    call      mc_writenasm.strmclstr
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3040:
L3039:
    jmp       L3036
L3037:
    movzx     rax,	byte [mc_decls.phighmem]
    test      rax,	rax
    jz        L3041
    mov       al,	-1
    mov       [rbp + mc_genss.genrm.am+2],	al
    xor       eax,	eax
    mov       [rbp + mc_genss.genrm.mode],	rax
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.rm],	rax
L3041:
L3036:
L3035:
L3034:
    mov       rax,	[rbp + mc_genss.genrm.mode]
    shl       rax,	6
    mov       r10,	[rbp + mc_genss.genrm.opc]
    shl       r10,	3
    add       rax,	r10
    add       rax,	[rbp + mc_genss.genrm.rm]
    mov       [rbp + mc_genss.genrm.am],	al
    mov       rax,	[rbp + mc_genss.genrm.am]
L2985:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc do_arith
mc_genss.do_arith:
;>>
    %define mc_genss.do_arith.a 16
    %define mc_genss.do_arith.b 24
    %define mc_genss.do_arith.code 32
    %define mc_genss.do_arith.d -8
    %define mc_genss.do_arith.opc -16
    %define mc_genss.do_arith.dispsize -24
    %define mc_genss.do_arith.x -32
    %define mc_genss.do_arith.$T1 -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_arith.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3044
    cmp       r10,	3
    jz        L3045
    jmp       L3046
L3044:
    mov       rax,	[rbp + mc_genss.do_arith.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3048
    cmp       r10,	3
    jz        L3048
    cmp       r10,	2
    jz        L3049
    jmp       L3050
L3048:
    mov       rax,	[rbp + mc_genss.do_arith.code]
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    mov       rax,	[rbp + mc_genss.do_arith.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3052
    mov       rax,	2
    jmp       L3051
L3052:
    mov       rax,	3
L3051:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       [rbp + mc_genss.do_arith.opc],	r10
    mov       rcx,	[rbp + mc_genss.do_arith.opc]
    mov       rdx,	[rbp + mc_genss.do_arith.a]
    mov       r8,	[rbp + mc_genss.do_arith.b]
    call      mc_genss.genrrm
    jmp       L3047
L3049:
;doregimm:
L3053:
    mov       rcx,	[rbp + mc_genss.do_arith.b]
    xor       edx,	edx
    call      mc_genss.getdef
    mov       [rbp + mc_genss.do_arith.d],	rax
    mov       rax,	[rbp + mc_genss.do_arith.d]
    test      rax,	rax
    jz        L3055
    mov       rax,	[rbp + mc_genss.do_arith.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jge       L3057
    lea       rcx,	[rel L5815]
    call      mc_libmcl.axerror
L3057:
L3056:
    mov       rcx,	129
    mov       rdx,	[rbp + mc_genss.do_arith.code]
    mov       r8,	[rbp + mc_genss.do_arith.a]
    call      mc_genss.genxrm
    mov       rcx,	[rbp + mc_genss.do_arith.b]
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3042
L3055:
L3054:
    mov       rax,	[rbp + mc_genss.do_arith.b]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.do_arith.x],	r10
    mov       rax,	1
    mov       [rbp + mc_genss.do_arith.dispsize],	rax
    mov       rax,	[rbp + mc_genss.do_arith.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3059
    mov       rax,	128
    mov       [rbp + mc_genss.do_arith.opc],	rax
    mov       rcx,	[rbp + mc_genss.do_arith.x]
    mov       rdx,	1
    call      mc_genss.checkimmrange
    mov       rax,	[rbp + mc_genss.do_arith.x]
    cmp       rax,	-128
    jl        L3062
    cmp       rax,	255
    jle       L3061
L3062:
    lea       rcx,	[rel L5816]
    call      mc_libmcl.axerror
L3061:
L3060:
    jmp       L3058
L3059:
    mov       rax,	[rbp + mc_genss.do_arith.x]
    cmp       rax,	-128
    jl        L3063
    cmp       rax,	127
    jg        L3063
    mov       rax,	131
    mov       [rbp + mc_genss.do_arith.opc],	rax
    jmp       L3058
L3063:
    mov       rcx,	[rbp + mc_genss.do_arith.x]
    mov       rdx,	4
    call      mc_genss.checkimmrange
    mov       rax,	129
    mov       [rbp + mc_genss.do_arith.opc],	rax
    mov       rax,	[rbp + mc_genss.do_arith.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	2
    jnz       L3065
    mov       rax,	2
    jmp       L3064
L3065:
    mov       rax,	4
L3064:
    mov       [rbp + mc_genss.do_arith.dispsize],	rax
L3058:
    mov       rcx,	[rbp + mc_genss.do_arith.opc]
    mov       rdx,	[rbp + mc_genss.do_arith.code]
    mov       r8,	[rbp + mc_genss.do_arith.a]
    call      mc_genss.genxrm
    mov       rax,	[rbp + mc_genss.do_arith.dispsize]
    cmp       rax,	1
    jz        L3067
    cmp       rax,	2
    jz        L3068
    cmp       rax,	4
    jz        L3069
    jmp       L3070
L3067:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_arith.x]
    mov       [r10],	al
    jmp       L3066
L3068:
    mov       rcx,	[rbp + mc_genss.do_arith.x]
    call      mc_genss.genword
    jmp       L3066
L3069:
    mov       rcx,	[rbp + mc_genss.do_arith.x]
    call      mc_genss.gendword
L3070:
L3066:
    mov       rcx,	[rbp + mc_genss.do_arith.dispsize]
    call      mc_genss.fixrip
    jmp       L3047
L3050:
    lea       rcx,	[rel L5817]
    call      mc_libmcl.axerror
L3047:
    jmp       L3043
L3045:
    mov       rax,	[rbp + mc_genss.do_arith.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3072
    cmp       r10,	2
    jz        L3073
    jmp       L3074
L3072:
    mov       rax,	[rbp + mc_genss.do_arith.code]
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    mov       rax,	[rbp + mc_genss.do_arith.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3076
    xor       eax,	eax
    jmp       L3075
L3076:
    mov       rax,	1
L3075:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       [rbp + mc_genss.do_arith.opc],	r10
    mov       rcx,	[rbp + mc_genss.do_arith.opc]
    mov       rdx,	[rbp + mc_genss.do_arith.b]
    mov       r8,	[rbp + mc_genss.do_arith.a]
    call      mc_genss.genrrm
    jmp       L3071
L3073:
    jmp       L3053
L3074:
    lea       rcx,	[rel L5818]
    call      mc_libmcl.axerror
L3071:
    jmp       L3043
L3046:
    call      msys.m$print_startcon
    lea       rax,	[mc_decls.opndnames_ma]
    mov       r10,	[rbp + mc_genss.do_arith.code]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5819]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_genss.do_arith.code]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5820]
    call      mc_libmcl.axerror
L3043:
L3042:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc do_mov
mc_genss.do_mov:
;>>
    %define mc_genss.do_mov.a 16
    %define mc_genss.do_mov.b 24
    %define mc_genss.do_mov.regcode -8
    %define mc_genss.do_mov.opc -16
    %define mc_genss.do_mov.dispsize -24
    %define mc_genss.do_mov.value -32
    %define mc_genss.do_mov.d -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_genss.do_mov.b]
    xor       edx,	edx
    call      mc_genss.getdef
    mov       [rbp + mc_genss.do_mov.d],	rax
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3079
    cmp       r10,	3
    jz        L3080
    jmp       L3081
L3079:
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3083
    cmp       r10,	3
    jz        L3083
    cmp       r10,	2
    jz        L3084
    jmp       L3085
L3083:
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L3087
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    test      r10,	r10
    jz        L3087
    call      msys.m$print_startcon
    mov       rax,	[mc_decls.currasmproc]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L5821]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    lea       rcx,	[rel L5822]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5823]
    call      mc_libmcl.axerror
L3087:
L3086:
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3089
    mov       rax,	138
    jmp       L3088
L3089:
    mov       rax,	139
L3088:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_mov.a]
    mov       r8,	[rbp + mc_genss.do_mov.b]
    call      mc_genss.genrrm
    jmp       L3082
L3084:
    mov       rax,	[rbp + mc_genss.do_mov.b]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.do_mov.value],	r10
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.do_mov.regcode],	rax
    mov       rcx,	[rbp + mc_genss.do_mov.a]
    call      mc_genss.setopsize
    mov       rax,	[rbp + mc_genss.do_mov.d]
    test      rax,	rax
    jz        L3091
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	2
    jg        L3091
    lea       rcx,	[rel L5824]
    call      mc_libmcl.axerror
L3091:
L3090:
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3093
    cmp       r10,	2
    jz        L3094
    cmp       r10,	4
    jz        L3095
    jmp       L3096
L3093:
    mov       rax,	[rbp + mc_genss.do_mov.value]
    cmp       rax,	-128
    jl        L3099
    cmp       rax,	255
    jle       L3098
L3099:
    lea       rcx,	[rel L5825]
    call      mc_libmcl.axerror
L3098:
L3097:
    call      mc_genss.genrex
    mov       rax,	176
    add       rax,	[rbp + mc_genss.do_mov.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_mov.value]
    mov       [r10],	al
    jmp       L3092
L3094:
    mov       rax,	[rbp + mc_genss.do_mov.value]
    cmp       rax,	-32768
    jl        L3102
    cmp       rax,	65535
    jle       L3101
L3102:
    lea       rcx,	[rel L5826]
    call      mc_libmcl.axerror
L3101:
L3100:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	[rbp + mc_genss.do_mov.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    call      mc_genss.genword
    jmp       L3092
L3095:
    mov       rax,	[rbp + mc_genss.do_mov.d]
    test      rax,	rax
    jz        L3104
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	[rbp + mc_genss.do_mov.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.do_mov.b]
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3103
L3104:
    mov       rax,	[rbp + mc_genss.do_mov.value]
    cmp       rax,	-2147483648
    jl        L3107
    mov       r10d,	4294967295
    mov       r10d,	r10d
    cmp       rax,	r10
    jle       L3106
L3107:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    call      msys.m$print_ptr_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5827]
    call      mc_libmcl.axerror
L3106:
L3105:
;doreg32:
L3108:
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	[rbp + mc_genss.do_mov.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    call      mc_genss.gendword
L3103:
    jmp       L3092
L3096:
    mov       rax,	[rbp + mc_genss.do_mov.d]
    test      rax,	rax
    jz        L3110
    mov       al,	8
    or        [mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	[rbp + mc_genss.do_mov.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.do_mov.b]
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3109
L3110:
    mov       rax,	[rbp + mc_genss.do_mov.value]
    cmp       rax,	0
    jl        L3112
    mov       rax,	[rbp + mc_genss.do_mov.value]
    mov       r10,	4294967295
    cmp       rax,	r10
    jg        L3112
    and       byte [mc_genss.rex],	247
    jmp       L3108
L3112:
L3111:
    mov       al,	8
    or        [mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	[rbp + mc_genss.do_mov.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    call      mc_genss.genqword
L3109:
L3092:
    jmp       L3082
L3085:
    lea       rcx,	[rel L5828]
    call      mc_libmcl.axerror
L3082:
    jmp       L3078
L3080:
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3114
    cmp       r10,	2
    jz        L3115
    jmp       L3116
L3114:
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3118
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_mov.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3118:
L3117:
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L3120
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    test      r10,	r10
    jz        L3120
    lea       rcx,	[rel L5829]
    call      mc_libmcl.axerror
L3120:
L3119:
    mov       rax,	[rbp + mc_genss.do_mov.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3122
    mov       rax,	136
    jmp       L3121
L3122:
    mov       rax,	137
L3121:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_mov.b]
    mov       r8,	[rbp + mc_genss.do_mov.a]
    call      mc_genss.genrrm
    jmp       L3113
L3115:
    mov       rax,	[rbp + mc_genss.do_mov.b]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.do_mov.value],	r10
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3124
    mov       rax,	[rbp + mc_genss.do_mov.a]
    lea       rax,	[rax+8]
    mov       r10w,	1
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3124:
L3123:
    mov       rax,	[rbp + mc_genss.do_mov.d]
    test      rax,	rax
    jz        L3126
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	2
    jg        L3126
    lea       rcx,	[rel L5830]
    call      mc_libmcl.axerror
L3126:
L3125:
    mov       rcx,	[rbp + mc_genss.do_mov.a]
    call      mc_genss.setopsize
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3128
    mov       rax,	198
    jmp       L3127
L3128:
    mov       rax,	199
L3127:
    mov       [rbp + mc_genss.do_mov.opc],	rax
    mov       rax,	[rbp + mc_genss.do_mov.d]
    test      rax,	rax
    jnz       L3130
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    mov       rdx,	r10
    call      mc_genss.checkimmrange
L3130:
L3129:
    mov       rcx,	[rbp + mc_genss.do_mov.opc]
    xor       edx,	edx
    mov       r8,	[rbp + mc_genss.do_mov.a]
    call      mc_genss.genxrm
    mov       rax,	[rbp + mc_genss.do_mov.b]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.do_mov.value],	r10
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       [rbp + mc_genss.do_mov.dispsize],	r10
    mov       rax,	[rbp + mc_genss.do_mov.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3132
    cmp       r10,	2
    jz        L3133
    cmp       r10,	4
    jz        L3134
    cmp       r10,	8
    jz        L3134
    jmp       L3135
L3132:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_mov.value]
    mov       [r10],	al
    jmp       L3131
L3133:
    mov       rcx,	[rbp + mc_genss.do_mov.value]
    call      mc_genss.genword
    jmp       L3131
L3134:
    mov       rcx,	[rbp + mc_genss.do_mov.b]
    mov       rdx,	4
    call      mc_genss.genopnd
    mov       rax,	4
    mov       [rbp + mc_genss.do_mov.dispsize],	rax
L3135:
L3131:
    mov       rcx,	[rbp + mc_genss.do_mov.dispsize]
    call      mc_genss.fixrip
    jmp       L3113
L3116:
    lea       rcx,	[rel L5831]
    call      mc_libmcl.axerror
L3113:
    jmp       L3078
L3081:
    lea       rcx,	[rel L5832]
    call      mc_libmcl.axerror
L3078:
L3077:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc do_push
mc_genss.do_push:
;>>
    %define mc_genss.do_push.a 16
    %define mc_genss.do_push.code -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.do_push.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3138
    mov       rax,	[rbp + mc_genss.do_push.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3138:
L3137:
    mov       rax,	[rbp + mc_genss.do_push.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3140
    cmp       r10,	2
    jz        L3141
    cmp       r10,	3
    jz        L3142
    jmp       L3143
L3140:
    mov       rax,	[rbp + mc_genss.do_push.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jz        L3145
    lea       rcx,	[rel L5833]
    call      mc_libmcl.axerror
L3145:
L3144:
    mov       rax,	[rbp + mc_genss.do_push.a]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.do_push.code],	rax
    and       byte [mc_genss.rex],	247
    call      mc_genss.genrex
    mov       rax,	80
    add       rax,	[rbp + mc_genss.do_push.code]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3139
L3141:
    mov       rcx,	[rbp + mc_genss.do_push.a]
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3147
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_push.a]
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3146
L3147:
    mov       rax,	[rbp + mc_genss.do_push.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3148
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	106
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.do_push.a]
    mov       r10,	[rax]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3146
L3148:
    mov       rax,	[rbp + mc_genss.do_push.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.isdwordsized
    test      rax,	rax
    jz        L3149
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	104
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.do_push.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L3146
L3149:
    lea       rcx,	[rel L5834]
    call      mc_libmcl.axerror
L3146:
    jmp       L3139
L3142:
    mov       rax,	[rbp + mc_genss.do_push.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jz        L3151
    lea       rcx,	[rel L5835]
    call      mc_libmcl.axerror
L3151:
L3150:
    mov       rcx,	255
    mov       rdx,	6
    mov       r8,	[rbp + mc_genss.do_push.a]
    call      mc_genss.genxrm
    jmp       L3139
L3143:
    lea       rcx,	[rel L5836]
    call      mc_libmcl.axerror
L3139:
L3136:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_pop
mc_genss.do_pop:
;>>
    %define mc_genss.do_pop.a 16
    %define mc_genss.do_pop.code -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.do_pop.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3154
    mov       rax,	[rbp + mc_genss.do_pop.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3154:
L3153:
    mov       rax,	[rbp + mc_genss.do_pop.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3156
    cmp       r10,	3
    jz        L3157
    jmp       L3158
L3156:
    mov       rax,	[rbp + mc_genss.do_pop.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jz        L3160
    lea       rcx,	[rel L5837]
    call      mc_libmcl.axerror
L3160:
L3159:
    mov       rax,	[rbp + mc_genss.do_pop.a]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.do_pop.code],	rax
    call      mc_genss.genrex
    mov       rax,	88
    add       rax,	[rbp + mc_genss.do_pop.code]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3155
L3157:
    mov       rax,	[rbp + mc_genss.do_pop.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jz        L3162
    lea       rcx,	[rel L5838]
    call      mc_libmcl.axerror
L3162:
L3161:
    mov       rcx,	143
    xor       edx,	edx
    mov       r8,	[rbp + mc_genss.do_pop.a]
    call      mc_genss.genxrm
    jmp       L3155
L3158:
    lea       rcx,	[rel L5839]
    call      mc_libmcl.axerror
L3155:
L3152:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_inc
mc_genss.do_inc:
;>>
    %define mc_genss.do_inc.a 16
    %define mc_genss.do_inc.code 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_inc.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3165
    cmp       r10,	3
    jz        L3165
    jmp       L3166
L3165:
    mov       rax,	[rbp + mc_genss.do_inc.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3168
    mov       rax,	254
    jmp       L3167
L3168:
    mov       rax,	255
L3167:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_inc.code]
    mov       r8,	[rbp + mc_genss.do_inc.a]
    call      mc_genss.genxrm
    jmp       L3164
L3166:
    lea       rcx,	[rel L5840]
    call      mc_libmcl.axerror
L3164:
L3163:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_neg
mc_genss.do_neg:
;>>
    %define mc_genss.do_neg.a 16
    %define mc_genss.do_neg.code 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_neg.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3171
    cmp       r10,	3
    jz        L3171
    jmp       L3172
L3171:
    mov       rax,	[rbp + mc_genss.do_neg.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3174
    mov       rax,	246
    jmp       L3173
L3174:
    mov       rax,	247
L3173:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_neg.code]
    mov       r8,	[rbp + mc_genss.do_neg.a]
    call      mc_genss.genxrm
    jmp       L3170
L3172:
    lea       rcx,	[rel L5841]
    call      mc_libmcl.axerror
L3170:
L3169:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_lea
mc_genss.do_lea:
;>>
    %define mc_genss.do_lea.a 16
    %define mc_genss.do_lea.b 24
    %define mc_genss.do_lea.regcode -8
    %define mc_genss.do_lea.am -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_lea.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3178
    mov       rax,	[rbp + mc_genss.do_lea.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3177
L3178:
    lea       rcx,	[rel L5842]
    call      mc_libmcl.axerror
L3177:
L3176:
    mov       rax,	[rbp + mc_genss.do_lea.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jge       L3180
    lea       rcx,	[rel L5843]
    call      mc_libmcl.axerror
L3180:
L3179:
    mov       rcx,	141
    mov       rdx,	[rbp + mc_genss.do_lea.a]
    mov       r8,	[rbp + mc_genss.do_lea.b]
    call      mc_genss.genrrm
L3175:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_movsx
mc_genss.do_movsx:
;>>
    %define mc_genss.do_movsx.a 16
    %define mc_genss.do_movsx.b 24
    %define mc_genss.do_movsx.opc 32
    %define mc_genss.do_movsx.am -8
    %define mc_genss.do_movsx.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_movsx.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3183
    lea       rcx,	[rel L5844]
    call      mc_libmcl.axerror
L3183:
L3182:
    mov       rax,	[rbp + mc_genss.do_movsx.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L3185
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jnz       L3185
    mov       rax,	[rbp + mc_genss.do_movsx.opc]
    cmp       rax,	190
    jnz       L3187
    mov       rcx,	[rbp + mc_genss.do_movsx.a]
    mov       rdx,	[rbp + mc_genss.do_movsx.b]
    call      mc_genss.do_movsxd
    jmp       L3186
L3187:
    mov       rax,	[rbp + mc_genss.do_movsx.a]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_decls.regtable]
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    mov       r10,	[rax+24]
    mov       [rbp + mc_genss.do_movsx.a],	r10
    mov       rcx,	[rbp + mc_genss.do_movsx.a]
    mov       rdx,	[rbp + mc_genss.do_movsx.b]
    call      mc_genss.do_mov
L3186:
    jmp       L3181
L3185:
L3184:
    mov       rax,	[rbp + mc_genss.do_movsx.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3190
    mov       rax,	[rbp + mc_genss.do_movsx.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    ja        L3189
L3190:
    lea       rcx,	[rel L5845]
    call      mc_libmcl.axerror
L3189:
L3188:
    mov       rax,	[rbp + mc_genss.do_movsx.opc]
    cmp       rax,	182
    jnz       L3192
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jnz       L3192
    lea       rcx,	[rel L5846]
    call      mc_libmcl.axerror
L3192:
L3191:
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3194
    cmp       r10,	3
    jz        L3195
    jmp       L3196
L3194:
    jmp       L3193
L3195:
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3198
    lea       rcx,	[rel L5847]
    call      mc_libmcl.axerror
L3198:
L3197:
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L3200
    lea       rcx,	[rel L5848]
    call      mc_libmcl.axerror
L3200:
L3199:
    jmp       L3193
L3196:
    lea       rcx,	[rel L5849]
    call      mc_libmcl.axerror
L3193:
    mov       rax,	[rbp + mc_genss.do_movsx.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3202
    mov       rax,	[rbp + mc_genss.do_movsx.opc]
    jmp       L3201
L3202:
    mov       rax,	[rbp + mc_genss.do_movsx.opc]
    add       rax,	1
L3201:
    mov       r10,	3840
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_genss.do_movsx.a]
    mov       r8,	[rbp + mc_genss.do_movsx.b]
    call      mc_genss.genrrm
L3181:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_exch
mc_genss.do_exch:
;>>
    %define mc_genss.do_exch.a 16
    %define mc_genss.do_exch.b 24
    %define mc_genss.do_exch.regcode -8
    %define mc_genss.do_exch.am -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3205
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3205
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	byte [rax+10]
    cmp       r10,	1
    jz        L3206
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	byte [rax+10]
    cmp       r10,	1
    jnz       L3205
L3206:
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3205
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	byte [rax+10]
    cmp       r10,	1
    jz        L3208
    mov       rax,	[rbp + mc_genss.do_exch.a]
    mov       r10,	[rbp + mc_genss.do_exch.b]
    mov       [rbp + mc_genss.do_exch.b],	rax
    mov       [rbp + mc_genss.do_exch.a],	r10
L3208:
L3207:
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L3210
    lea       rcx,	[rel L5850]
    call      mc_libmcl.axerror
L3210:
L3209:
    mov       rcx,	[rbp + mc_genss.do_exch.a]
    call      mc_genss.setopsize
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.do_exch.regcode],	rax
    call      mc_genss.genrex
    mov       rax,	144
    add       rax,	[rbp + mc_genss.do_exch.regcode]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3203
L3205:
L3204:
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L3212
    mov       rax,	[rbp + mc_genss.do_exch.a]
    mov       r10,	[rbp + mc_genss.do_exch.b]
    mov       [rbp + mc_genss.do_exch.b],	rax
    mov       [rbp + mc_genss.do_exch.a],	r10
L3212:
L3211:
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3215
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3214
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3214
L3215:
    lea       rcx,	[rel L5851]
    call      mc_libmcl.axerror
L3214:
L3213:
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3217
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L3217
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_exch.b]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3217:
L3216:
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_exch.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L3219
    lea       rcx,	[rel L5852]
    call      mc_libmcl.axerror
L3219:
L3218:
    mov       rax,	[rbp + mc_genss.do_exch.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3221
    mov       rax,	134
    jmp       L3220
L3221:
    mov       rax,	135
L3220:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_exch.a]
    mov       r8,	[rbp + mc_genss.do_exch.b]
    call      mc_genss.genrrm
L3203:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_movsxd
mc_genss.do_movsxd:
;>>
    %define mc_genss.do_movsxd.a 16
    %define mc_genss.do_movsxd.b 24
    %define mc_genss.do_movsxd.regcode -8
    %define mc_genss.do_movsxd.am -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_movsxd.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L3224
    mov       rax,	[rbp + mc_genss.do_movsxd.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3224
    mov       rax,	[rbp + mc_genss.do_movsxd.b]
    lea       rax,	[rax+8]
    mov       r10w,	4
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3224:
L3223:
    mov       rax,	[rbp + mc_genss.do_movsxd.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L3227
    mov       rax,	[rbp + mc_genss.do_movsxd.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jle       L3226
L3227:
    lea       rcx,	[rel L5853]
    call      mc_libmcl.axerror
L3226:
L3225:
    mov       rax,	[rbp + mc_genss.do_movsxd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3230
    mov       rax,	[rbp + mc_genss.do_movsxd.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3229
    mov       rax,	[rbp + mc_genss.do_movsxd.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3229
L3230:
    lea       rcx,	[rel L5854]
    call      mc_libmcl.axerror
L3229:
L3228:
    mov       rcx,	99
    mov       rdx,	[rbp + mc_genss.do_movsxd.a]
    mov       r8,	[rbp + mc_genss.do_movsxd.b]
    call      mc_genss.genrrm
L3222:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_imul2
mc_genss.do_imul2:
;>>
    %define mc_genss.do_imul2.a 16
    %define mc_genss.do_imul2.b 24
    %define mc_genss.do_imul2.regcode -8
    %define mc_genss.do_imul2.am -16
    %define mc_genss.do_imul2.opc -24
    %define mc_genss.do_imul2.dispsize -32
    %define mc_genss.do_imul2.value -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_imul2.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3233
    lea       rcx,	[rel L5855]
    call      mc_libmcl.axerror
L3233:
L3232:
    mov       rax,	[rbp + mc_genss.do_imul2.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3235
    mov       rax,	[rbp + mc_genss.do_imul2.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_imul2.b]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3235:
L3234:
    mov       rax,	[rbp + mc_genss.do_imul2.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3237
    lea       rcx,	[rel L5856]
    call      mc_libmcl.axerror
L3237:
L3236:
    mov       rax,	[rbp + mc_genss.do_imul2.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3239
    cmp       r10,	3
    jz        L3239
    cmp       r10,	2
    jz        L3240
    jmp       L3241
L3239:
    mov       rax,	[rbp + mc_genss.do_imul2.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_imul2.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jz        L3243
    lea       rcx,	[rel L5857]
    call      mc_libmcl.axerror
L3243:
L3242:
    mov       rcx,	4015
    mov       rdx,	[rbp + mc_genss.do_imul2.a]
    mov       r8,	[rbp + mc_genss.do_imul2.b]
    call      mc_genss.genrrm
    jmp       L3238
L3240:
    mov       rcx,	[rbp + mc_genss.do_imul2.b]
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3245
    lea       rcx,	[rel L5858]
    call      mc_libmcl.axerror
L3245:
L3244:
    mov       rax,	[rbp + mc_genss.do_imul2.b]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.do_imul2.value],	r10
    mov       rax,	[rbp + mc_genss.do_imul2.value]
    cmp       rax,	-128
    jl        L3247
    cmp       rax,	127
    jg        L3247
    mov       rax,	107
    mov       [rbp + mc_genss.do_imul2.opc],	rax
    jmp       L3246
L3247:
    mov       rax,	105
    mov       [rbp + mc_genss.do_imul2.opc],	rax
L3246:
    mov       rcx,	[rbp + mc_genss.do_imul2.opc]
    mov       rdx,	[rbp + mc_genss.do_imul2.a]
    mov       r8,	[rbp + mc_genss.do_imul2.a]
    call      mc_genss.genrrm
    mov       rax,	[rbp + mc_genss.do_imul2.value]
    cmp       rax,	-128
    jl        L3249
    cmp       rax,	127
    jg        L3249
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_imul2.value]
    mov       [r10],	al
    mov       rax,	1
    mov       [rbp + mc_genss.do_imul2.dispsize],	rax
    jmp       L3248
L3249:
    mov       rax,	[rbp + mc_genss.do_imul2.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	2
    jnz       L3250
    mov       rcx,	[rbp + mc_genss.do_imul2.value]
    call      mc_genss.genword
    mov       rax,	2
    mov       [rbp + mc_genss.do_imul2.dispsize],	rax
    jmp       L3248
L3250:
    mov       rcx,	[rbp + mc_genss.do_imul2.value]
    call      mc_genss.gendword
    mov       rax,	4
    mov       [rbp + mc_genss.do_imul2.dispsize],	rax
L3248:
    mov       rcx,	[rbp + mc_genss.do_imul2.dispsize]
    call      mc_genss.fixrip
    jmp       L3238
L3241:
    lea       rcx,	[rel L5859]
    call      mc_libmcl.axerror
L3238:
L3231:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc do_shift
mc_genss.do_shift:
;>>
    %define mc_genss.do_shift.a 16
    %define mc_genss.do_shift.b 24
    %define mc_genss.do_shift.code 32
    %define mc_genss.do_shift.w -8
    %define mc_genss.do_shift.opc -16
    %define mc_genss.do_shift.needdisp -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_shift.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3253
    mov       rax,	[rbp + mc_genss.do_shift.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3253
    lea       rcx,	[rel L5860]
    call      mc_libmcl.axerror
L3253:
L3252:
    mov       rcx,	[rbp + mc_genss.do_shift.b]
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3255
    lea       rcx,	[rel L5861]
    call      mc_libmcl.axerror
L3255:
L3254:
    mov       rax,	[rbp + mc_genss.do_shift.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3257
    xor       eax,	eax
    jmp       L3256
L3257:
    mov       rax,	1
L3256:
    mov       [rbp + mc_genss.do_shift.w],	rax
    xor       eax,	eax
    mov       [rbp + mc_genss.do_shift.needdisp],	rax
    mov       rax,	[rbp + mc_genss.do_shift.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jz        L3259
    cmp       r10,	1
    jz        L3260
    jmp       L3261
L3259:
    mov       rax,	[rbp + mc_genss.do_shift.b]
    mov       r10,	[rax]
    cmp       r10,	1
    jnz       L3263
    mov       rax,	208
    add       rax,	[rbp + mc_genss.do_shift.w]
    mov       [rbp + mc_genss.do_shift.opc],	rax
    jmp       L3262
L3263:
    mov       rax,	192
    add       rax,	[rbp + mc_genss.do_shift.w]
    mov       [rbp + mc_genss.do_shift.opc],	rax
    mov       rax,	1
    mov       [rbp + mc_genss.do_shift.needdisp],	rax
L3262:
    jmp       L3258
L3260:
    mov       rax,	[rbp + mc_genss.do_shift.b]
    movzx     r10,	byte [rax+10]
    cmp       r10,	11
    jnz       L3266
    mov       rax,	[rbp + mc_genss.do_shift.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3265
L3266:
    lea       rcx,	[rel L5862]
    call      mc_libmcl.axerror
L3265:
L3264:
    mov       rax,	210
    add       rax,	[rbp + mc_genss.do_shift.w]
    mov       [rbp + mc_genss.do_shift.opc],	rax
    jmp       L3258
L3261:
    lea       rcx,	[rel L5863]
    call      mc_libmcl.axerror
L3258:
    mov       rcx,	[rbp + mc_genss.do_shift.opc]
    mov       rdx,	[rbp + mc_genss.do_shift.code]
    mov       r8,	[rbp + mc_genss.do_shift.a]
    call      mc_genss.genxrm
    mov       rax,	[rbp + mc_genss.do_shift.needdisp]
    test      rax,	rax
    jz        L3268
    mov       rax,	[rbp + mc_genss.do_shift.b]
    mov       r10,	[rax]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rcx,	1
    call      mc_genss.fixrip
L3268:
L3267:
L3251:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc do_test
mc_genss.do_test:
;>>
    %define mc_genss.do_test.a 16
    %define mc_genss.do_test.b 24
    %define mc_genss.do_test.value -8
    %define mc_genss.do_test.opc -16
    %define mc_genss.do_test.am -24
    %define mc_genss.do_test.regcode -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3271
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	byte [rax+10]
    cmp       r10,	1
    jnz       L3271
    mov       rax,	[rbp + mc_genss.do_test.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jnz       L3271
    mov       rax,	[rbp + mc_genss.do_test.b]
    mov       r10,	[rax]
    mov       [rbp + mc_genss.do_test.value],	r10
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3273
    cmp       r10,	2
    jz        L3274
    cmp       r10,	4
    jz        L3275
    jmp       L3276
L3273:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	168
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_test.value]
    mov       [r10],	al
    jmp       L3272
L3274:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_test.value]
    call      mc_genss.genword
    jmp       L3272
L3275:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_test.value]
    call      mc_genss.gendword
    jmp       L3272
L3276:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	[rbp + mc_genss.do_test.value]
    call      mc_genss.gendword
L3272:
    jmp       L3270
L3271:
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3278
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L3277
L3278:
    mov       rax,	[rbp + mc_genss.do_test.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jnz       L3277
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3280
    mov       rax,	246
    jmp       L3279
L3280:
    mov       rax,	247
L3279:
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	[rbp + mc_genss.do_test.a]
    call      mc_genss.genxrm
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jz        L3282
    cmp       r10,	2
    jz        L3283
    jmp       L3284
L3282:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_test.value]
    mov       [r10],	al
    jmp       L3281
L3283:
    mov       rcx,	[rbp + mc_genss.do_test.value]
    call      mc_genss.genword
    jmp       L3281
L3284:
    mov       rcx,	[rbp + mc_genss.do_test.value]
    call      mc_genss.gendword
L3281:
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	r10
    call      mc_genss.fixrip
    jmp       L3270
L3277:
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3286
    cmp       r10,	3
    jnz       L3285
L3286:
    mov       rax,	[rbp + mc_genss.do_test.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3285
;domemreg:
L3287:
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jnz       L3289
    mov       rax,	132
    jmp       L3288
L3289:
    mov       rax,	133
L3288:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_test.a]
    mov       r8,	[rbp + mc_genss.do_test.b]
    call      mc_genss.genrrm
    jmp       L3270
L3285:
    mov       rax,	[rbp + mc_genss.do_test.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3290
    mov       rax,	[rbp + mc_genss.do_test.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L3290
    mov       rax,	[rbp + mc_genss.do_test.a]
    mov       r10,	[rbp + mc_genss.do_test.b]
    mov       [rbp + mc_genss.do_test.b],	rax
    mov       [rbp + mc_genss.do_test.a],	r10
    jmp       L3287
L3290:
    lea       rcx,	[rel L5864]
    call      mc_libmcl.axerror
L3270:
L3269:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc do_setcc
mc_genss.do_setcc:
;>>
    %define mc_genss.do_setcc.cond 16
    %define mc_genss.do_setcc.b 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_genss.do_setcc.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3295
    cmp       r10,	3
    jnz       L3294
L3295:
    mov       rax,	[rbp + mc_genss.do_setcc.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jle       L3293
L3294:
    lea       rcx,	[rel L5865]
    call      mc_libmcl.axerror
L3293:
L3292:
    mov       rax,	3984
    add       rax,	[rbp + mc_genss.do_setcc.cond]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	[rbp + mc_genss.do_setcc.b]
    call      mc_genss.genxrm
L3291:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc checksize
mc_genss.checksize:
;>>
    %define mc_genss.checksize.a 16
    %define mc_genss.checksize.size1 24
    %define mc_genss.checksize.size2 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.checksize.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3298
    lea       rcx,	[rel L5866]
    call      mc_libmcl.axerror
L3298:
L3297:
    mov       rax,	[rbp + mc_genss.checksize.size1]
    test      rax,	rax
    jz        L3300
    mov       rax,	[rbp + mc_genss.checksize.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	[rbp + mc_genss.checksize.size1]
    jz        L3300
    cmp       r10,	[rbp + mc_genss.checksize.size2]
    jz        L3300
    call      msys.m$print_startcon
    lea       rcx,	[rel L5867]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.checksize.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5868]
    call      mc_libmcl.axerror
L3300:
L3299:
L3296:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_arithxmm
mc_genss.do_arithxmm:
;>>
    %define mc_genss.do_arithxmm.a 16
    %define mc_genss.do_arithxmm.b 24
    %define mc_genss.do_arithxmm.prefix 32
    %define mc_genss.do_arithxmm.opc 40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mc_genss.do_arithxmm.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3304
    mov       rax,	[rbp + mc_genss.do_arithxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3303
    mov       rax,	[rbp + mc_genss.do_arithxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3303
L3304:
    lea       rcx,	[rel L5869]
    call      mc_libmcl.axerror
L3303:
L3302:
    mov       rax,	[rbp + mc_genss.do_arithxmm.prefix]
    test      rax,	rax
    jz        L3306
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_arithxmm.prefix]
    mov       [r10],	al
L3306:
L3305:
    mov       rax,	3840
    add       rax,	[rbp + mc_genss.do_arithxmm.opc]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_arithxmm.a]
    mov       r8,	[rbp + mc_genss.do_arithxmm.b]
    call      mc_genss.genrrm
L3301:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_logicxmm
mc_genss.do_logicxmm:
;>>
    %define mc_genss.do_logicxmm.a 16
    %define mc_genss.do_logicxmm.b 24
    %define mc_genss.do_logicxmm.opc 32
    %define mc_genss.do_logicxmm.size 40
    %define mc_genss.do_logicxmm.am -8
    %define mc_genss.do_logicxmm.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mc_genss.do_logicxmm.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3310
    mov       rax,	[rbp + mc_genss.do_logicxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3309
    mov       rax,	[rbp + mc_genss.do_logicxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3309
L3310:
    lea       rcx,	[rel L5870]
    call      mc_libmcl.axerror
L3309:
L3308:
    mov       rax,	[rbp + mc_genss.do_logicxmm.size]
    cmp       rax,	8
    jnz       L3312
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
L3312:
L3311:
    mov       rax,	3840
    add       rax,	[rbp + mc_genss.do_logicxmm.opc]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_logicxmm.a]
    mov       r8,	[rbp + mc_genss.do_logicxmm.b]
    call      mc_genss.genrrm
L3307:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_convertfloat
mc_genss.do_convertfloat:
;>>
    %define mc_genss.do_convertfloat.a 16
    %define mc_genss.do_convertfloat.b 24
    %define mc_genss.do_convertfloat.prefix 32
    %define mc_genss.do_convertfloat.am -8
    %define mc_genss.do_convertfloat.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_convertfloat.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3316
    mov       rax,	[rbp + mc_genss.do_convertfloat.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3315
    mov       rax,	[rbp + mc_genss.do_convertfloat.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3315
L3316:
    lea       rcx,	[rel L5871]
    call      mc_libmcl.axerror
L3315:
L3314:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_convertfloat.prefix]
    mov       [r10],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3930
    mov       rdx,	[rbp + mc_genss.do_convertfloat.a]
    mov       r8,	[rbp + mc_genss.do_convertfloat.b]
    call      mc_genss.genrrm
L3313:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_fix
mc_genss.do_fix:
;>>
    %define mc_genss.do_fix.a 16
    %define mc_genss.do_fix.b 24
    %define mc_genss.do_fix.prefix 32
    %define mc_genss.do_fix.opc 40
    %define mc_genss.do_fix.am -8
    %define mc_genss.do_fix.regcode -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mc_genss.do_fix.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3320
    mov       rax,	[rbp + mc_genss.do_fix.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3319
    mov       rax,	[rbp + mc_genss.do_fix.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3319
L3320:
    lea       rcx,	[rel L5872]
    call      mc_libmcl.axerror
L3319:
L3318:
    mov       rcx,	[rbp + mc_genss.do_fix.a]
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    mov       rax,	[rbp + mc_genss.do_fix.prefix]
    cmp       rax,	243
    jnz       L3322
    mov       rax,	4
    jmp       L3321
L3322:
    mov       rax,	8
L3321:
    mov       r10,	[rbp + mc_genss.do_fix.b]
    lea       r10,	[r10+8]
    mov       di,	[r10]
    mov       r11,	-32
    and       di,	r11w
    or        di,	ax
    mov       [r10],	di
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_fix.prefix]
    mov       [r10],	al
    mov       rax,	3840
    add       rax,	[rbp + mc_genss.do_fix.opc]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_fix.a]
    mov       r8,	[rbp + mc_genss.do_fix.b]
    call      mc_genss.genrrm
L3317:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_float
mc_genss.do_float:
;>>
    %define mc_genss.do_float.a 16
    %define mc_genss.do_float.b 24
    %define mc_genss.do_float.prefix 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_float.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3326
    mov       rax,	[rbp + mc_genss.do_float.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3325
    mov       rax,	[rbp + mc_genss.do_float.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3325
L3326:
    lea       rcx,	[rel L5873]
    call      mc_libmcl.axerror
L3325:
L3324:
    mov       rcx,	[rbp + mc_genss.do_float.b]
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    mov       rax,	[rbp + mc_genss.do_float.prefix]
    cmp       rax,	243
    jnz       L3328
    mov       rax,	4
    jmp       L3327
L3328:
    mov       rax,	8
L3327:
    mov       r10,	[rbp + mc_genss.do_float.a]
    lea       r10,	[r10+8]
    mov       di,	[r10]
    mov       r11,	-32
    and       di,	r11w
    or        di,	ax
    mov       [r10],	di
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_float.prefix]
    mov       [r10],	al
    mov       al,	1
    mov       [mc_genss.usesizeb],	al
    mov       rcx,	3882
    mov       rdx,	[rbp + mc_genss.do_float.a]
    mov       r8,	[rbp + mc_genss.do_float.b]
    call      mc_genss.genrrm
L3323:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_movxmm
mc_genss.do_movxmm:
;>>
    %define mc_genss.do_movxmm.a 16
    %define mc_genss.do_movxmm.b 24
    %define mc_genss.do_movxmm.size 32
    %define mc_genss.do_movxmm.am -8
    %define mc_genss.do_movxmm.regcode -16
    %define mc_genss.do_movxmm.regcode1 -24
    %define mc_genss.do_movxmm.regcode2 -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3331
    cmp       r10,	5
    jz        L3332
    cmp       r10,	3
    jz        L3333
    jmp       L3334
L3331:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3336
    jmp       L3337
L3336:
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	[rbp + mc_genss.do_movxmm.size]
    jz        L3339
    lea       rcx,	[rel L5874]
    call      mc_libmcl.axerror
L3339:
L3338:
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rcx,	3966
    mov       rdx,	[rbp + mc_genss.do_movxmm.b]
    mov       r8,	[rbp + mc_genss.do_movxmm.a]
    call      mc_genss.genrrm
    jmp       L3335
L3337:
    lea       rcx,	[rel L5875]
    call      mc_libmcl.axerror
L3335:
    jmp       L3330
L3332:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3341
    cmp       r10,	5
    jz        L3342
    cmp       r10,	3
    jz        L3343
    jmp       L3344
L3341:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	[rbp + mc_genss.do_movxmm.size]
    jz        L3346
    lea       rcx,	[rel L5876]
    call      mc_libmcl.axerror
L3346:
L3345:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rcx,	3950
    mov       rdx,	[rbp + mc_genss.do_movxmm.a]
    mov       r8,	[rbp + mc_genss.do_movxmm.b]
    call      mc_genss.genrrm
    jmp       L3340
L3342:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       rcx,	3966
    mov       rdx,	[rbp + mc_genss.do_movxmm.a]
    mov       r8,	[rbp + mc_genss.do_movxmm.b]
    call      mc_genss.genrrm
    jmp       L3340
L3343:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3348
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3348:
L3347:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	[rbp + mc_genss.do_movxmm.size]
    jz        L3350
    lea       rcx,	[rel L5877]
    call      mc_libmcl.axerror
L3350:
L3349:
    mov       rax,	[rbp + mc_genss.do_movxmm.size]
    cmp       rax,	4
    jnz       L3352
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3950
    mov       rdx,	[rbp + mc_genss.do_movxmm.a]
    mov       r8,	[rbp + mc_genss.do_movxmm.b]
    call      mc_genss.genrrm
    jmp       L3351
L3352:
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3966
    mov       rdx,	[rbp + mc_genss.do_movxmm.a]
    mov       r8,	[rbp + mc_genss.do_movxmm.b]
    call      mc_genss.genrrm
L3351:
    jmp       L3340
L3344:
    lea       rcx,	[rel L5878]
    call      mc_libmcl.axerror
L3340:
    jmp       L3330
L3333:
    mov       rax,	[rbp + mc_genss.do_movxmm.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3354
    jmp       L3355
L3354:
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    test      r10,	r10
    jz        L3357
    mov       rax,	[rbp + mc_genss.do_movxmm.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	[rbp + mc_genss.do_movxmm.size]
    jz        L3357
    lea       rcx,	[rel L5879]
    call      mc_libmcl.axerror
L3357:
L3356:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rax,	[rbp + mc_genss.do_movxmm.size]
    cmp       rax,	4
    jnz       L3359
    mov       rax,	3966
    jmp       L3358
L3359:
    mov       rax,	4054
L3358:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_movxmm.b]
    mov       r8,	[rbp + mc_genss.do_movxmm.a]
    call      mc_genss.genrrm
    jmp       L3353
L3355:
    lea       rcx,	[rel L5880]
    call      mc_libmcl.axerror
L3353:
    jmp       L3330
L3334:
    lea       rcx,	[rel L5881]
    call      mc_libmcl.axerror
L3330:
L3329:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc fixrip
mc_genss.fixrip:
;>>
    %define mc_genss.fixrip.dispsize 16
    %define mc_genss.fixrip.codeaddr -8
    %define mc_genss.fixrip.offsetptr -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_genss.ripentry]
    test      rax,	rax
    jnz       L3362
    jmp       L3360
L3362:
L3361:
    mov       rax,	[rbp + mc_genss.fixrip.dispsize]
    cmp       rax,	0
    jz        L3364
    cmp       rax,	1
    jz        L3365
    cmp       rax,	2
    jz        L3365
    cmp       rax,	4
    jz        L3365
    jmp       L3366
L3364:
    jmp       L3360
L3365:
    jmp       L3363
L3366:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5882]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_genss.fixrip.dispsize]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L5883]
    call      mc_libmcl.axerror
L3363:
    mov       eax,	[rbp + mc_genss.fixrip.dispsize]
    mov       r10,	[mc_genss.ripentry]
    mov       [r10+12],	eax
L3360:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_bswap
mc_genss.do_bswap:
;>>
    %define mc_genss.do_bswap.a 16
    %define mc_genss.do_bswap.code -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_genss.do_bswap.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3370
    mov       rax,	[rbp + mc_genss.do_bswap.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jge       L3369
L3370:
    lea       rcx,	[rel L5884]
    call      mc_libmcl.axerror
L3369:
L3368:
    mov       rcx,	[rbp + mc_genss.do_bswap.a]
    call      mc_genss.setopsize
    mov       rax,	[rbp + mc_genss.do_bswap.a]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.do_bswap.code],	rax
    call      mc_genss.genrex
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	200
    add       rax,	[rbp + mc_genss.do_bswap.code]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3367:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc do_movdqx
mc_genss.do_movdqx:
;>>
    %define mc_genss.do_movdqx.a 16
    %define mc_genss.do_movdqx.b 24
    %define mc_genss.do_movdqx.prefix 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_genss.do_movdqx.prefix]
    shl       rax,	16
    add       rax,	3840
    mov       [rbp + mc_genss.do_movdqx.prefix],	rax
    mov       rax,	[rbp + mc_genss.do_movdqx.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3373
    mov       rax,	[rbp + mc_genss.do_movdqx.a]
    lea       rax,	[rax+8]
    mov       r10w,	16
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3373:
L3372:
    mov       rax,	[rbp + mc_genss.do_movdqx.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3375
    mov       rax,	[rbp + mc_genss.do_movdqx.b]
    lea       rax,	[rax+8]
    mov       r10w,	16
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3375:
L3374:
    mov       rax,	[rbp + mc_genss.do_movdqx.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L3377
    mov       rax,	[rbp + mc_genss.do_movdqx.prefix]
    add       rax,	127
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_movdqx.b]
    mov       r8,	[rbp + mc_genss.do_movdqx.a]
    call      mc_genss.genrrm
    jmp       L3376
L3377:
    mov       rax,	[rbp + mc_genss.do_movdqx.prefix]
    add       rax,	111
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_movdqx.a]
    mov       r8,	[rbp + mc_genss.do_movdqx.b]
    call      mc_genss.genrrm
L3376:
L3371:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc do_dshift
mc_genss.do_dshift:
;>>
    %define mc_genss.do_dshift.a 16
    %define mc_genss.do_dshift.b 24
    %define mc_genss.do_dshift.c 32
    %define mc_genss.do_dshift.opc 40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rax,	[rbp + mc_genss.do_dshift.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	0
    jnz       L3380
    mov       rax,	[rbp + mc_genss.do_dshift.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_dshift.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3380:
L3379:
    mov       rax,	[rbp + mc_genss.do_dshift.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_genss.do_dshift.b]
    movzx     r11,	word [rax+8]
    and       r11,	31
    cmp       r10,	r11
    jnz       L3383
    mov       rax,	[rbp + mc_genss.do_dshift.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	1
    jg        L3382
L3383:
    lea       rcx,	[rel L5885]
    call      mc_libmcl.axerror
L3382:
L3381:
    xor       eax,	eax
    mov       [mc_genss.sizeoverride],	al
    mov       rax,	3840
    add       rax,	[rbp + mc_genss.do_dshift.opc]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_dshift.b]
    mov       r8,	[rbp + mc_genss.do_dshift.a]
    call      mc_genss.genrrm
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mc_genss.do_dshift.c]
    mov       [r10],	al
L3378:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mclinit
mc_libmcl.mclinit:
;>>
    %define mc_libmcl.mclinit.a -8
    %define mc_libmcl.mclinit.r -16
    %define mc_libmcl.mclinit.s -24
    %define mc_libmcl.mclinit.av_1 -32
    %define mc_libmcl.mclinit.av_2 -40
    %define mc_libmcl.mclinit.i -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rax,	55
    cmp       rax,	64
    jle       L3386
    lea       rcx,	[rel L5886]
    call      mlib.abortprogram
L3386:
L3385:
    mov       rax,	1
    mov       [rbp + mc_libmcl.mclinit.r],	rax
L3387:
    mov       rcx,	[rbp + mc_libmcl.mclinit.r]
    mov       rdx,	1
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	[rbp + mc_libmcl.mclinit.r]
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10],	rax
    mov       rcx,	[rbp + mc_libmcl.mclinit.r]
    mov       rdx,	2
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	[rbp + mc_libmcl.mclinit.r]
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+8],	rax
    mov       rcx,	[rbp + mc_libmcl.mclinit.r]
    mov       rdx,	4
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	[rbp + mc_libmcl.mclinit.r]
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+24],	rax
    mov       rcx,	[rbp + mc_libmcl.mclinit.r]
    mov       rdx,	8
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	[rbp + mc_libmcl.mclinit.r]
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+56],	rax
L3388:
    mov       rax,	[rbp + mc_libmcl.mclinit.r]
    inc       rax
    mov       [rbp + mc_libmcl.mclinit.r],	rax
    cmp       rax,	16
    jle       L3387
L3389:
    mov       rax,	-128
    mov       [rbp + mc_libmcl.mclinit.i],	rax
    mov       rax,	64
    mov       [rbp + mc_libmcl.mclinit.av_1],	rax
    mov       rax,	[rbp + mc_libmcl.mclinit.av_1]
    cmp       rax,	-128
    jl        L3392
L3390:
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mclinit.a],	rax
    mov       rax,	[rbp + mc_libmcl.mclinit.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	15
    mov       r10,	[rbp + mc_libmcl.mclinit.a]
    mov       [r10+10],	al
    mov       rax,	[rbp + mc_libmcl.mclinit.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       eax,	[rbp + mc_libmcl.mclinit.i]
    mov       r10,	[rbp + mc_libmcl.mclinit.a]
    mov       [r10+12],	eax
    mov       rax,	[rbp + mc_libmcl.mclinit.a]
    lea       r10,	[mc_decls.frameregtable]
    mov       r11,	[rbp + mc_libmcl.mclinit.i]
    mov       [r10 + r11*8+1024],	rax
L3391:
    mov       rax,	[rbp + mc_libmcl.mclinit.i]
    inc       rax
    mov       [rbp + mc_libmcl.mclinit.i],	rax
    cmp       rax,	[rbp + mc_libmcl.mclinit.av_1]
    jle       L3390
L3392:
    mov       rcx,	15
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [mc_decls.dframeopnd],	rax
    mov       rcx,	16
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [mc_decls.dstackopnd],	rax
    call      mc_libmcl.initmcdest
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    xor       eax,	eax
    mov       [mc_decls.lab_funcnametable],	rax
    xor       eax,	eax
    mov       [mc_decls.lab_funcaddrtable],	rax
    mov       rax,	-1
    mov       [rbp + mc_libmcl.mclinit.i],	rax
    mov       rax,	10
    mov       [rbp + mc_libmcl.mclinit.av_2],	rax
    mov       rax,	[rbp + mc_libmcl.mclinit.av_2]
    cmp       rax,	-1
    jl        L3395
L3393:
    mov       rcx,	[rbp + mc_libmcl.mclinit.i]
    mov       rdx,	8
    call      mc_libmcl.mgenint0
    lea       r10,	[mc_libmcl.smallinttable]
    mov       r11,	[rbp + mc_libmcl.mclinit.i]
    mov       [r10 + r11*8+8],	rax
L3394:
    mov       rax,	[rbp + mc_libmcl.mclinit.i]
    inc       rax
    mov       [rbp + mc_libmcl.mclinit.i],	rax
    cmp       rax,	[rbp + mc_libmcl.mclinit.av_2]
    jle       L3393
L3395:
L3384:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc initmcdest
mc_libmcl.initmcdest:
;>>
;---------------
    xor       eax,	eax
    mov       [mc_decls.mccodex],	rax
    mov       [mc_decls.mccode],	rax
L3396:
;---------------
    ret       
;End 
;Proc genmc
mc_libmcl.genmc:
genmc:
;>>
    %define mc_libmcl.genmc.opcode 16
    %define mc_libmcl.genmc.a 24
    %define mc_libmcl.genmc.b 32
    %define mc_libmcl.genmc.m -8
    %define mc_libmcl.genmc.oldm -16
    %define mc_libmcl.genmc.labno -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	55
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_libmcl.genmc.m],	rax
    mov       al,	[rbp + mc_libmcl.genmc.opcode]
    mov       r10,	[rbp + mc_libmcl.genmc.m]
    mov       [r10+24],	al
    inc       qword [mc_libmcl.mclseqno]
    mov       rax,	[mc_libmcl.mclseqno]
    mov       r10,	[rbp + mc_libmcl.genmc.m]
    mov       [r10+27],	rax
    mov       eax,	[pc_decls.mmpos]
    mov       r10,	[rbp + mc_libmcl.genmc.m]
    mov       [r10+35],	eax
    mov       rax,	[rbp + mc_libmcl.genmc.a]
    mov       r10,	[rbp + mc_libmcl.genmc.m]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mc_libmcl.genmc.b]
    mov       r10,	[rbp + mc_libmcl.genmc.m]
    mov       [r10+16],	rax
    mov       rax,	[rbp + mc_libmcl.genmc.opcode]
    cmp       rax,	22
    jz        L3399
    cmp       rax,	15
    jz        L3400
    cmp       rax,	9
    jz        L3401
    cmp       rax,	12
    jz        L3402
    jmp       L3403
L3399:
    inc       qword [pc_decls.nproccalls]
    jmp       L3398
L3400:
    mov       rax,	[rbp + mc_libmcl.genmc.b]
    test      rax,	rax
    jz        L3405
    mov       rax,	[rbp + mc_libmcl.genmc.b]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	5
    jnz       L3405
    mov       rax,	[rbp + mc_libmcl.genmc.b]
    mov       r10,	[rax]
    mov       al,	1
    mov       [r10+64],	al
L3405:
L3404:
    jmp       L3398
L3401:
    mov       rax,	[rbp + mc_libmcl.genmc.a]
    mov       r10,	[rax]
    mov       [rbp + mc_libmcl.genmc.labno],	r10
    jmp       L3398
L3402:
    mov       rax,	[rbp + mc_libmcl.genmc.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L3408
    mov       rax,	[rbp + mc_libmcl.genmc.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3407
L3408:
    mov       rax,	[rbp + mc_libmcl.genmc.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L3410
    mov       rax,	18
    jmp       L3409
L3410:
    mov       rax,	17
L3409:
    mov       r10,	[rbp + mc_libmcl.genmc.m]
    mov       [r10+24],	al
L3407:
L3406:
L3403:
L3398:
    mov       rax,	[mc_decls.mccode]
    test      rax,	rax
    jz        L3412
    mov       rax,	[rbp + mc_libmcl.genmc.m]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.genmc.m]
    mov       [mc_decls.mccodex],	rax
    jmp       L3411
L3412:
    mov       rax,	[rbp + mc_libmcl.genmc.m]
    mov       [mc_decls.mccodex],	rax
    mov       [mc_decls.mccode],	rax
L3411:
L3397:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc genmc_cond
mc_libmcl.genmc_cond:
;>>
    %define mc_libmcl.genmc_cond.opcode 16
    %define mc_libmcl.genmc_cond.cond 24
    %define mc_libmcl.genmc_cond.a 32
    %define mc_libmcl.genmc_cond.b 40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	[rbp + mc_libmcl.genmc_cond.opcode]
    mov       rdx,	[rbp + mc_libmcl.genmc_cond.a]
    mov       r8,	[rbp + mc_libmcl.genmc_cond.b]
    call      mc_libmcl.genmc
    mov       al,	[rbp + mc_libmcl.genmc_cond.cond]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+25],	al
L3413:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genmc_str
mc_libmcl.genmc_str:
;>>
    %define mc_libmcl.genmc_str.opcode 16
    %define mc_libmcl.genmc_str.s 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_libmcl.genmc_str.s]
    mov       rdx,	-1
    call      mc_libmcl.mgenstring
    mov       rcx,	[rbp + mc_libmcl.genmc_str.opcode]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L3414:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc newmclopnd
mc_libmcl.newmclopnd:
;>>
    %define mc_libmcl.newmclopnd.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_libmcl.newmclopnd.a],	rax
    mov       rax,	[rbp + mc_libmcl.newmclopnd.a]
L3415:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc duplopnd
mc_libmcl.duplopnd:
;>>
    %define mc_libmcl.duplopnd.a 16
    %define mc_libmcl.duplopnd.b -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_libmcl.duplopnd.b],	rax
    mov       rax,	[rbp + mc_libmcl.duplopnd.a]
    mov       r10,	[rbp + mc_libmcl.duplopnd.b]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rax,	[rbp + mc_libmcl.duplopnd.b]
L3416:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenindex
mc_libmcl.mgenindex:
mgenindex:
;>>
    %define mc_libmcl.mgenindex.areg 16
    %define mc_libmcl.mgenindex.ireg 24
    %define mc_libmcl.mgenindex.scale 32
    %define mc_libmcl.mgenindex.offset 40
    %define mc_libmcl.mgenindex.size 48
    %define mc_libmcl.mgenindex.labno 56
    %define mc_libmcl.mgenindex.def 64
    %define mc_libmcl.mgenindex.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenindex.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenindex.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	[rbp + mc_libmcl.mgenindex.areg]
    mov       r10,	[rbp + mc_libmcl.mgenindex.a]
    mov       [r10+10],	al
    mov       al,	[rbp + mc_libmcl.mgenindex.ireg]
    mov       r10,	[rbp + mc_libmcl.mgenindex.a]
    mov       [r10+11],	al
    mov       rax,	[rbp + mc_libmcl.mgenindex.a]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.mgenindex.scale]
    mov       di,	[rax]
    mov       r11,	-481
    shl       r10w,	5
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenindex.a]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.mgenindex.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       eax,	[rbp + mc_libmcl.mgenindex.offset]
    mov       r10,	[rbp + mc_libmcl.mgenindex.a]
    mov       [r10+12],	eax
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    test      rax,	rax
    jz        L3419
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    mov       r10,	[rbp + mc_libmcl.mgenindex.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenindex.a]
    lea       rax,	[rax+8]
    mov       r10w,	6
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    jmp       L3418
L3419:
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    test      rax,	rax
    jz        L3420
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    mov       r10,	[rbp + mc_libmcl.mgenindex.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    lea       rax,	[rax+65]
    inc       byte [rax]
    mov       rax,	[rbp + mc_libmcl.mgenindex.a]
    lea       rax,	[rax+8]
    mov       r10w,	5
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    movzx     r10,	byte [rax+49]
    cmp       r10,	4
    jz        L3423
    cmp       r10,	5
    jnz       L3422
L3423:
    mov       al,	15
    mov       r10,	[rbp + mc_libmcl.mgenindex.a]
    mov       [r10+10],	al
L3422:
L3421:
L3420:
L3418:
    mov       rax,	[rbp + mc_libmcl.mgenindex.a]
L3417:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgencomment
mc_libmcl.mgencomment:
;>>
    %define mc_libmcl.mgencomment.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.mgencomment.s]
    cmp       rax,	0
    jz        L3427
    mov       rax,	[rbp + mc_libmcl.mgencomment.s]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jnz       L3426
L3427:
    mov       rcx,	4
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L3425
L3426:
    mov       rcx,	3
    mov       rdx,	[rbp + mc_libmcl.mgencomment.s]
    call      mc_libmcl.genmc_str
L3425:
L3424:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mgenstring
mc_libmcl.mgenstring:
;>>
    %define mc_libmcl.mgenstring.s 16
    %define mc_libmcl.mgenstring.length 24
    %define mc_libmcl.mgenstring.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenstring.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenstring.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenstring.length]
    cmp       rax,	0
    jge       L3430
    mov       rcx,	[rbp + mc_libmcl.mgenstring.s]
    call      strlen
    mov       [rbp + mc_libmcl.mgenstring.length],	rax
L3430:
L3429:
    mov       rax,	[rbp + mc_libmcl.mgenstring.length]
    add       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mc_libmcl.mgenstring.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenstring.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_libmcl.mgenstring.s]
    mov       r8,	[rbp + mc_libmcl.mgenstring.length]
    call      memcpy
    mov       rax,	[rbp + mc_libmcl.mgenstring.a]
    mov       r10,	[rax]
    xor       eax,	eax
    mov       r11,	[rbp + mc_libmcl.mgenstring.length]
    mov       [r10 + r11],	al
    mov       rax,	[rbp + mc_libmcl.mgenstring.a]
    lea       rax,	[rax+8]
    mov       r10w,	4
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenstring.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenstring.a]
L3428:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenname
mc_libmcl.mgenname:
;>>
    %define mc_libmcl.mgenname.s 16
    %define mc_libmcl.mgenname.str -64
    %define mc_libmcl.mgenname.a -72
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenname.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenname.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rcx,	[rbp + mc_libmcl.mgenname.s]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + mc_libmcl.mgenname.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenname.a]
    lea       rax,	[rax+8]
    mov       r10w,	7
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenname.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenname.a]
L3431:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc setsegment
mc_libmcl.setsegment:
;>>
    %define mc_libmcl.setsegment.seg 16
    %define mc_libmcl.setsegment.align 24
    %define mc_libmcl.setsegment.opc -8
    %define mc_libmcl.setsegment.oldalign -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_libmcl.setsegment.seg]
    cmp       rax,	[mc_decls.currsegment]
    jz        L3434
    mov       rax,	[rbp + mc_libmcl.setsegment.seg]
    cmp       rax,	73
    jz        L3436
    cmp       rax,	90
    jz        L3437
    cmp       rax,	67
    jz        L3438
    cmp       rax,	82
    jz        L3439
    jmp       L3440
L3436:
    mov       rax,	120
    mov       [rbp + mc_libmcl.setsegment.opc],	rax
    jmp       L3435
L3437:
    mov       rax,	121
    mov       [rbp + mc_libmcl.setsegment.opc],	rax
    jmp       L3435
L3438:
    mov       rax,	122
    mov       [rbp + mc_libmcl.setsegment.opc],	rax
    jmp       L3435
L3439:
    lea       rcx,	[rel L5887]
    lea       rdx,	[rel L5888]
    call      mc_libmcl.merror
    jmp       L3435
L3440:
    lea       rcx,	[rel L5889]
    lea       rdx,	[rel L5890]
    call      mc_libmcl.merror
L3435:
    mov       rax,	[mc_decls.mccodex]
    test      rax,	rax
    jz        L3442
    mov       rax,	[mc_decls.mccodex]
    movzx     r10,	byte [rax+24]
    cmp       r10,	120
    jz        L3443
    cmp       r10,	121
    jz        L3443
    cmp       r10,	122
    jnz       L3442
L3443:
    mov       al,	[rbp + mc_libmcl.setsegment.opc]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+24],	al
    jmp       L3441
L3442:
    mov       rcx,	[rbp + mc_libmcl.setsegment.opc]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L3441:
    mov       rax,	[rbp + mc_libmcl.setsegment.seg]
    mov       [mc_decls.currsegment],	rax
L3434:
L3433:
    mov       rax,	[rbp + mc_libmcl.setsegment.align]
    cmp       rax,	1
    jle       L3445
    mov       rax,	[mc_decls.mccodex]
    movzx     r10,	byte [rax+24]
    cmp       r10,	123
    jnz       L3447
    mov       rax,	[mc_decls.mccodex]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    mov       [rbp + mc_libmcl.setsegment.oldalign],	rax
    mov       rax,	[rbp + mc_libmcl.setsegment.oldalign]
    cmp       rax,	[rbp + mc_libmcl.setsegment.align]
    jl        L3449
    jmp       L3432
L3449:
L3448:
L3447:
L3446:
    mov       rcx,	[rbp + mc_libmcl.setsegment.align]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	123
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L3445:
L3444:
L3432:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc changeopndsize
mc_libmcl.changeopndsize:
;>>
    %define mc_libmcl.changeopndsize.a 16
    %define mc_libmcl.changeopndsize.size 24
    %define mc_libmcl.changeopndsize.b -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_libmcl.changeopndsize.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	[rbp + mc_libmcl.changeopndsize.size]
    jz        L3452
    mov       rax,	[rbp + mc_libmcl.changeopndsize.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3454
    mov       rax,	[rbp + mc_libmcl.changeopndsize.a]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_decls.regtable]
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    mov       r10,	[rbp + mc_libmcl.changeopndsize.size]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_libmcl.changeopndsize.b],	r11
    jmp       L3453
L3454:
    mov       rcx,	[rbp + mc_libmcl.changeopndsize.a]
    call      mc_libmcl.duplopnd
    mov       [rbp + mc_libmcl.changeopndsize.b],	rax
    mov       rax,	[rbp + mc_libmcl.changeopndsize.b]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.changeopndsize.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3453:
    mov       rax,	[rbp + mc_libmcl.changeopndsize.b]
    jmp       L3450
L3452:
L3451:
    mov       rax,	[rbp + mc_libmcl.changeopndsize.a]
L3450:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc applyoffset
mc_libmcl.applyoffset:
;>>
    %define mc_libmcl.applyoffset.a 16
    %define mc_libmcl.applyoffset.offset 24
    %define mc_libmcl.applyoffset.size 32
    %define mc_libmcl.applyoffset.b -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_libmcl.applyoffset.offset]
    cmp       rax,	0
    jnz       L3457
    mov       rax,	[rbp + mc_libmcl.applyoffset.size]
    cmp       rax,	0
    jnz       L3457
    mov       rax,	[rbp + mc_libmcl.applyoffset.a]
    jmp       L3455
L3457:
L3456:
    mov       rcx,	[rbp + mc_libmcl.applyoffset.a]
    call      mc_libmcl.duplopnd
    mov       [rbp + mc_libmcl.applyoffset.b],	rax
    mov       rax,	[rbp + mc_libmcl.applyoffset.b]
    lea       rax,	[rax+12]
    mov       r10d,	[rbp + mc_libmcl.applyoffset.offset]
    add       [rax],	r10d
    mov       rax,	[rbp + mc_libmcl.applyoffset.size]
    test      rax,	rax
    jz        L3459
    mov       rax,	[rbp + mc_libmcl.applyoffset.b]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.applyoffset.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3459:
L3458:
    mov       rax,	[rbp + mc_libmcl.applyoffset.b]
L3455:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenint
mc_libmcl.mgenint:
mgenint:
;>>
    %define mc_libmcl.mgenint.x 16
    %define mc_libmcl.mgenint.mode 24
    %define mc_libmcl.mgenint.a -8
    %define mc_libmcl.mgenint.size -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenint.mode]
    movzx     r11,	byte [rax + r10]
    mov       [rbp + mc_libmcl.mgenint.size],	r11
    mov       rax,	[rbp + mc_libmcl.mgenint.x]
    cmp       rax,	-1
    jl        L3462
    cmp       rax,	10
    jg        L3462
    mov       rax,	[rbp + mc_libmcl.mgenint.size]
    cmp       rax,	8
    jnz       L3462
    lea       rax,	[mc_libmcl.smallinttable]
    mov       r10,	[rbp + mc_libmcl.mgenint.x]
    mov       r11,	[rax + r10*8+8]
    mov       rax,	r11
    jmp       L3460
L3462:
L3461:
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenint.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenint.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenint.x]
    mov       r10,	[rbp + mc_libmcl.mgenint.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenint.a]
    lea       rax,	[rax+8]
    mov       r10w,	1
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenint.a]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.mgenint.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenint.a]
L3460:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenint0
mc_libmcl.mgenint0:
;>>
    %define mc_libmcl.mgenint0.x 16
    %define mc_libmcl.mgenint0.size 24
    %define mc_libmcl.mgenint0.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenint0.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenint0.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenint0.x]
    mov       r10,	[rbp + mc_libmcl.mgenint0.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenint0.a]
    lea       rax,	[rax+8]
    mov       r10w,	1
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenint0.a]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.mgenint0.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenint0.a]
L3463:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenrealmem
mc_libmcl.mgenrealmem:
;>>
    %define mc_libmcl.mgenrealmem.x 16
    %define mc_libmcl.mgenrealmem.mode 24
    %define mc_libmcl.mgenrealmem.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenrealmem.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenrealmem.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenrealmem.mode]
    sub       rax,	1
    test      rax,	rax
    jz        L3466
    movq      XMM0,	[rbp + mc_libmcl.mgenrealmem.x]
    call      mc_libmcl.getrealindex
    mov       r10,	[rbp + mc_libmcl.mgenrealmem.a]
    mov       [r10],	rax
    jmp       L3465
L3466:
    movq      XMM0,	[rbp + mc_libmcl.mgenrealmem.x]
    call      mc_libmcl.getreal32index
    mov       r10,	[rbp + mc_libmcl.mgenrealmem.a]
    mov       [r10],	rax
L3465:
    mov       rax,	[rbp + mc_libmcl.mgenrealmem.a]
    lea       rax,	[rax+8]
    mov       r10w,	6
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenrealmem.mode]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_libmcl.mgenrealmem.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenrealmem.a]
L3464:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenrealimm
mc_libmcl.mgenrealimm:
;>>
    %define mc_libmcl.mgenrealimm.x 16
    %define mc_libmcl.mgenrealimm.mode 24
    %define mc_libmcl.mgenrealimm.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    movq      [rbp+16],	XMM0
    mov       [rbp+24],	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenrealimm.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenrealimm.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    movq      XMM4,	[rbp + mc_libmcl.mgenrealimm.x]
    mov       rax,	[rbp + mc_libmcl.mgenrealimm.a]
    movq      [rax],	XMM4
    mov       rax,	[rbp + mc_libmcl.mgenrealimm.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenrealimm.mode]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_libmcl.mgenrealimm.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenrealimm.a]
L3467:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenlabel
mc_libmcl.mgenlabel:
mgenlabel:
;>>
    %define mc_libmcl.mgenlabel.x 16
    %define mc_libmcl.mgenlabel.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenlabel.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenlabel.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenlabel.x]
    cmp       rax,	0
    jnz       L3470
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [rbp + mc_libmcl.mgenlabel.x],	rax
L3470:
L3469:
    mov       rax,	[rbp + mc_libmcl.mgenlabel.x]
    mov       r10,	[rbp + mc_libmcl.mgenlabel.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenlabel.a]
    lea       rax,	[rax+8]
    mov       r10w,	6
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenlabel.a]
L3468:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenlabelmem
mc_libmcl.mgenlabelmem:
;>>
    %define mc_libmcl.mgenlabelmem.x 16
    %define mc_libmcl.mgenlabelmem.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_libmcl.mgenlabelmem.x]
    call      mc_libmcl.mgenlabel
    mov       [rbp + mc_libmcl.mgenlabelmem.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenlabelmem.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenlabelmem.a]
L3471:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenmem
mc_libmcl.mgenmem:
;>>
    %define mc_libmcl.mgenmem.d 16
    %define mc_libmcl.mgenmem.mode 24
    %define mc_libmcl.mgenmem.a -8
    %define mc_libmcl.mgenmem.reg -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_libmcl.mgenmem.d]
    movzx     r10,	byte [rax+66]
    test      r10,	r10
    jz        L3474
    mov       rax,	[rbp + mc_libmcl.mgenmem.d]
    movzx     r10,	byte [rax+58]
    lea       rax,	[pc_tables.pfloat]
    movzx     r11,	byte [rax + r10]
    test      r11,	r11
    jz        L3476
    mov       rcx,	[rbp + mc_libmcl.mgenmem.d]
    call      mc_libmcl.mgenxregvar
    jmp       L3472
L3476:
    mov       rcx,	[rbp + mc_libmcl.mgenmem.d]
    call      mc_libmcl.mgenregvar
    jmp       L3472
L3475:
L3474:
L3473:
    xor       eax,	eax
    mov       [rbp + mc_libmcl.mgenmem.reg],	rax
    mov       rax,	[rbp + mc_libmcl.mgenmem.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	4
    jz        L3479
    cmp       r10,	5
    jnz       L3478
L3479:
    mov       rax,	15
    mov       [rbp + mc_libmcl.mgenmem.reg],	rax
L3478:
L3477:
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenmem.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenmem.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	[rbp + mc_libmcl.mgenmem.reg]
    mov       r10,	[rbp + mc_libmcl.mgenmem.a]
    mov       [r10+10],	al
    mov       rax,	[rbp + mc_libmcl.mgenmem.d]
    mov       r10,	[rbp + mc_libmcl.mgenmem.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenmem.d]
    lea       rax,	[rax+65]
    inc       byte [rax]
    mov       rax,	[rbp + mc_libmcl.mgenmem.a]
    lea       rax,	[rax+8]
    mov       r10w,	5
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenmem.mode]
    test      rax,	rax
    jz        L3481
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenmem.mode]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_libmcl.mgenmem.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    jmp       L3480
L3481:
    mov       rax,	[rbp + mc_libmcl.mgenmem.d]
    mov       r10d,	[rax+60]
    mov       rax,	8
    cmp       r10,	rax
    cmova     r10,	rax
    mov       rax,	[rbp + mc_libmcl.mgenmem.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
L3480:
    mov       rax,	[rbp + mc_libmcl.mgenmem.a]
L3472:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenmemaddr
mc_libmcl.mgenmemaddr:
mgenmemaddr:
;>>
    %define mc_libmcl.mgenmemaddr.d 16
    %define mc_libmcl.mgenmemaddr.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       al,	1
    mov       r10,	[rbp + mc_libmcl.mgenmemaddr.d]
    mov       [r10+64],	al
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.d]
    lea       rax,	[rax+65]
    inc       byte [rax]
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenmemaddr.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.a]
    lea       rax,	[rax+8]
    mov       r10w,	2
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.d]
    mov       r10,	[rbp + mc_libmcl.mgenmemaddr.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.d]
    lea       rax,	[rax+65]
    inc       byte [rax]
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.a]
    lea       rax,	[rax+8]
    mov       r10w,	5
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenmemaddr.a]
L3482:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenreg0
mc_libmcl.mgenreg0:
;>>
    %define mc_libmcl.mgenreg0.reg 16
    %define mc_libmcl.mgenreg0.size 24
    %define mc_libmcl.mgenreg0.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenreg0.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenreg0.a]
    lea       rax,	[rax+8]
    mov       r10w,	1
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	[rbp + mc_libmcl.mgenreg0.reg]
    mov       r10,	[rbp + mc_libmcl.mgenreg0.a]
    mov       [r10+10],	al
    mov       rax,	[rbp + mc_libmcl.mgenreg0.a]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.mgenreg0.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenreg0.size]
    cmp       rax,	0
    jnz       L3485
    lea       rcx,	[rel L5891]
    lea       rdx,	[rel L5892]
    call      mc_libmcl.merror
L3485:
L3484:
    mov       rax,	[rbp + mc_libmcl.mgenreg0.a]
L3483:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenxreg
mc_libmcl.mgenxreg:
mgenxreg:
;>>
    %define mc_libmcl.mgenxreg.xreg 16
    %define mc_libmcl.mgenxreg.size 24
    %define mc_libmcl.mgenxreg.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenxreg.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenxreg.a]
    lea       rax,	[rax+8]
    mov       r10w,	5
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	[rbp + mc_libmcl.mgenxreg.xreg]
    mov       r10,	[rbp + mc_libmcl.mgenxreg.a]
    mov       [r10+10],	al
    mov       rax,	[rbp + mc_libmcl.mgenxreg.a]
    lea       rax,	[rax+8]
    mov       r10w,	[rbp + mc_libmcl.mgenxreg.size]
    mov       di,	[rax]
    mov       r11,	-32
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenxreg.size]
    cmp       rax,	0
    jnz       L3488
    lea       rcx,	[rel L5893]
    lea       rdx,	[rel L5894]
    call      mc_libmcl.merror
L3488:
L3487:
    mov       rax,	[rbp + mc_libmcl.mgenxreg.a]
L3486:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenreg
mc_libmcl.mgenreg:
mgenreg:
;>>
    %define mc_libmcl.mgenreg.reg 16
    %define mc_libmcl.mgenreg.mode 24
    %define mc_libmcl.mgenreg.a -8
    %define mc_libmcl.mgenreg.size -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenreg.mode]
    movzx     r11,	byte [rax + r10]
    mov       [rbp + mc_libmcl.mgenreg.size],	r11
    mov       rax,	[rbp + mc_libmcl.mgenreg.mode]
    cmp       rax,	2
    jg        L3491
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenreg.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenreg.a]
    lea       rax,	[rax+8]
    mov       r10w,	5
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	[rbp + mc_libmcl.mgenreg.reg]
    mov       r10,	[rbp + mc_libmcl.mgenreg.a]
    mov       [r10+10],	al
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenreg.mode]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_libmcl.mgenreg.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgenreg.a]
    jmp       L3490
L3491:
    mov       rax,	[rbp + mc_libmcl.mgenreg.size]
    cmp       rax,	0
    jnz       L3493
    mov       rax,	8
    mov       [rbp + mc_libmcl.mgenreg.size],	rax
L3493:
L3492:
    lea       rax,	[mc_decls.regtable]
    mov       r10,	[rbp + mc_libmcl.mgenreg.reg]
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    mov       r10,	[rbp + mc_libmcl.mgenreg.size]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
    jmp       L3489
    mov       rcx,	[rbp + mc_libmcl.mgenreg.reg]
    mov       rdx,	[rbp + mc_libmcl.mgenreg.size]
    call      mc_libmcl.mgenreg0
L3490:
L3489:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenregi
mc_libmcl.mgenregi:
;>>
    %define mc_libmcl.mgenregi.reg 16
    %define mc_libmcl.mgenregi.mode 24
    %define mc_libmcl.mgenregi.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.regtable]
    mov       r10,	[rbp + mc_libmcl.mgenregi.reg]
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    lea       r10,	[pc_tables.psize]
    mov       r11,	[rbp + mc_libmcl.mgenregi.mode]
    movzx     rdi,	byte [r10 + r11]
    mov       r10,	[rax + rdi*8-8]
    mov       rax,	r10
    jmp       L3494
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenregi.mode]
    movzx     r11,	byte [rax + r10]
    mov       rcx,	[rbp + mc_libmcl.mgenregi.reg]
    mov       rdx,	r11
    call      mc_libmcl.mgenreg0
L3494:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenireg
mc_libmcl.mgenireg:
;>>
    %define mc_libmcl.mgenireg.reg 16
    %define mc_libmcl.mgenireg.mode 24
    %define mc_libmcl.mgenireg.offset 32
    %define mc_libmcl.mgenireg.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgenireg.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenireg.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	[rbp + mc_libmcl.mgenireg.reg]
    mov       r10,	[rbp + mc_libmcl.mgenireg.a]
    mov       [r10+10],	al
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgenireg.mode]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_libmcl.mgenireg.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    mov       eax,	[rbp + mc_libmcl.mgenireg.offset]
    mov       r10,	[rbp + mc_libmcl.mgenireg.a]
    mov       [r10+12],	eax
    mov       rax,	[rbp + mc_libmcl.mgenireg.a]
L3495:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgentemp
mc_libmcl.mgentemp:
;>>
    %define mc_libmcl.mgentemp.n 16
    %define mc_libmcl.mgentemp.mode 24
    %define mc_libmcl.mgentemp.a -8
    %define mc_libmcl.mgentemp.reg -16
    %define mc_libmcl.mgentemp.size -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pcltempflags]
    mov       r10,	[rbp + mc_libmcl.mgentemp.n]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L3498
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgentemp.mode]
    movzx     r11,	byte [rax + r10]
    lea       rax,	[mc_decls.pcltempopnds]
    mov       r10,	[rbp + mc_libmcl.mgentemp.n]
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	rdi
    mov       rdx,	r11
    call      mc_libmcl.changeopndsize
    jmp       L3496
L3498:
L3497:
    call      mc_libmcl.newmclopnd
    mov       [rbp + mc_libmcl.mgentemp.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgentemp.a]
    lea       rax,	[rax+8]
    mov       r10w,	3
    mov       di,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    mov       al,	15
    mov       r10,	[rbp + mc_libmcl.mgentemp.a]
    mov       [r10+10],	al
    mov       rax,	[rbp + mc_libmcl.mgentemp.a]
    lea       rax,	[rax+8]
    mov       r10w,	8
    mov       di,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       di,	r11w
    or        di,	r10w
    mov       [rax],	di
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_libmcl.mgentemp.mode]
    movzx     r11,	byte [rax + r10]
    mov       rax,	[rbp + mc_libmcl.mgentemp.a]
    lea       rax,	[rax+8]
    mov       di,	[rax]
    mov       r10,	-32
    and       di,	r10w
    or        di,	r11w
    mov       [rax],	di
    mov       rax,	[rbp + mc_libmcl.mgentemp.n]
    mov       r10,	[rbp + mc_libmcl.mgentemp.a]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_libmcl.mgentemp.a]
    lea       r10,	[mc_decls.pcltempopnds]
    mov       r11,	[rbp + mc_libmcl.mgentemp.n]
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pcltempflags]
    mov       r11,	[rbp + mc_libmcl.mgentemp.n]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_libmcl.mgentemp.a]
L3496:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc roundsizetg
mc_libmcl.roundsizetg:
;>>
    %define mc_libmcl.roundsizetg.size 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.roundsizetg.size]
    and       rax,	7
    cmp       rax,	0
    jnz       L3501
    mov       rax,	[rbp + mc_libmcl.roundsizetg.size]
    jmp       L3499
L3501:
L3500:
    mov       rax,	[rbp + mc_libmcl.roundsizetg.size]
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	[rbp + mc_libmcl.roundsizetg.size]
    add       rax,	r10
L3499:
;---------------
    pop       rbp
    ret       
;End 
;Proc merror
mc_libmcl.merror:
merror:
;>>
    %define mc_libmcl.merror.mess 16
    %define mc_libmcl.merror.param 24
    %define mc_libmcl.merror.lineno -8
    %define mc_libmcl.merror.filename -16
    %define mc_libmcl.merror.sourceline -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L3504
    mov       rcx,	[pc_decls.mmpos]
    lea       rdx,	[rbp + mc_libmcl.merror.filename]
    lea       r8,	[rbp + mc_libmcl.merror.sourceline]
    mov       rax,	[pc_decls.igetmsourceinfo]
    call      rax
    mov       [rbp + mc_libmcl.merror.lineno],	rax
    call      msys.m$print_startcon
    lea       rcx,	[rel L5895]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_libmcl.merror.lineno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L5896]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_libmcl.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L3503
L3504:
    xor       eax,	eax
    mov       [rbp + mc_libmcl.merror.lineno],	rax
    lea       rax,	[rel L5897]
    mov       [rbp + mc_libmcl.merror.filename],	rax
L3503:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5898]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mc_libmcl.merror.mess]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_libmcl.merror.param]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_libmcl.merror.lineno]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + mc_libmcl.merror.filename]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_genmcl.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mc_libmcl.merror.filename]
    mov       rdx,	[rbp + mc_libmcl.merror.lineno]
    call      pc_api.pcerrorstop
L3502:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc merroropnd
mc_libmcl.merroropnd:
;>>
    %define mc_libmcl.merroropnd.mess 16
    %define mc_libmcl.merroropnd.opndtype 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5899]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mc_libmcl.merroropnd.mess]
    call      msys.m$print_str_nf
    lea       rax,	[pc_tables.opndnames]
    mov       r10,	[rbp + mc_libmcl.merroropnd.opndtype]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L3505:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
;>>
;---------------
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
L3506:
;---------------
    ret       
;End 
;Proc mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
;>>
    %define mc_libmcl.mdefinefwdlabel.lab 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_libmcl.mdefinefwdlabel.lab]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L3507:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc checkregvar
mc_libmcl.checkregvar:
;>>
    %define mc_libmcl.checkregvar.reg 16
    %define mc_libmcl.checkregvar.ispfloat 24
    %define mc_libmcl.checkregvar.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    xor       eax,	eax
L3508:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc mgenextname
mc_libmcl.mgenextname:
;>>
    %define mc_libmcl.mgenextname.s 16
    %define mc_libmcl.mgenextname.str -64
    %define mc_libmcl.mgenextname.d -72
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    mov       rdx,	[rbp + mc_libmcl.mgenextname.s]
    call      strcpy
    mov       rcx,	[rbp + mc_libmcl.mgenextname.s]
    call      strlen
    xor       r10d,	r10d
    mov       [rbp + rax + mc_libmcl.mgenextname.str-1],	r10b
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       [rbp + mc_libmcl.mgenextname.d],	rax
    mov       rax,	[rbp + mc_libmcl.mgenextname.d]
    test      rax,	rax
    jnz       L3511
    mov       rcx,	112
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_libmcl.mgenextname.d],	rax
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + mc_libmcl.mgenextname.d]
    mov       [r10],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_libmcl.mgenextname.d]
    mov       [r10+49],	al
    mov       al,	1
    mov       r10,	[rbp + mc_libmcl.mgenextname.d]
    mov       [r10+56],	al
    mov       rcx,	[rbp + mc_libmcl.mgenextname.d]
    call      mc_libmcl.addnamesym
L3511:
L3510:
    mov       rcx,	[rbp + mc_libmcl.mgenextname.d]
    call      mc_libmcl.mgenmemaddr
L3509:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc mgenregvar
mc_libmcl.mgenregvar:
;>>
    %define mc_libmcl.mgenregvar.d 16
    %define mc_libmcl.mgenregvar.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.mgenregvar.d]
    movzx     r10,	byte [rax+66]
    mov       rcx,	r10
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_libmcl.mgenregvar.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenregvar.d]
    movzx     r10,	byte [rax+66]
    mov       al,	1
    lea       r11,	[mc_decls.isregvar]
    mov       [r11 + r10-1],	al
    mov       rax,	[rbp + mc_libmcl.mgenregvar.a]
L3512:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mgenxregvar
mc_libmcl.mgenxregvar:
;>>
    %define mc_libmcl.mgenxregvar.d 16
    %define mc_libmcl.mgenxregvar.a -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.mgenxregvar.d]
    movzx     r10,	byte [rax+66]
    mov       rcx,	r10
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_libmcl.mgenxregvar.a],	rax
    mov       rax,	[rbp + mc_libmcl.mgenxregvar.d]
    movzx     r10,	byte [rax+66]
    mov       al,	1
    lea       r11,	[mc_decls.isxregvar]
    mov       [r11 + r10-1],	al
    mov       rax,	[rbp + mc_libmcl.mgenxregvar.a]
L3513:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getopndcat
mc_libmcl.getopndcat:
;>>
    %define mc_libmcl.getopndcat.ax 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.getopndcat.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3516
    cmp       r10,	5
    jz        L3516
    cmp       r10,	2
    jz        L3517
    cmp       r10,	3
    jz        L3518
    jmp       L3519
L3516:
    mov       rax,	3
    jmp       L3515
L3517:
    mov       rax,	2
    jmp       L3515
L3518:
    mov       rax,	[rbp + mc_libmcl.getopndcat.ax]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + mc_libmcl.getopndcat.ax]
    movzx     r11,	byte [rax+11]
    cmp       r11,	r10
    jnz       L3521
    cmp       r11,	0
    jnz       L3521
    mov       rax,	5
    jmp       L3520
L3521:
    mov       rax,	[rbp + mc_libmcl.getopndcat.ax]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jnz       L3523
    mov       rax,	[rbp + mc_libmcl.getopndcat.ax]
    movzx     r10,	byte [rax+11]
    test      r10,	r10
    jz        L3522
    mov       rax,	[rbp + mc_libmcl.getopndcat.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    cmp       r10,	1
    jg        L3522
L3523:
    mov       rax,	4
    jmp       L3520
L3522:
    mov       rax,	6
L3520:
    jmp       L3515
L3519:
    mov       rax,	1
L3515:
L3514:
;---------------
    pop       rbp
    ret       
;End 
;Proc getprimreg
mc_libmcl.getprimreg:
;>>
    %define mc_libmcl.getprimreg.ax 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.getprimreg.ax]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jz        L3526
    mov       rax,	[rbp + mc_libmcl.getprimreg.ax]
    movzx     r10,	byte [rax+10]
    mov       rax,	r10
    jmp       L3525
L3526:
    mov       rax,	[rbp + mc_libmcl.getprimreg.ax]
    movzx     r10,	byte [rax+11]
    mov       rax,	r10
L3525:
L3524:
;---------------
    pop       rbp
    ret       
;End 
;Proc pushslots
mc_libmcl.pushslots:
;>>
    %define mc_libmcl.pushslots.nslots 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.pushslots.nslots]
    imul      rax,	8
    mov       rcx,	rax
    call      mc_libmcl.pushstack
    mov       rax,	[rbp + mc_libmcl.pushslots.nslots]
    add       [mc_decls.mstackdepth],	rax
L3527:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc popslots
mc_libmcl.popslots:
;>>
    %define mc_libmcl.popslots.nslots 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.popslots.nslots]
    imul      rax,	8
    mov       rcx,	rax
    call      mc_libmcl.popstack
    mov       rax,	[rbp + mc_libmcl.popslots.nslots]
    sub       [mc_decls.mstackdepth],	rax
L3528:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pushstack
mc_libmcl.pushstack:
;>>
    %define mc_libmcl.pushstack.n 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.pushstack.n]
    test      rax,	rax
    jz        L3531
    mov       rcx,	[rbp + mc_libmcl.pushstack.n]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	30
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L3531:
L3530:
L3529:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc popstack
mc_libmcl.popstack:
;>>
    %define mc_libmcl.popstack.n 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.popstack.n]
    test      rax,	rax
    jz        L3534
    mov       rcx,	[rbp + mc_libmcl.popstack.n]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L3534:
L3533:
L3532:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getstringindex
mc_libmcl.getstringindex:
;>>
    %define mc_libmcl.getstringindex.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_libmcl.getstringindex.s]
    cmp       rax,	0
    jnz       L3537
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       [mc_decls.kk0used],	rax
    mov       rax,	[mc_decls.kk0used]
    jmp       L3535
L3537:
L3536:
    mov       rax,	[mc_decls.cstringlist]
    test      rax,	rax
    jz        L3539
    mov       rax,	[mc_decls.cstringlist]
    mov       r10,	[rax]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_libmcl.getstringindex.s]
    call      mlib.eqstring
    test      rax,	rax
    jz        L3539
    mov       rax,	[mc_decls.cstringlist]
    mov       r10,	[rax+16]
    mov       rax,	r10
    jmp       L3535
L3539:
L3538:
    lea       rcx,	[mc_decls.cstringlist]
    mov       rdx,	[rbp + mc_libmcl.getstringindex.s]
    call      mc_libmcl.addconst
L3535:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc addconst
mc_libmcl.addconst:
;>>
    %define mc_libmcl.addconst.clist 16
    %define mc_libmcl.addconst.value 24
    %define mc_libmcl.addconst.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	24
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_libmcl.addconst.p],	rax
    mov       rax,	[rbp + mc_libmcl.addconst.value]
    mov       r10,	[rbp + mc_libmcl.addconst.p]
    mov       [r10],	rax
    inc       qword [mc_decls.mlabelno]
    mov       rax,	[mc_decls.mlabelno]
    mov       r10,	[rbp + mc_libmcl.addconst.p]
    mov       [r10+16],	rax
    mov       rax,	[rbp + mc_libmcl.addconst.clist]
    mov       r10,	[rax]
    mov       rax,	[rbp + mc_libmcl.addconst.p]
    mov       [rax+8],	r10
    mov       rax,	[rbp + mc_libmcl.addconst.p]
    mov       r10,	[rbp + mc_libmcl.addconst.clist]
    mov       [r10],	rax
    mov       rax,	[mc_decls.mlabelno]
L3540:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getrealindex
mc_libmcl.getrealindex:
;>>
    %define mc_libmcl.getrealindex.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    movq      [rbp+16],	XMM0
;---------------
    movq      XMM4,	[rbp + mc_libmcl.getrealindex.x]
    movq      rax,	XMM4
    lea       rcx,	[mc_decls.creallist]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L3541:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getreal32index
mc_libmcl.getreal32index:
;>>
    %define mc_libmcl.getreal32index.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    movq      [rbp+16],	XMM0
;---------------
    movq      XMM4,	[rbp + mc_libmcl.getreal32index.x]
    movq      rax,	XMM4
    lea       rcx,	[mc_decls.creal32list]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L3542:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc ispoweroftwo
mc_libmcl.ispoweroftwo:
;>>
    %define mc_libmcl.ispoweroftwo.x 16
    %define mc_libmcl.ispoweroftwo.a -8
    %define mc_libmcl.ispoweroftwo.n -16
    %define mc_libmcl.ispoweroftwo.av_1 -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mc_libmcl.ispoweroftwo.a],	rax
    xor       eax,	eax
    mov       [rbp + mc_libmcl.ispoweroftwo.n],	rax
    mov       rax,	60
    mov       [rbp + mc_libmcl.ispoweroftwo.av_1],	rax
L3544:
    inc       qword [rbp + mc_libmcl.ispoweroftwo.n]
    mov       rax,	[rbp + mc_libmcl.ispoweroftwo.a]
    shl       rax,	1
    mov       [rbp + mc_libmcl.ispoweroftwo.a],	rax
    mov       rax,	[rbp + mc_libmcl.ispoweroftwo.a]
    cmp       rax,	[rbp + mc_libmcl.ispoweroftwo.x]
    jnz       L3548
    mov       rax,	[rbp + mc_libmcl.ispoweroftwo.n]
    jmp       L3543
L3548:
L3547:
L3545:
    dec       qword [rbp + mc_libmcl.ispoweroftwo.av_1]
    jnz       L3544
L3546:
    xor       eax,	eax
L3543:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc axerror
mc_libmcl.axerror:
;>>
    %define mc_libmcl.axerror.mess 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5900]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_libmcl.axerror.mess]
    call      msys.m$print_str_nf
    lea       rcx,	[rel L5901]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L3549:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc newblocktemp
mc_libmcl.newblocktemp:
;>>
    %define mc_libmcl.newblocktemp.size 16
    %define mc_libmcl.newblocktemp.str -16
    %define mc_libmcl.newblocktemp.d -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.nblocktemps]
    cmp       rax,	50
    jle       L3552
    lea       rcx,	[rel L5902]
    lea       rdx,	[rel L5903]
    call      mc_libmcl.merror
L3552:
L3551:
    inc       qword [mc_decls.nblocktemps]
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5904]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    xor       edx,	edx
    call      pc_api.pc_makesymbol
    mov       [rbp + mc_libmcl.newblocktemp.d],	rax
    mov       al,	11
    mov       r10,	[rbp + mc_libmcl.newblocktemp.d]
    mov       [r10+58],	al
    mov       eax,	[rbp + mc_libmcl.newblocktemp.size]
    mov       r10,	[rbp + mc_libmcl.newblocktemp.d]
    mov       [r10+60],	eax
    mov       al,	1
    mov       r10,	[rbp + mc_libmcl.newblocktemp.d]
    mov       [r10+68],	al
    mov       al,	4
    mov       r10,	[rbp + mc_libmcl.newblocktemp.d]
    mov       [r10+49],	al
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_libmcl.newblocktemp.d]
    mov       [rax+24],	r10
    mov       rax,	[pc_decls.currfunc]
    mov       r10,	[rbp + mc_libmcl.newblocktemp.d]
    mov       [r10+32],	rax
    mov       rax,	[rbp + mc_libmcl.newblocktemp.d]
    mov       r10,	[pc_decls.currfunc]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_libmcl.newblocktemp.d]
    lea       r10,	[mc_decls.blockdefs]
    mov       r11,	[mc_decls.nblocktemps]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rbp + mc_libmcl.newblocktemp.d]
L3550:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc findnamesym
mc_libmcl.findnamesym:
;>>
    %define mc_libmcl.findnamesym.s 16
    %define mc_libmcl.findnamesym.d -8
    %define mc_libmcl.findnamesym.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mc_libmcl.findnamesym.i],	rax
    mov       rax,	[mc_libmcl.nnametable]
    cmp       rax,	1
    jl        L3556
L3554:
    lea       rax,	[mc_libmcl.nametable]
    mov       r10,	[rbp + mc_libmcl.findnamesym.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[r11]
    mov       rcx,	[rbp + mc_libmcl.findnamesym.s]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L3558
    lea       rax,	[mc_libmcl.nametable]
    mov       r10,	[rbp + mc_libmcl.findnamesym.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
    jmp       L3553
L3558:
L3557:
L3555:
    mov       rax,	[rbp + mc_libmcl.findnamesym.i]
    inc       rax
    mov       [rbp + mc_libmcl.findnamesym.i],	rax
    cmp       rax,	[mc_libmcl.nnametable]
    jle       L3554
L3556:
    xor       eax,	eax
L3553:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc addnamesym
mc_libmcl.addnamesym:
;>>
    %define mc_libmcl.addnamesym.d 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_libmcl.nnametable]
    cmp       rax,	20
    jge       L3561
    inc       qword [mc_libmcl.nnametable]
    mov       rax,	[mc_libmcl.nnametable]
    mov       r10,	[rbp + mc_libmcl.addnamesym.d]
    lea       r11,	[mc_libmcl.nametable]
    mov       [r11 + rax*8-8],	r10
L3561:
L3560:
L3559:
;---------------
    pop       rbp
    ret       
;End 
;Proc start
mc_decls.start:
;>>
    %define mc_decls.start.av_1 -8
    %define mc_decls.start.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    xor       eax,	eax
    mov       [rbp + mc_decls.start.i],	rax
    mov       rax,	13
    mov       [rbp + mc_decls.start.av_1],	rax
    mov       rax,	[rbp + mc_decls.start.av_1]
    cmp       rax,	0
    jl        L3565
L3563:
    mov       al,	10
    lea       r10,	[mc_decls.ploadop]
    mov       r11,	[rbp + mc_decls.start.i]
    mov       [r10 + r11],	al
L3564:
    mov       rax,	[rbp + mc_decls.start.i]
    inc       rax
    mov       [rbp + mc_decls.start.i],	rax
    cmp       rax,	[rbp + mc_decls.start.av_1]
    jle       L3563
L3565:
    mov       al,	20
    mov       [mc_decls.ploadop+5],	al
    mov       [mc_decls.ploadop+4],	al
    mov       [mc_decls.ploadop+3],	al
    mov       al,	19
    mov       [mc_decls.ploadop+9],	al
    mov       [mc_decls.ploadop+8],	al
    mov       [mc_decls.ploadop+7],	al
    mov       al,	17
    mov       [mc_decls.ploadop+1],	al
    mov       al,	18
    mov       [mc_decls.ploadop+2],	al
    mov       al,	12
    mov       [mc_decls.ploadop+10],	al
    mov       [mc_decls.ploadop+6],	al
L3562:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc peephole
mc_optim.peephole:
;>>
    %define mc_optim.peephole.m 16
    %define mc_optim.peephole.m2 -8
    %define mc_optim.peephole.m3 -16
    %define mc_optim.peephole.mtarget -24
    %define mc_optim.peephole.lastmcl -32
    %define mc_optim.peephole.lab1 -40
    %define mc_optim.peephole.lab2 -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mc_optim.peephole.lastmcl],	rax
    movzx     rax,	byte [mc_decls.fppeephole]
    test      rax,	rax
    jnz       L3568
    jmp       L3566
L3568:
L3567:
L3569:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax]
    mov       [rbp + mc_optim.peephole.m2],	r10
    jmp       L3572
L3571:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax]
    mov       [rbp + mc_optim.peephole.m2],	r10
L3572:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    test      rax,	rax
    jz        L3574
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	3
    jz        L3571
    cmp       r10,	5
    jz        L3571
L3574:
L3573:
    mov       rax,	[rbp + mc_optim.peephole.m]
    movzx     r10,	byte [rax+24]
    sub       r10,	1
    cmp       r10,	42
    jae       L3577
    lea       rax,	[rel L3576]
    jmp       [rax + r10*8]
    segment .data
L3576:
    dq  L3578
    dq  L3579
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3597
    dq  L3577
    dq  L3577
    dq  L3629
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3594
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3580
    dq  L3583
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3577
    dq  L3624
    dq  L3588
    segment .text
L3578:
    jmp       L3575
L3579:
    jmp       L3570
L3580:
;dojmp:
L3581:
    jmp       L3582
L3583:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	26
    jz        L3585
    jmp       L3581
L3585:
L3584:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    mov       [rbp + mc_optim.peephole.lab1],	rax
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax]
    mov       [rbp + mc_optim.peephole.m3],	r10
    mov       rax,	[rbp + mc_optim.peephole.m3]
    movzx     r10,	byte [rax+24]
    cmp       r10,	9
    jnz       L3587
    mov       rax,	[rbp + mc_optim.peephole.m3]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    cmp       rax,	[rbp + mc_optim.peephole.lab1]
    jnz       L3587
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    mov       rax,	[r10]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mc_optim.peephole.m]
    movzx     r10,	byte [rax+25]
    lea       rax,	[mc_decls.asmrevcond]
    mov       r11,	[rax + r10*8]
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       [rax+25],	r11b
    mov       rcx,	[rbp + mc_optim.peephole.m2]
    mov       rdx,	102
    call      mc_optim.deletemcl
L3587:
L3586:
    jmp       L3575
L3588:
    mov       rax,	[rbp + mc_optim.peephole.lastmcl]
    movzx     r10,	byte [rax+24]
    cmp       r10,	39
    jz        L3590
    cmp       r10,	40
    jz        L3590
    cmp       r10,	41
    jz        L3590
    jmp       L3591
L3590:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r11,	[rax+8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_optim.sameregopnd
    test      rax,	rax
    jz        L3593
    mov       rax,	[rbp + mc_optim.peephole.lastmcl]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r11,	[rax+8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_optim.sameregopnd
    test      rax,	rax
    jz        L3593
    mov       rcx,	[rbp + mc_optim.peephole.m]
    mov       rdx,	103
    call      mc_optim.deletemcl
L3593:
L3592:
L3591:
L3589:
    jmp       L3575
L3594:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    movzx     rax,	word [r10+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3596
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    movzx     rax,	word [r10+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3596
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    movzx     rax,	word [r10+8]
    and       rax,	31
    cmp       rax,	4
    jge       L3596
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+8],	rax
L3596:
L3595:
    jmp       L3575
L3597:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3599
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isregopnd
    test      rax,	rax
    jz        L3599
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3601
    mov       rax,	[rbp + mc_optim.peephole.m2]
    lea       rax,	[rax+39]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L3601
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    movzx     rax,	word [r10+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3601
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       [rax+16],	r10
    mov       rcx,	[rbp + mc_optim.peephole.m]
    mov       rdx,	106
    call      mc_optim.deletemcl
    jmp       L3582
L3601:
L3600:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jnz       L3603
    jmp       L3582
L3603:
L3602:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax]
    mov       [rbp + mc_optim.peephole.m3],	r10
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	43
    jnz       L3605
    mov       rax,	[rbp + mc_optim.peephole.m3]
    movzx     r10,	byte [rax+24]
    cmp       r10,	27
    jnz       L3605
    mov       rax,	[rbp + mc_optim.peephole.m3]
    lea       rax,	[rax+39]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L3605
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       [rax+8],	r10
    mov       rcx,	[rbp + mc_optim.peephole.m]
    mov       rdx,	107
    call      mc_optim.deletemcl
    jmp       L3604
L3605:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	42
    jnz       L3606
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3606
    mov       rax,	[rbp + mc_optim.peephole.m3]
    movzx     r10,	byte [rax+24]
    cmp       r10,	27
    jnz       L3606
    mov       rax,	[rbp + mc_optim.peephole.m3]
    lea       rax,	[rax+39]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L3606
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       [rax+8],	r10
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       [rax+16],	r10
    mov       rcx,	[rbp + mc_optim.peephole.m]
    mov       rdx,	108
    call      mc_optim.deletemcl
    jmp       L3604
L3606:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	53
    jz        L3608
    cmp       r10,	54
    jnz       L3607
L3608:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3607
    mov       al,	15
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+24],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	53
    jnz       L3610
    mov       rax,	1
    jmp       L3609
L3610:
    mov       rax,	-1
L3609:
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       r11,	[r10+16]
    movzx     r10,	byte [r11+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+16],	rax
    mov       rcx,	[rbp + mc_optim.peephole.m2]
    mov       rdx,	120
    call      mc_optim.deletemcl
    jmp       L3569
L3607:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	29
    jz        L3612
    cmp       r10,	30
    jnz       L3611
L3612:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3611
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isconst
    test      rax,	rax
    jz        L3614
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rax,	[r10]
    cmp       rax,	-2147483648
    jl        L3614
    cmp       rax,	2147483647
    jg        L3614
    mov       al,	15
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+24],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	29
    jnz       L3616
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rax,	[r10]
    jmp       L3615
L3616:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rax,	[r10]
    neg       rax
L3615:
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       r11,	[r10+16]
    movzx     r10,	byte [r11+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+16],	rax
    mov       rcx,	[rbp + mc_optim.peephole.m2]
    mov       rdx,	121
    call      mc_optim.deletemcl
    jmp       L3569
L3614:
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isregopnd
    test      rax,	rax
    jz        L3617
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	29
    jnz       L3617
    mov       al,	15
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+24],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    movzx     rax,	byte [r10+10]
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       r11,	[r10+16]
    movzx     r10,	byte [r11+10]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       r10,	[rbp + mc_optim.peephole.m]
    mov       [r10+16],	rax
    mov       rcx,	[rbp + mc_optim.peephole.m2]
    mov       rdx,	122
    call      mc_optim.deletemcl
    jmp       L3569
L3617:
L3613:
L3611:
L3604:
L3599:
L3598:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    movzx     rax,	word [r10+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3619
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	12
    jnz       L3619
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    movzx     rax,	word [r10+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3619
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    movzx     rax,	byte [r10+10]
    mov       r10,	[rbp + mc_optim.peephole.m2]
    mov       r11,	[r10+8]
    movzx     r10,	byte [r11+10]
    cmp       rax,	r10
    jnz       L3619
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r11,	[rax+8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_optim.sameoperand
    test      rax,	rax
    jz        L3619
    mov       rcx,	[rbp + mc_optim.peephole.m2]
    mov       rdx,	141
    call      mc_optim.deletemcl
L3619:
L3618:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    movzx     rax,	word [r10+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3621
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	12
    jnz       L3621
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    movzx     rax,	word [r10+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3621
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    movzx     rax,	word [r10+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3623
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r11,	[rax+8]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_optim.sameoperand
    test      rax,	rax
    jz        L3623
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    movzx     rax,	byte [r10+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       r10,	[rbp + mc_optim.peephole.m2]
    mov       [r10+16],	rax
L3623:
L3622:
L3621:
L3620:
    jmp       L3575
L3624:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3626
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3626
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3628
    mov       rax,	[rbp + mc_optim.peephole.m2]
    lea       rax,	[rax+39]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L3628
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r10,	[rbp + mc_optim.peephole.m2]
    mov       [r10+16],	rax
    mov       rcx,	[rbp + mc_optim.peephole.m]
    mov       rdx,	110
    call      mc_optim.deletemcl
L3628:
L3627:
L3626:
L3625:
    jmp       L3575
L3629:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3631
    mov       rax,	[rbp + mc_optim.peephole.m2]
    movzx     r10,	byte [rax+24]
    cmp       r10,	12
    jnz       L3631
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_optim.isregopnd
    test      rax,	rax
    jz        L3633
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3633
    mov       rax,	[rbp + mc_optim.peephole.m2]
    lea       rax,	[rax+39]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L3633
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       [rax+8],	r10
    mov       rcx,	[rbp + mc_optim.peephole.m2]
    mov       rdx,	131
    call      mc_optim.deletemcl
L3633:
L3632:
L3631:
L3630:
L3577:
L3575:
;skip:
L3582:
    mov       rax,	[rbp + mc_optim.peephole.m]
    mov       [rbp + mc_optim.peephole.lastmcl],	rax
    mov       rax,	[rbp + mc_optim.peephole.m2]
    mov       [rbp + mc_optim.peephole.m],	rax
    jmp       L3569
L3570:
L3566:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc isreg
mc_optim.isreg:
;>>
    %define mc_optim.isreg.a 16
    %define mc_optim.isreg.reg 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_optim.isreg.a]
    test      rax,	rax
    jnz       L3636
    xor       eax,	eax
    jmp       L3634
L3636:
L3635:
    mov       rax,	[rbp + mc_optim.isreg.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3638
    xor       eax,	eax
    jmp       L3634
L3638:
L3637:
    mov       rax,	[rbp + mc_optim.isreg.reg]
    cmp       rax,	0
    jnz       L3640
    xor       eax,	eax
    jmp       L3634
L3640:
L3639:
    mov       rax,	[rbp + mc_optim.isreg.a]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + mc_optim.isreg.reg]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
L3634:
;---------------
    pop       rbp
    ret       
;End 
;Proc isreg0
mc_optim.isreg0:
;>>
    %define mc_optim.isreg0.a 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_optim.isreg0.a]
    test      rax,	rax
    jnz       L3643
    xor       eax,	eax
    jmp       L3641
L3643:
L3642:
    mov       rax,	[rbp + mc_optim.isreg0.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3645
    mov       rax,	[rbp + mc_optim.isreg0.a]
    movzx     r10,	byte [rax+10]
    cmp       r10,	1
    jnz       L3645
    mov       rax,	1
    jmp       L3641
L3645:
L3644:
    xor       eax,	eax
L3641:
;---------------
    pop       rbp
    ret       
;End 
;Proc isregopnd
mc_optim.isregopnd:
;>>
    %define mc_optim.isregopnd.a 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_optim.isregopnd.a]
    test      rax,	rax
    jnz       L3648
    xor       eax,	eax
    jmp       L3646
L3648:
L3647:
    mov       rax,	[rbp + mc_optim.isregopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jnz       L3650
    mov       rax,	[rbp + mc_optim.isregopnd.a]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_decls.isregvar]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L3650
    mov       rax,	1
    jmp       L3646
L3650:
L3649:
    xor       eax,	eax
L3646:
;---------------
    pop       rbp
    ret       
;End 
;Proc isconst
mc_optim.isconst:
;>>
    %define mc_optim.isconst.a 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_optim.isconst.a]
    test      rax,	rax
    jnz       L3653
    xor       eax,	eax
    jmp       L3651
L3653:
L3652:
    mov       rax,	[rbp + mc_optim.isconst.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jnz       L3655
    mov       rax,	[rbp + mc_optim.isconst.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	1
    jnz       L3655
    mov       rax,	1
    jmp       L3651
L3655:
L3654:
    xor       eax,	eax
L3651:
;---------------
    pop       rbp
    ret       
;End 
;Proc deletemcl
mc_optim.deletemcl:
;>>
    %define mc_optim.deletemcl.m 16
    %define mc_optim.deletemcl.id 24
    %define mc_optim.deletemcl.str -128
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+16],	rcx
;---------------
    mov       al,	5
    mov       r10,	[rbp + mc_optim.deletemcl.m]
    mov       [r10+24],	al
L3656:
;---------------
    add       rsp,	128
    pop       rbp
    ret       
;End 
;Proc sameoperand
mc_optim.sameoperand:
;>>
    %define mc_optim.sameoperand.a 16
    %define mc_optim.sameoperand.b 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_optim.sameoperand.a]
    mov       rdx,	[rbp + mc_optim.sameoperand.b]
    mov       r8,	16
    call      memcmp
    movsxd    rax,	eax
    cmp       rax,	0
    setz      al
    movzx     eax,	al
L3657:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc sameregopnd
mc_optim.sameregopnd:
;>>
    %define mc_optim.sameregopnd.a 16
    %define mc_optim.sameregopnd.b 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_optim.sameregopnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    mov       rax,	[rbp + mc_optim.sameregopnd.b]
    movzx     r11,	word [rax+8]
    shr       r11,	9
    and       r11,	7
    cmp       r11,	r10
    jnz       L3661
    cmp       r11,	1
    jz        L3660
L3661:
    xor       eax,	eax
    jmp       L3658
L3660:
L3659:
    mov       rax,	[rbp + mc_optim.sameregopnd.a]
    movzx     r10,	byte [rax+10]
    mov       rax,	[rbp + mc_optim.sameregopnd.b]
    movzx     r11,	byte [rax+10]
    cmp       r10,	r11
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L3658:
;---------------
    pop       rbp
    ret       
;End 
;Proc getopnd
mc_stackmcl.getopnd:
;>>
    %define mc_stackmcl.getopnd.n 16
    %define mc_stackmcl.getopnd.mode 24
    %define mc_stackmcl.getopnd.reg 32
    %define mc_stackmcl.getopnd.ax -8
    %define mc_stackmcl.getopnd.bx -16
    %define mc_stackmcl.getopnd.a -24
    %define mc_stackmcl.getopnd.d -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.getopnd.n]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_stackmcl.getopnd.a],	r11
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.getopnd.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jz        L3664
    cmp       r11,	2
    jz        L3665
    jmp       L3666
L3664:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.getopnd.n]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgenreg
    jmp       L3662
L3665:
    mov       rcx,	[rbp + mc_stackmcl.getopnd.n]
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgentemp
    mov       [rbp + mc_stackmcl.getopnd.bx],	rax
    mov       rax,	[rbp + mc_stackmcl.getopnd.bx]
    jmp       L3662
L3666:
L3663:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    movzx     r10,	byte [rax+1]
    cmp       r10,	1
    jz        L3668
    cmp       r10,	2
    jz        L3669
    cmp       r10,	4
    jz        L3670
    cmp       r10,	5
    jz        L3671
    cmp       r10,	6
    jz        L3671
    cmp       r10,	7
    jz        L3672
    jmp       L3673
L3668:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       [rbp + mc_stackmcl.getopnd.d],	r10
    mov       rax,	[rbp + mc_stackmcl.getopnd.mode]
    cmp       rax,	11
    jnz       L3675
    mov       rax,	[rbp + mc_stackmcl.getopnd.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	5
    jz        L3675
    mov       rax,	6
    mov       [rbp + mc_stackmcl.getopnd.mode],	rax
    jmp       L3669
L3675:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
L3674:
    jmp       L3667
L3669:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       [rbp + mc_stackmcl.getopnd.d],	r10
    mov       rax,	[rbp + mc_stackmcl.getopnd.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	5
    jnz       L3677
    mov       rax,	[rbp + mc_stackmcl.getopnd.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jnz       L3677
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
    jmp       L3676
L3677:
    mov       rcx,	[rbp + mc_stackmcl.getopnd.reg]
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgenmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_stackmcl.getopnd.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
L3676:
    jmp       L3667
L3670:
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r11,	byte [r10 + rax]
    cmp       r11,	2
    jz        L3679
    cmp       r11,	4
    jz        L3680
    jmp       L3681
L3679:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    lea       rax,	[rax+8]
    mov       r10,	65535
    and       [rax],	r10
    jmp       L3678
L3680:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    lea       rax,	[rax+8]
    mov       r10,	4294967295
    and       [rax],	r10
L3681:
L3678:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgenint
    mov       [rbp + mc_stackmcl.getopnd.bx],	rax
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    cmp       r10,	-2147483648
    jl        L3683
    cmp       r10,	2147483647
    jg        L3683
    mov       rax,	[rbp + mc_stackmcl.getopnd.bx]
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
    jmp       L3682
L3683:
    mov       rcx,	[rbp + mc_stackmcl.getopnd.reg]
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_stackmcl.getopnd.ax]
    mov       r8,	[rbp + mc_stackmcl.getopnd.bx]
    call      mc_libmcl.genmc
L3682:
    jmp       L3667
L3671:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_libmcl.mgenrealmem
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
    jmp       L3667
L3672:
    mov       rcx,	[rbp + mc_stackmcl.getopnd.reg]
    mov       rdx,	[rbp + mc_stackmcl.getopnd.mode]
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_stackmcl.getopnd.ax],	rax
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	15
    mov       rdx,	[rbp + mc_stackmcl.getopnd.ax]
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3667
L3673:
;error:
L3684:
    mov       rax,	[rbp + mc_stackmcl.getopnd.a]
    movzx     r10,	byte [rax+1]
    lea       rax,	[pc_tables.opndnames]
    mov       r11,	[rax + r10*8]
    lea       rcx,	[rel L5905]
    mov       rdx,	r11
    call      mc_libmcl.merror
L3667:
    mov       rax,	[rbp + mc_stackmcl.getopnd.ax]
L3662:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc loadopnd
mc_stackmcl.loadopnd:
;>>
    %define mc_stackmcl.loadopnd.n 16
    %define mc_stackmcl.loadopnd.mode 24
    %define mc_stackmcl.loadopnd.reg 32
    %define mc_stackmcl.loadopnd.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mc_stackmcl.loadopnd.n]
    mov       rdx,	[rbp + mc_stackmcl.loadopnd.mode]
    mov       r8,	[rbp + mc_stackmcl.loadopnd.reg]
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_stackmcl.loadopnd.ax],	rax
    mov       rcx,	[rbp + mc_stackmcl.loadopnd.ax]
    mov       rdx,	[rbp + mc_stackmcl.loadopnd.mode]
    mov       r8,	[rbp + mc_stackmcl.loadopnd.reg]
    call      mc_stackmcl.loadtoreg
    mov       [rbp + mc_stackmcl.loadopnd.ax],	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[rbp + mc_stackmcl.loadopnd.n]
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[rbp + mc_stackmcl.loadopnd.n]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.loadopnd.ax]
    movzx     r10,	byte [rax+10]
    lea       rax,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_stackmcl.loadopnd.n]
    mov       [rax + r11-1],	r10b
    mov       rax,	[rbp + mc_stackmcl.loadopnd.ax]
L3685:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc loadparam
mc_stackmcl.loadparam:
;>>
    %define mc_stackmcl.loadparam.n 16
    %define mc_stackmcl.loadparam.mode 24
    %define mc_stackmcl.loadparam.reg 32
    %define mc_stackmcl.loadparam.ax -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mc_stackmcl.loadparam.n]
    mov       rdx,	[rbp + mc_stackmcl.loadparam.mode]
    mov       r8,	[rbp + mc_stackmcl.loadparam.reg]
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_stackmcl.loadparam.ax],	rax
    mov       rcx,	[rbp + mc_stackmcl.loadparam.ax]
    mov       rdx,	[rbp + mc_stackmcl.loadparam.mode]
    mov       r8,	[rbp + mc_stackmcl.loadparam.reg]
    call      mc_stackmcl.loadtoreg_m
    mov       [rbp + mc_stackmcl.loadparam.ax],	rax
    mov       rax,	[rbp + mc_stackmcl.loadparam.ax]
L3686:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pushopnd
mc_stackmcl.pushopnd:
;>>
    %define mc_stackmcl.pushopnd.n 16
    %define mc_stackmcl.pushopnd.mode 24
    %define mc_stackmcl.pushopnd.ax -8
    %define mc_stackmcl.pushopnd.bx -16
    %define mc_stackmcl.pushopnd.p -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.pushopnd.n]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_stackmcl.pushopnd.p],	r11
    mov       rax,	[rbp + mc_stackmcl.pushopnd.mode]
    cmp       rax,	0
    jnz       L3689
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_stackmcl.pushopnd.n]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.pushopnd.mode],	r11
L3689:
L3688:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.pushopnd.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3691
    mov       rax,	[rbp + mc_stackmcl.pushopnd.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	1
    jz        L3693
    cmp       r10,	4
    jz        L3694
    cmp       r10,	5
    jz        L3695
    jmp       L3696
L3693:
    lea       rax,	[pc_tables.psize]
    mov       r10,	[rbp + mc_stackmcl.pushopnd.mode]
    movzx     r11,	byte [rax + r10]
    cmp       r11,	8
    jnz       L3698
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rbp + mc_stackmcl.pushopnd.p]
    mov       r11,	[r10+8]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_stackmcl.pushopnd.ax],	rax
    jmp       L3699
L3698:
L3697:
    jmp       L3692
L3694:
    mov       rax,	[rbp + mc_stackmcl.pushopnd.p]
    mov       r10,	[rax+8]
    cmp       r10,	-2147483648
    jl        L3701
    cmp       r10,	2147483647
    jg        L3701
    mov       rax,	[rbp + mc_stackmcl.pushopnd.p]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_stackmcl.pushopnd.ax],	rax
    jmp       L3699
L3701:
L3700:
    jmp       L3692
L3695:
    mov       rax,	[rbp + mc_stackmcl.pushopnd.p]
    movq      XMM4,	[rax+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       [rbp + mc_stackmcl.pushopnd.ax],	rax
    jmp       L3699
L3696:
L3692:
L3691:
L3690:
    mov       rcx,	[rbp + mc_stackmcl.pushopnd.n]
    mov       rdx,	[rbp + mc_stackmcl.pushopnd.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       [rbp + mc_stackmcl.pushopnd.ax],	rax
    mov       rax,	[rbp + mc_stackmcl.pushopnd.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3703
    mov       rax,	[rbp + mc_stackmcl.pushopnd.ax]
    mov       [rbp + mc_stackmcl.pushopnd.bx],	rax
    mov       rax,	[rbp + mc_stackmcl.pushopnd.mode]
    cmp       rax,	4
    jnz       L3705
    mov       rax,	5
    jmp       L3704
L3705:
    mov       rax,	6
L3704:
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       [rbp + mc_stackmcl.pushopnd.ax],	rax
    mov       rcx,	12
    mov       rdx,	[rbp + mc_stackmcl.pushopnd.ax]
    mov       r8,	[rbp + mc_stackmcl.pushopnd.bx]
    call      mc_libmcl.genmc
L3703:
L3702:
;pushit:
L3699:
    mov       rcx,	[rbp + mc_stackmcl.pushopnd.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword [mc_decls.mstackdepth]
L3687:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc loadtoreg
mc_stackmcl.loadtoreg:
;>>
    %define mc_stackmcl.loadtoreg.ax 16
    %define mc_stackmcl.loadtoreg.mode 24
    %define mc_stackmcl.loadtoreg.reg 32
    %define mc_stackmcl.loadtoreg.bx -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_stackmcl.loadtoreg.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3709
    cmp       r10,	5
    jnz       L3708
L3709:
    mov       rax,	[rbp + mc_stackmcl.loadtoreg.ax]
    jmp       L3706
L3708:
L3707:
    mov       rcx,	[rbp + mc_stackmcl.loadtoreg.reg]
    mov       rdx,	[rbp + mc_stackmcl.loadtoreg.mode]
    call      mc_stackmcl.getworkreg_rm
    mov       [rbp + mc_stackmcl.loadtoreg.bx],	rax
    mov       rcx,	[rbp + mc_stackmcl.loadtoreg.bx]
    mov       rdx,	[rbp + mc_stackmcl.loadtoreg.ax]
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	[rbp + mc_stackmcl.loadtoreg.bx]
L3706:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc loadtoreg_m
mc_stackmcl.loadtoreg_m:
;>>
    %define mc_stackmcl.loadtoreg_m.ax 16
    %define mc_stackmcl.loadtoreg_m.mode 24
    %define mc_stackmcl.loadtoreg_m.reg 32
    %define mc_stackmcl.loadtoreg_m.bx -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_m.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3713
    cmp       r10,	5
    jnz       L3712
L3713:
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_m.ax]
    movzx     r10,	byte [rax+10]
    cmp       r10,	[rbp + mc_stackmcl.loadtoreg_m.reg]
    jnz       L3715
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_m.ax]
    jmp       L3710
L3715:
L3714:
L3712:
L3711:
    mov       rcx,	[rbp + mc_stackmcl.loadtoreg_m.reg]
    mov       rdx,	[rbp + mc_stackmcl.loadtoreg_m.mode]
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.loadtoreg_m.bx],	rax
    mov       rcx,	[rbp + mc_stackmcl.loadtoreg_m.bx]
    mov       rdx,	[rbp + mc_stackmcl.loadtoreg_m.ax]
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_m.bx]
L3710:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc loadtoreg_common
mc_stackmcl.loadtoreg_common:
;>>
    %define mc_stackmcl.loadtoreg_common.bx 16
    %define mc_stackmcl.loadtoreg_common.ax 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_common.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	2
    jnz       L3718
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_common.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	1
    jnz       L3718
    mov       rax,	[rbp + mc_stackmcl.loadtoreg_common.ax]
    mov       r10,	[rax]
    cmp       r10,	0
    jnz       L3718
    mov       rcx,	[rbp + mc_stackmcl.loadtoreg_common.bx]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_stackmcl.loadtoreg_common.bx],	rax
    mov       rcx,	41
    mov       rdx,	[rbp + mc_stackmcl.loadtoreg_common.bx]
    mov       r8,	[rbp + mc_stackmcl.loadtoreg_common.bx]
    call      mc_libmcl.genmc
    jmp       L3717
L3718:
    mov       rcx,	12
    mov       rdx,	[rbp + mc_stackmcl.loadtoreg_common.bx]
    mov       r8,	[rbp + mc_stackmcl.loadtoreg_common.ax]
    call      mc_libmcl.genmc
L3717:
L3716:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc pushpcl
mc_stackmcl.pushpcl:
;>>
    %define mc_stackmcl.pushpcl.p 16
    %define mc_stackmcl.pushpcl.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	20
    jl        L3721
    lea       rcx,	[rel L5906]
    lea       rdx,	[rel L5907]
    call      mc_libmcl.merror
L3721:
L3720:
    inc       qword [mc_decls.noperands]
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_stackmcl.pushpcl.n],	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[rbp + mc_stackmcl.pushpcl.n]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.pushpcl.p]
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[rbp + mc_stackmcl.pushpcl.n]
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_stackmcl.pushpcl.n]
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	[rbp + mc_stackmcl.pushpcl.n]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.pushpcl.p]
    movzx     r10,	byte [rax+3]
    lea       rax,	[mc_decls.pclmode]
    mov       r11,	[rbp + mc_stackmcl.pushpcl.n]
    mov       [rax + r11-1],	r10b
L3719:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc pushpcl_reg
mc_stackmcl.pushpcl_reg:
;>>
    %define mc_stackmcl.pushpcl_reg.mode 16
    %define mc_stackmcl.pushpcl_reg.reg 24
    %define mc_stackmcl.pushpcl_reg.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	20
    jl        L3724
    lea       rcx,	[rel L5908]
    lea       rdx,	[rel L5909]
    call      mc_libmcl.merror
L3724:
L3723:
    mov       rax,	[rbp + mc_stackmcl.pushpcl_reg.reg]
    cmp       rax,	0
    jnz       L3726
    mov       rcx,	[rbp + mc_stackmcl.pushpcl_reg.mode]
    call      mc_stackmcl.getworkreg
    mov       [rbp + mc_stackmcl.pushpcl_reg.reg],	rax
L3726:
L3725:
    inc       qword [mc_decls.noperands]
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_stackmcl.pushpcl_reg.n],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.n]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.n]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rbp + mc_stackmcl.pushpcl_reg.reg]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.n]
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.n]
    mov       [r10 + r11-1],	al
    mov       al,	[rbp + mc_stackmcl.pushpcl_reg.mode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.n]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.pushpcl_reg.mode]
    cmp       rax,	2
    jg        L3728
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.reg]
    mov       [r10 + r11-1],	al
    jmp       L3727
L3728:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.pushpcl_reg.reg]
    mov       [r10 + r11-1],	al
L3727:
L3722:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc poppcl
mc_stackmcl.poppcl:
;>>
    %define mc_stackmcl.poppcl.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_stackmcl.poppcl.n],	rax
    mov       rax,	[rbp + mc_stackmcl.poppcl.n]
    cmp       rax,	0
    jg        L3731
    lea       rcx,	[rel L5910]
    lea       rdx,	[rel L5911]
    call      mc_libmcl.merror
L3731:
L3730:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[rbp + mc_stackmcl.poppcl.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jle       L3733
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[rbp + mc_stackmcl.poppcl.n]
    lea       rax,	[rax + r10-1]
    dec       byte [rax]
    jmp       L3729
L3733:
L3732:
    dec       qword [mc_decls.noperands]
L3729:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc duplpcl
mc_stackmcl.duplpcl:
;>>
    %define mc_stackmcl.duplpcl.mode -8
    %define mc_stackmcl.duplpcl.$T1 -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.duplpcl.mode],	r11
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	[rbp + mc_stackmcl.duplpcl.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	[rbp + mc_stackmcl.duplpcl.mode]
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    lea       rcx,	[rel L5912]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_stackmcl.duplpcl.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_stackmcl.duplpcl.$T1],	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	[rbp + mc_stackmcl.duplpcl.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
L3734:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getworkireg
mc_stackmcl.getworkireg:
;>>
    %define mc_stackmcl.getworkireg.r -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mc_stackmcl.getworkireg.r],	rax
L3736:
    lea       rax,	[mc_decls.workregs]
    mov       r10,	[rbp + mc_stackmcl.getworkireg.r]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L3740
    lea       rax,	[mc_decls.regset]
    mov       r10,	[rbp + mc_stackmcl.getworkireg.r]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3740
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.getworkireg.r]
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.spillregs]
    mov       r11,	[rbp + mc_stackmcl.getworkireg.r]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.getworkireg.r]
    jmp       L3735
L3740:
L3739:
L3737:
    mov       rax,	[rbp + mc_stackmcl.getworkireg.r]
    inc       rax
    mov       [rbp + mc_stackmcl.getworkireg.r],	rax
    cmp       rax,	14
    jle       L3736
L3738:
    lea       rcx,	[rel L5913]
    lea       rdx,	[rel L5914]
    call      mc_libmcl.merror
    xor       eax,	eax
L3735:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getworkxreg
mc_stackmcl.getworkxreg:
;>>
    %define mc_stackmcl.getworkxreg.r -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	5
    mov       [rbp + mc_stackmcl.getworkxreg.r],	rax
L3742:
    lea       rax,	[mc_decls.workxregs]
    mov       r10,	[rbp + mc_stackmcl.getworkxreg.r]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L3746
    lea       rax,	[mc_decls.xregset]
    mov       r10,	[rbp + mc_stackmcl.getworkxreg.r]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3746
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_stackmcl.getworkxreg.r]
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.spillxregs]
    mov       r11,	[rbp + mc_stackmcl.getworkxreg.r]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.getworkxreg.r]
    jmp       L3741
L3746:
L3745:
L3743:
    mov       rax,	[rbp + mc_stackmcl.getworkxreg.r]
    inc       rax
    mov       [rbp + mc_stackmcl.getworkxreg.r],	rax
    cmp       rax,	16
    jle       L3742
L3744:
    lea       rcx,	[rel L5915]
    lea       rdx,	[rel L5916]
    call      mc_libmcl.merror
    xor       eax,	eax
L3741:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getworkregm
mc_stackmcl.getworkregm:
;>>
    %define mc_stackmcl.getworkregm.mode 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_stackmcl.getworkregm.mode]
    call      mc_stackmcl.getworkreg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_stackmcl.getworkregm.mode]
    call      mc_libmcl.mgenreg
L3747:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getworkreg
mc_stackmcl.getworkreg:
;>>
    %define mc_stackmcl.getworkreg.mode 16
    %define mc_stackmcl.getworkreg.reg -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_stackmcl.getworkreg.mode]
    cmp       rax,	2
    jg        L3750
    call      mc_stackmcl.getworkxreg
    jmp       L3749
L3750:
    call      mc_stackmcl.getworkireg
L3749:
L3748:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getworkreg_rm
mc_stackmcl.getworkreg_rm:
;>>
    %define mc_stackmcl.getworkreg_rm.reg 16
    %define mc_stackmcl.getworkreg_rm.mode 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_stackmcl.getworkreg_rm.reg]
    cmp       rax,	0
    jz        L3754
    cmp       rax,	15
    jnz       L3753
L3754:
    mov       rcx,	[rbp + mc_stackmcl.getworkreg_rm.mode]
    call      mc_stackmcl.getworkregm
    jmp       L3751
L3753:
L3752:
    mov       rcx,	[rbp + mc_stackmcl.getworkreg_rm.reg]
    mov       rdx,	[rbp + mc_stackmcl.getworkreg_rm.mode]
    call      mc_libmcl.mgenreg
L3751:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc start
mc_stackmcl.start:
;>>
    %define mc_stackmcl.start.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    mov       rax,	1
    mov       [rbp + mc_stackmcl.start.i],	rax
L3756:
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       r11,	[rbp + mc_stackmcl.start.i]
    mov       [r10 + r11-1],	al
L3757:
    mov       rax,	[rbp + mc_stackmcl.start.i]
    inc       rax
    mov       [rbp + mc_stackmcl.start.i],	rax
    cmp       rax,	10
    jle       L3756
L3758:
    mov       rax,	5
    mov       [rbp + mc_stackmcl.start.i],	rax
L3759:
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       r11,	[rbp + mc_stackmcl.start.i]
    mov       [r10 + r11-1],	al
L3760:
    mov       rax,	[rbp + mc_stackmcl.start.i]
    inc       rax
    mov       [rbp + mc_stackmcl.start.i],	rax
    cmp       rax,	16
    jle       L3759
L3761:
L3755:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc freeireg
mc_stackmcl.freeireg:
;>>
    %define mc_stackmcl.freeireg.reg 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.freeireg.reg]
    mov       [r10 + r11-1],	al
L3762:
;---------------
    pop       rbp
    ret       
;End 
;Proc freexreg
mc_stackmcl.freexreg:
;>>
    %define mc_stackmcl.freexreg.reg 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_stackmcl.freexreg.reg]
    mov       [r10 + r11-1],	al
L3763:
;---------------
    pop       rbp
    ret       
;End 
;Proc freereg
mc_stackmcl.freereg:
;>>
    %define mc_stackmcl.freereg.reg 16
    %define mc_stackmcl.freereg.mode 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_stackmcl.freereg.mode]
    cmp       rax,	2
    jg        L3766
    xor       eax,	eax
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_stackmcl.freereg.reg]
    mov       [r10 + r11-1],	al
    jmp       L3765
L3766:
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.freereg.reg]
    mov       [r10 + r11-1],	al
L3765:
L3764:
;---------------
    pop       rbp
    ret       
;End 
;Proc saveopnd
mc_stackmcl.saveopnd:
;>>
    %define mc_stackmcl.saveopnd.n 16
    %define mc_stackmcl.saveopnd.allregs 24
    %define mc_stackmcl.saveopnd.reg -8
    %define mc_stackmcl.saveopnd.mode -16
    %define mc_stackmcl.saveopnd.tx -24
    %define mc_stackmcl.saveopnd.$T1 -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.saveopnd.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jz        L3769
    jmp       L3767
L3769:
L3768:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.saveopnd.n]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.saveopnd.reg],	r11
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_stackmcl.saveopnd.n]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.saveopnd.mode],	r11
    mov       rax,	[rbp + mc_stackmcl.saveopnd.mode]
    cmp       rax,	2
    jle       L3771
    mov       rax,	[rbp + mc_stackmcl.saveopnd.allregs]
    test      rax,	rax
    jnz       L3774
    mov       rax,	[rbp + mc_stackmcl.saveopnd.reg]
    cmp       rax,	4
    jl        L3775
    cmp       rax,	10
    jle       L3773
L3775:
L3774:
    mov       rcx,	[rbp + mc_stackmcl.saveopnd.reg]
    mov       rdx,	[rbp + mc_stackmcl.saveopnd.mode]
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	[rbp + mc_stackmcl.saveopnd.n]
    mov       rdx,	[rbp + mc_stackmcl.saveopnd.mode]
    call      mc_libmcl.mgentemp
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3773:
L3772:
    jmp       L3770
L3771:
    mov       rax,	[rbp + mc_stackmcl.saveopnd.allregs]
    test      rax,	rax
    jnz       L3778
    mov       rax,	[rbp + mc_stackmcl.saveopnd.reg]
    cmp       rax,	1
    jl        L3777
    cmp       rax,	6
    jg        L3777
L3778:
    mov       rcx,	[rbp + mc_stackmcl.saveopnd.reg]
    mov       rdx,	[rbp + mc_stackmcl.saveopnd.mode]
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	[rbp + mc_stackmcl.saveopnd.n]
    mov       rdx,	[rbp + mc_stackmcl.saveopnd.mode]
    call      mc_libmcl.mgentemp
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3777:
L3776:
L3770:
    mov       al,	2
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[rbp + mc_stackmcl.saveopnd.n]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_stackmcl.saveopnd.n]
    mov       [r10 + r11-1],	al
L3767:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc saveopnds
mc_stackmcl.saveopnds:
;>>
    %define mc_stackmcl.saveopnds.n 16
    %define mc_stackmcl.saveopnds.av_1 -8
    %define mc_stackmcl.saveopnds.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mc_stackmcl.saveopnds.i],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	[rbp + mc_stackmcl.saveopnds.n]
    mov       [rbp + mc_stackmcl.saveopnds.av_1],	rax
    mov       rax,	[rbp + mc_stackmcl.saveopnds.av_1]
    cmp       rax,	1
    jl        L3782
L3780:
    mov       rcx,	[rbp + mc_stackmcl.saveopnds.i]
    xor       edx,	edx
    call      mc_stackmcl.saveopnd
L3781:
    mov       rax,	[rbp + mc_stackmcl.saveopnds.i]
    inc       rax
    mov       [rbp + mc_stackmcl.saveopnds.i],	rax
    cmp       rax,	[rbp + mc_stackmcl.saveopnds.av_1]
    jle       L3780
L3782:
L3779:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc savenextopnd
mc_stackmcl.savenextopnd:
;>>
    %define mc_stackmcl.savenextopnd.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mc_stackmcl.savenextopnd.i],	rax
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3786
L3784:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.savenextopnd.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jnz       L3788
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_stackmcl.savenextopnd.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	2
    jle       L3788
    mov       rcx,	[rbp + mc_stackmcl.savenextopnd.i]
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3783
L3788:
L3787:
L3785:
    mov       rax,	[rbp + mc_stackmcl.savenextopnd.i]
    inc       rax
    mov       [rbp + mc_stackmcl.savenextopnd.i],	rax
    cmp       rax,	[mc_decls.noperands]
    jle       L3784
L3786:
L3783:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc savenextxopnd
mc_stackmcl.savenextxopnd:
;>>
    %define mc_stackmcl.savenextxopnd.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mc_stackmcl.savenextxopnd.i],	rax
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3792
L3790:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.savenextxopnd.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jnz       L3794
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_stackmcl.savenextxopnd.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	2
    jg        L3794
    mov       rcx,	[rbp + mc_stackmcl.savenextxopnd.i]
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3789
L3794:
L3793:
L3791:
    mov       rax,	[rbp + mc_stackmcl.savenextxopnd.i]
    inc       rax
    mov       [rbp + mc_stackmcl.savenextxopnd.i],	rax
    cmp       rax,	[mc_decls.noperands]
    jle       L3790
L3792:
L3789:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc movetoreg
mc_stackmcl.movetoreg:
;>>
    %define mc_stackmcl.movetoreg.newreg 16
    %define mc_stackmcl.movetoreg.oldreg -8
    %define mc_stackmcl.movetoreg.mode -16
    %define mc_stackmcl.movetoreg.$T1 -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.movetoreg.mode],	r11
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	[rbp + mc_stackmcl.movetoreg.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.movetoreg.oldreg],	r11
    mov       rax,	[rbp + mc_stackmcl.movetoreg.oldreg]
    cmp       rax,	[rbp + mc_stackmcl.movetoreg.newreg]
    jnz       L3797
    jmp       L3795
L3797:
L3796:
    lea       rax,	[mc_decls.regset]
    mov       r10,	[rbp + mc_stackmcl.movetoreg.newreg]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L3799
    lea       rcx,	[rel L5917]
    lea       rdx,	[rel L5918]
    call      mc_libmcl.merror
L3799:
L3798:
    mov       rcx,	[rbp + mc_stackmcl.movetoreg.oldreg]
    mov       rdx,	[rbp + mc_stackmcl.movetoreg.mode]
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	[rbp + mc_stackmcl.movetoreg.newreg]
    mov       rdx,	[rbp + mc_stackmcl.movetoreg.mode]
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       al,	[rbp + mc_stackmcl.movetoreg.newreg]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.movetoreg.mode]
    cmp       rax,	2
    jg        L3801
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_stackmcl.movetoreg.newreg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.movetoreg.newreg]
    cmp       rax,	4
    jl        L3803
    mov       rax,	[rbp + mc_stackmcl.movetoreg.newreg]
    cmp       [pc_decls.highxreg],	rax
    jge       L5919
    mov       [pc_decls.highxreg],	rax
L5919:
L3803:
L3802:
    jmp       L3800
L3801:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.movetoreg.newreg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_stackmcl.movetoreg.newreg]
    cmp       rax,	11
    jl        L3805
    mov       rax,	[rbp + mc_stackmcl.movetoreg.newreg]
    cmp       [pc_decls.highreg],	rax
    jge       L5920
    mov       [pc_decls.highreg],	rax
L5920:
L3805:
L3804:
L3800:
L3795:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc getopnd_ind
mc_stackmcl.getopnd_ind:
;>>
    %define mc_stackmcl.getopnd_ind.n 16
    %define mc_stackmcl.getopnd_ind.mode 24
    %define mc_stackmcl.getopnd_ind.a -8
    %define mc_stackmcl.getopnd_ind.d -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.getopnd_ind.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3808
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.getopnd_ind.n]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_stackmcl.getopnd_ind.a],	r11
    mov       rax,	[rbp + mc_stackmcl.getopnd_ind.a]
    movzx     r10,	byte [rax+1]
    cmp       r10,	2
    jnz       L3810
    mov       rax,	[rbp + mc_stackmcl.getopnd_ind.a]
    mov       r10,	[rax+8]
    mov       [rbp + mc_stackmcl.getopnd_ind.d],	r10
    mov       rax,	[rbp + mc_stackmcl.getopnd_ind.d]
    movzx     r10,	byte [rax+49]
    cmp       r10,	5
    jnz       L3813
    mov       rax,	[rbp + mc_stackmcl.getopnd_ind.d]
    movzx     r10,	byte [rax+58]
    cmp       r10,	11
    jz        L3812
L3813:
    mov       rax,	[rbp + mc_stackmcl.getopnd_ind.a]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_stackmcl.getopnd_ind.mode]
    call      mc_libmcl.mgenmem
    jmp       L3806
L3812:
L3811:
L3810:
L3809:
L3808:
L3807:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.getopnd_ind.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jz        L3815
    mov       rcx,	[rbp + mc_stackmcl.getopnd_ind.n]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3815:
L3814:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.getopnd_ind.n]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_stackmcl.getopnd_ind.mode]
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3806:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
;>>
    %define mc_stackmcl.getopnd_ind_simp.n 16
    %define mc_stackmcl.getopnd_ind_simp.mode 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.getopnd_ind_simp.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jz        L3818
    mov       rcx,	[rbp + mc_stackmcl.getopnd_ind_simp.n]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3818:
L3817:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.getopnd_ind_simp.n]
    movzx     r11,	byte [rax + r10-1]
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_stackmcl.getopnd_ind_simp.mode]
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3816:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc swapopnds
mc_stackmcl.swapopnds:
;>>
    %define mc_stackmcl.swapopnds.m 16
    %define mc_stackmcl.swapopnds.n 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.swapopnds.m]
    lea       rax,	[rax + r10*8-8]
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[rbp + mc_stackmcl.swapopnds.n]
    lea       r10,	[r10 + r11*8-8]
    mov       r11,	[rax]
    mov       rdi,	[r10]
    mov       [r10],	r11
    mov       [rax],	rdi
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.swapopnds.m]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[rbp + mc_stackmcl.swapopnds.n]
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       dil,	[r10]
    mov       [r10],	r11b
    mov       [rax],	dil
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.swapopnds.m]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_stackmcl.swapopnds.n]
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       dil,	[r10]
    mov       [r10],	r11b
    mov       [rax],	dil
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_stackmcl.swapopnds.m]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[rbp + mc_stackmcl.swapopnds.n]
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       dil,	[r10]
    mov       [r10],	r11b
    mov       [rax],	dil
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[rbp + mc_stackmcl.swapopnds.m]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	[rbp + mc_stackmcl.swapopnds.n]
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       dil,	[r10]
    mov       [r10],	r11b
    mov       [rax],	dil
L3819:
;---------------
    pop       rbp
    ret       
;End 
;Proc isimmload
mc_stackmcl.isimmload:
;>>
    %define mc_stackmcl.isimmload.n 16
    %define mc_stackmcl.isimmload.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.isimmload.n]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_stackmcl.isimmload.p],	r11
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.isimmload.n]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3822
    mov       rax,	[rbp + mc_stackmcl.isimmload.p]
    movzx     r10,	byte [rax]
    cmp       r10,	1
    jnz       L3822
    mov       rax,	[rbp + mc_stackmcl.isimmload.p]
    movzx     r10,	byte [rax+1]
    cmp       r10,	4
    jnz       L3822
    mov       rax,	[rbp + mc_stackmcl.isimmload.p]
    jmp       L3821
L3822:
    xor       eax,	eax
L3821:
L3820:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc setnewzz
mc_stackmcl.setnewzz:
;>>
    %define mc_stackmcl.setnewzz.reg 16
    %define mc_stackmcl.setnewzz.mode 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rbp + mc_stackmcl.setnewzz.reg]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	[rbp + mc_stackmcl.setnewzz.mode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L3823:
;---------------
    pop       rbp
    ret       
;End 
;Proc freeworkregs
mc_stackmcl.freeworkregs:
;>>
    %define mc_stackmcl.freeworkregs.p 16
    %define mc_stackmcl.freeworkregs.reg -8
    %define mc_stackmcl.freeworkregs.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    lea       rax,	[mc_decls.regset]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rax,	1
    mov       [rbp + mc_stackmcl.freeworkregs.i],	rax
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3827
L3825:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.freeworkregs.i]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.freeworkregs.reg],	r11
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.freeworkregs.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L3829
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[rbp + mc_stackmcl.freeworkregs.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	2
    jg        L3831
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	[rbp + mc_stackmcl.freeworkregs.reg]
    mov       [r10 + r11-1],	al
    jmp       L3830
L3831:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.freeworkregs.reg]
    mov       [r10 + r11-1],	al
L3830:
L3829:
L3828:
L3826:
    mov       rax,	[rbp + mc_stackmcl.freeworkregs.i]
    inc       rax
    mov       [rbp + mc_stackmcl.freeworkregs.i],	rax
    cmp       rax,	[mc_decls.noperands]
    jle       L3825
L3827:
L3824:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc swapopndregs
mc_stackmcl.swapopndregs:
;>>
    %define mc_stackmcl.swapopndregs.reg2 16
    %define mc_stackmcl.swapopndregs.reg1 -8
    %define mc_stackmcl.swapopndregs.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	2
    jg        L3834
    lea       rcx,	[rel L5921]
    lea       rdx,	[rel L5922]
    call      mc_libmcl.merror
L3834:
L3833:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     r11,	byte [rax + r10-1]
    mov       [rbp + mc_stackmcl.swapopndregs.reg1],	r11
    mov       rax,	[rbp + mc_stackmcl.swapopndregs.reg1]
    cmp       rax,	[rbp + mc_stackmcl.swapopndregs.reg2]
    jnz       L3836
    jmp       L3832
L3836:
L3835:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	1
    mov       [rbp + mc_stackmcl.swapopndregs.i],	rax
    mov       rax,	[rbp + mc_stackmcl.swapopndregs.i]
    cmp       rax,	1
    jl        L3840
L3837:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.swapopndregs.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	1
    jnz       L3842
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[rbp + mc_stackmcl.swapopndregs.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	[rbp + mc_stackmcl.swapopndregs.reg2]
    jnz       L3842
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[rbp + mc_stackmcl.swapopndregs.i]
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       dil,	[r10]
    mov       [r10],	r11b
    mov       [rax],	dil
    jmp       L3832
L3842:
L3841:
L3838:
    mov       rax,	[rbp + mc_stackmcl.swapopndregs.i]
    dec       rax
    mov       [rbp + mc_stackmcl.swapopndregs.i],	rax
    cmp       rax,	1
    jge       L3837
L3840:
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	[rbp + mc_stackmcl.swapopndregs.reg1]
    mov       [r10 + r11-1],	al
    mov       al,	[rbp + mc_stackmcl.swapopndregs.reg2]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L3839:
L3832:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc makeopndind
mc_stackmcl.makeopndind:
;>>
    %define mc_stackmcl.makeopndind.a 16
    %define mc_stackmcl.makeopndind.mode 24
    %define mc_stackmcl.makeopndind.b -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_stackmcl.makeopndind.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3845
    lea       rcx,	[rel L5923]
    lea       rdx,	[rel L5924]
    call      mc_libmcl.merror
L3845:
L3844:
    mov       rax,	[rbp + mc_stackmcl.makeopndind.a]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_stackmcl.makeopndind.mode]
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3843:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc makesimpleaddr
mc_stackmcl.makesimpleaddr:
;>>
    %define mc_stackmcl.makesimpleaddr.ax 16
    %define mc_stackmcl.makesimpleaddr.bx -8
    %define mc_stackmcl.makesimpleaddr.newreg -16
    %define mc_stackmcl.makesimpleaddr.reg -24
    %define mc_stackmcl.makesimpleaddr.regix -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.ax]
    movzx     r10,	byte [rax+10]
    mov       [rbp + mc_stackmcl.makesimpleaddr.reg],	r10
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.ax]
    movzx     r10,	byte [rax+11]
    mov       [rbp + mc_stackmcl.makesimpleaddr.regix],	r10
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.reg]
    cmp       rax,	15
    jnz       L3848
    xor       eax,	eax
    mov       [rbp + mc_stackmcl.makesimpleaddr.reg],	rax
L3848:
L3847:
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.ax]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jz        L3850
    lea       rcx,	[rel L5925]
    lea       rdx,	[rel L5926]
    call      mc_libmcl.merror
L3850:
L3849:
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.reg]
    cmp       rax,	0
    jnz       L3852
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.regix]
    cmp       rax,	0
    jnz       L3852
    call      mc_stackmcl.getworkireg
    mov       [rbp + mc_stackmcl.makesimpleaddr.newreg],	rax
    jmp       L3851
L3852:
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.reg]
    test      rax,	rax
    jz        L3853
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.ax]
    jmp       L3846
L3853:
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.regix]
    test      rax,	rax
    jz        L3854
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.regix]
    mov       [rbp + mc_stackmcl.makesimpleaddr.newreg],	rax
    jmp       L3851
L3854:
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.regix]
    mov       [rbp + mc_stackmcl.makesimpleaddr.newreg],	rax
L3851:
    mov       rcx,	[rbp + mc_stackmcl.makesimpleaddr.newreg]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_stackmcl.makesimpleaddr.bx],	rax
    mov       rcx,	[rbp + mc_stackmcl.makesimpleaddr.newreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	15
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.makesimpleaddr.ax]
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_stackmcl.makesimpleaddr.bx]
L3846:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc checkallloaded
mc_stackmcl.checkallloaded:
;>>
    %define mc_stackmcl.checkallloaded.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mc_stackmcl.checkallloaded.i],	rax
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3858
L3856:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[rbp + mc_stackmcl.checkallloaded.i]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3860
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.checkallloaded.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11+1]
    cmp       rax,	1
    jnz       L3860
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[rbp + mc_stackmcl.checkallloaded.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11+3]
    mov       rcx,	[rbp + mc_stackmcl.checkallloaded.i]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3860:
L3859:
L3857:
    mov       rax,	[rbp + mc_stackmcl.checkallloaded.i]
    inc       rax
    mov       [rbp + mc_stackmcl.checkallloaded.i],	rax
    cmp       rax,	[mc_decls.noperands]
    jle       L3856
L3858:
L3855:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc getassemstr
mc_writenasm.getassemstr:
;>>
    %define mc_writenasm.getassemstr.d -8
    %define mc_writenasm.getassemstr.e -16
    %define mc_writenasm.getassemstr.m -24
    %define mc_writenasm.getassemstr.str2 -56
    %define mc_writenasm.getassemstr.str3 -88
    %define mc_writenasm.getassemstr.i -96
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[rel L5927]
    call      msys.m$print_str_nf
    movzx     rax,	byte [mc_decls.phighmem]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_init
    lea       rcx,	[rel L5928]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5929]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5930]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5931]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5932]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5933]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5934]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5935]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5936]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5937]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5938]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5939]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5940]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5941]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5942]
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5943]
    call      mc_writenasm.asmstr
    mov       rax,	[pc_decls.psymboltable]
    mov       [rbp + mc_writenasm.getassemstr.d],	rax
    jmp       L3865
L3862:
    mov       rax,	[rbp + mc_writenasm.getassemstr.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L3867
    lea       rcx,	[rel L5944]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.getassemstr.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5945]
    call      mc_writenasm.asmstr
L3867:
L3866:
    mov       rax,	[rbp + mc_writenasm.getassemstr.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L3869
    lea       rcx,	[rel L5946]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.getassemstr.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5947]
    call      mc_writenasm.asmstr
L3869:
L3868:
L3863:
    mov       rax,	[rbp + mc_writenasm.getassemstr.d]
    mov       r10,	[rax+8]
    mov       [rbp + mc_writenasm.getassemstr.d],	r10
L3865:
    mov       rax,	[rbp + mc_writenasm.getassemstr.d]
    test      rax,	rax
    jnz       L3862
L3864:
    lea       rcx,	[rel L5947]
    call      mc_writenasm.asmstr
    mov       rax,	[mc_decls.mccode]
    mov       [rbp + mc_writenasm.getassemstr.m],	rax
    mov       rax,	1
    mov       [rbp + mc_writenasm.getassemstr.i],	rax
    jmp       L3871
L3870:
    mov       rcx,	[rbp + mc_writenasm.getassemstr.i]
    mov       rdx,	[rbp + mc_writenasm.getassemstr.m]
    call      mc_writenasm.writemcl
    inc       qword [rbp + mc_writenasm.getassemstr.i]
    mov       rax,	[rbp + mc_writenasm.getassemstr.m]
    mov       r10,	[rax]
    mov       [rbp + mc_writenasm.getassemstr.m],	r10
L3871:
    mov       rax,	[rbp + mc_writenasm.getassemstr.m]
    test      rax,	rax
    jnz       L3870
L3872:
    mov       rax,	[pc_decls.pdest]
L3861:
;---------------
    add       rsp,	128
    pop       rbp
    ret       
;End 
;Proc writemcl
mc_writenasm.writemcl:
;>>
    %define mc_writenasm.writemcl.index 16
    %define mc_writenasm.writemcl.mcl 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_writenasm.writemcl.mcl]
    movzx     r10,	byte [rax+24]
    cmp       r10,	5
    jz        L3875
    jmp       L3876
L3875:
    jmp       L3874
L3876:
    mov       rcx,	[rbp + mc_writenasm.writemcl.mcl]
    call      mc_writenasm.strmcl
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_line
L3874:
L3873:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc start
mc_writenasm.start:
;>>
    %define mc_writenasm.start.flag -8
    %define mc_writenasm.start.av_1 -16
    %define mc_writenasm.start.i -24
    %define mc_writenasm.start.r -32
    %define mc_writenasm.start.k -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1297301838
    mov       [pc_decls.assemtype],	rax
    mov       rax,	1
    mov       [rbp + mc_writenasm.start.i],	rax
L3878:
    mov       rax,	[rbp + mc_writenasm.start.i]
    cmp       rax,	1
    jz        L3883
    cmp       rax,	2
    jz        L3883
    cmp       rax,	4
    jz        L3883
    cmp       rax,	8
    jnz       L3882
L3883:
    mov       rax,	1
    mov       [rbp + mc_writenasm.start.r],	rax
L3884:
    xor       eax,	eax
    mov       [rbp + mc_writenasm.start.flag],	al
    mov       rax,	1
    mov       [rbp + mc_writenasm.start.k],	rax
    mov       rax,	137
    mov       [rbp + mc_writenasm.start.av_1],	rax
    mov       rax,	[rbp + mc_writenasm.start.av_1]
    cmp       rax,	1
    jl        L3889
L3887:
    movzx     rax,	byte [rbp + mc_writenasm.start.flag]
    test      rax,	rax
    jz        L3891
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	[rbp + mc_writenasm.start.k]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	[rbp + mc_writenasm.start.i]
    jnz       L3893
    lea       rax,	[mc_decls.regindices]
    mov       r10,	[rbp + mc_writenasm.start.k]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	[rbp + mc_writenasm.start.r]
    jnz       L3893
    lea       rax,	[mc_decls.dregnames]
    mov       r10,	[rbp + mc_writenasm.start.k]
    mov       r11,	[rax + r10*8-8]
    lea       rax,	[mc_writenasm.nregnames]
    mov       r10,	[rbp + mc_writenasm.start.i]
    shl       r10,	7
    lea       rax,	[rax + r10-128]
    mov       r10,	[rbp + mc_writenasm.start.r]
    mov       [rax + r10*8-8],	r11
L3893:
L3892:
    jmp       L3890
L3891:
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	[rbp + mc_writenasm.start.k]
    movzx     r11,	byte [rax + r10-1]
    cmp       r11,	0
    jnz       L3894
    mov       al,	1
    mov       [rbp + mc_writenasm.start.flag],	al
L3894:
L3890:
L3888:
    mov       rax,	[rbp + mc_writenasm.start.k]
    inc       rax
    mov       [rbp + mc_writenasm.start.k],	rax
    cmp       rax,	[rbp + mc_writenasm.start.av_1]
    jle       L3887
L3889:
L3885:
    mov       rax,	[rbp + mc_writenasm.start.r]
    inc       rax
    mov       [rbp + mc_writenasm.start.r],	rax
    cmp       rax,	16
    jle       L3884
L3886:
L3882:
L3881:
L3879:
    mov       rax,	[rbp + mc_writenasm.start.i]
    inc       rax
    mov       [rbp + mc_writenasm.start.i],	rax
    cmp       rax,	8
    jle       L3878
L3880:
L3877:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc strmcl
mc_writenasm.strmcl:
;>>
    %define mc_writenasm.strmcl.mcl 16
    %define mc_writenasm.strmcl.opcname -128
    %define mc_writenasm.strmcl.a -136
    %define mc_writenasm.strmcl.b -144
    %define mc_writenasm.strmcl.opcode -152
    %define mc_writenasm.strmcl.cond -160
    %define mc_writenasm.strmcl.sizepref -168
    %define mc_writenasm.strmcl.s -176
    %define mc_writenasm.strmcl.comment -184
    %define mc_writenasm.strmcl.d -192
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	224
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     r10,	byte [rax+24]
    mov       [rbp + mc_writenasm.strmcl.opcode],	r10
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     r10,	byte [rax+25]
    mov       [rbp + mc_writenasm.strmcl.cond],	r10
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       r10,	[rax+8]
    mov       [rbp + mc_writenasm.strmcl.a],	r10
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       r10,	[rax+16]
    mov       [rbp + mc_writenasm.strmcl.b],	r10
    xor       eax,	eax
    mov       [rbp + mc_writenasm.strmcl.comment],	rax
    mov       rax,	[rbp + mc_writenasm.strmcl.opcode]
    cmp       rax,	1
    jz        L3897
    cmp       rax,	2
    jz        L3898
    cmp       rax,	4
    jz        L3899
    cmp       rax,	3
    jz        L3900
    cmp       rax,	5
    jz        L3901
    cmp       rax,	6
    jz        L3902
    cmp       rax,	9
    jz        L3903
    cmp       rax,	7
    jz        L3904
    cmp       rax,	8
    jz        L3905
    cmp       rax,	122
    jz        L3906
    cmp       rax,	120
    jz        L3907
    cmp       rax,	121
    jz        L3908
    jmp       L3909
L3897:
    lea       rcx,	[rel L5948]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       rax,	[r10]
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       [mc_decls.currasmproc],	r10
    jmp       L3895
L3898:
    lea       rcx,	[rel L5949]
    call      mc_writenasm.asmstr
    xor       eax,	eax
    mov       [mc_decls.currasmproc],	rax
    jmp       L3895
L3899:
    jmp       L3895
L3900:
    mov       rcx,	59
    call      mc_writenasm.asmchar
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    jmp       L3910
    jmp       L3896
L3901:
    lea       rcx,	[rel L5950]
    call      mc_writenasm.asmstr
    jmp       L3910
    jmp       L3896
L3902:
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       [rbp + mc_writenasm.strmcl.d],	r10
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	5
    jz        L3912
    cmp       r10,	4
    jz        L3913
    jmp       L3914
L3912:
    mov       rcx,	[rbp + mc_writenasm.strmcl.d]
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    jmp       L3911
L3913:
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    jmp       L3895
L3914:
    lea       rcx,	[rel L5951]
    lea       rdx,	[rel L5952]
    call      mc_libmcl.merror
L3911:
    lea       rcx,	[rel L5953]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L3916
    lea       rcx,	[rel L5954]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5955]
    call      mc_writenasm.asmstr
L3916:
L3915:
    jmp       L3895
L3903:
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5956]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      mc_writenasm.asmstr
    jmp       L3895
L3904:
    lea       rcx,	[rel L5957]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5958]
    call      mc_writenasm.asmstr
    mov       rcx,	[rbp + mc_writenasm.strmcl.b]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    jmp       L3895
L3905:
    lea       rcx,	[rel L5959]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mc_writenasm.asmstr
    lea       rcx,	[rel L5960]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3918
    jmp       L3919
L3918:
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_writenasm.getregname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    jmp       L3917
L3919:
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_writenasm.getxregname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L3917:
    jmp       L3895
L3906:
    lea       rcx,	[rel L5961]
    call      mc_writenasm.asmstr
    mov       al,	1
    mov       [mc_writenasm.currseg],	al
    jmp       L3895
L3907:
    lea       rcx,	[rel L5962]
    call      mc_writenasm.asmstr
    mov       al,	2
    mov       [mc_writenasm.currseg],	al
    jmp       L3895
L3908:
    lea       rcx,	[rel L5963]
    call      mc_writenasm.asmstr
    mov       al,	3
    mov       [mc_writenasm.currseg],	al
    jmp       L3895
L3909:
L3896:
    mov       rax,	[rbp + mc_writenasm.strmcl.opcode]
    cmp       rax,	27
    jz        L3921
    cmp       rax,	59
    jz        L3922
    cmp       rax,	16
    jz        L3923
    cmp       rax,	39
    jz        L3924
    cmp       rax,	40
    jz        L3925
    cmp       rax,	41
    jz        L3926
    cmp       rax,	52
    jz        L3927
    cmp       rax,	35
    jz        L3928
    cmp       rax,	20
    jz        L3929
    cmp       rax,	19
    jz        L3930
    cmp       rax,	17
    jz        L3931
    cmp       rax,	123
    jz        L3932
    jmp       L3933
L3921:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5964]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	[rbp + mc_writenasm.strmcl.cond]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3920
L3922:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5965]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	[rbp + mc_writenasm.strmcl.cond]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3920
L3923:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5966]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	[rbp + mc_writenasm.strmcl.cond]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3920
L3924:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5967]
    call      strcpy
    jmp       L3920
L3925:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5968]
    call      strcpy
    jmp       L3920
L3926:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5969]
    call      strcpy
    jmp       L3920
L3927:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5970]
    call      strcpy
    jmp       L3920
L3928:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5971]
    call      strcpy
    jmp       L3920
L3929:
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L3935
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jnz       L3935
    mov       rcx,	[rbp + mc_writenasm.strmcl.a]
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_writenasm.strmcl.a],	rax
    mov       r10,	[rbp + mc_writenasm.strmcl.mcl]
    mov       [r10+8],	rax
    mov       rax,	12
    mov       [rbp + mc_writenasm.strmcl.opcode],	rax
L3935:
L3934:
    jmp       L3933
    jmp       L3920
L3930:
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	8
    jnz       L3937
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r10,	word [rax+8]
    and       r10,	31
    cmp       r10,	4
    jnz       L3937
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5972]
    call      strcpy
    jmp       L3936
L3937:
    jmp       L3933
L3936:
    jmp       L3920
L3931:
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3939
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L3939
    mov       rax,	18
    mov       [rbp + mc_writenasm.strmcl.opcode],	rax
L3939:
L3938:
    jmp       L3933
    jmp       L3920
L3932:
    movzx     rax,	byte [mc_writenasm.currseg]
    cmp       rax,	3
    jnz       L3941
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[rel L5973]
    call      strcpy
    jmp       L3940
L3941:
    jmp       L3933
L3940:
    jmp       L3920
L3933:
    mov       rax,	[rbp + mc_writenasm.strmcl.opcode]
    cmp       rax,	150
    jle       L3943
    mov       rcx,	[rbp + mc_writenasm.strmcl.opcode]
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
    jmp       L3942
L3943:
    lea       rax,	[mc_decls.mclnames]
    mov       r10,	[rbp + mc_writenasm.strmcl.opcode]
    mov       r11,	[rax + r10*8-8]
    lea       r11,	[r11+2]
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	r11
    call      strcpy
L3942:
L3920:
    mov       rax,	[rbp + mc_writenasm.strmcl.opcode]
    cmp       rax,	119
    jnz       L3945
    mov       rax,	4
    jmp       L3944
L3945:
    mov       rax,	10
L3944:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    lea       r8,	[rel L5974]
    call      mlib.ipadstr
    lea       rcx,	[mc_writenasm.strmcl.str]
    lea       rdx,	[rel L5975]
    call      strcpy
    lea       rcx,	[mc_writenasm.strmcl.str]
    mov       rdx,	4
    lea       r8,	[rel L5976]
    call      mlib.ipadstr
    lea       rcx,	[mc_writenasm.strmcl.str]
    lea       rdx,	[rbp + mc_writenasm.strmcl.opcname]
    call      strcat
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    test      rax,	rax
    jz        L3947
    mov       rax,	[rbp + mc_writenasm.strmcl.b]
    test      rax,	rax
    jz        L3947
    mov       rcx,	[rbp + mc_writenasm.strmcl.opcode]
    mov       rdx,	[rbp + mc_writenasm.strmcl.a]
    mov       r8,	[rbp + mc_writenasm.strmcl.b]
    call      mc_writenasm.needsizeprefix
    mov       [rbp + mc_writenasm.strmcl.sizepref],	rax
    mov       rcx,	[rbp + mc_writenasm.strmcl.a]
    mov       rdx,	[rbp + mc_writenasm.strmcl.sizepref]
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    lea       rcx,	[rel L5977]
    call      mc_writenasm.asmstr
    mov       rcx,	[rbp + mc_writenasm.strmcl.b]
    mov       rdx,	[rbp + mc_writenasm.strmcl.sizepref]
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     r10,	byte [rax+26]
    test      r10,	r10
    jz        L3949
    lea       rcx,	[rel L5978]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     r10,	byte [rax+26]
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L3949:
L3948:
    jmp       L3946
L3947:
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    test      rax,	rax
    jz        L3950
    mov       rax,	[rbp + mc_writenasm.strmcl.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    test      r10,	r10
    jz        L3950
    mov       rax,	[rbp + mc_writenasm.strmcl.opcode]
    cmp       rax,	22
    jnz       L3952
    mov       rcx,	[rbp + mc_writenasm.strmcl.a]
    xor       edx,	edx
    mov       r8,	[rbp + mc_writenasm.strmcl.opcode]
    call      mc_writenasm.asmopnd
    jmp       L3951
L3952:
    mov       rcx,	[rbp + mc_writenasm.strmcl.a]
    mov       rdx,	1
    mov       r8,	[rbp + mc_writenasm.strmcl.opcode]
    call      mc_writenasm.asmopnd
L3951:
L3950:
L3946:
;docomments:
L3910:
L3895:
;---------------
    add       rsp,	224
    pop       rbp
    ret       
;End 
;Proc strmclstr
mc_writenasm.strmclstr:
;>>
    %define mc_writenasm.strmclstr.m 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_init
    mov       rcx,	[rbp + mc_writenasm.strmclstr.m]
    call      mc_writenasm.strmcl
    mov       rax,	[pc_decls.pdest]
    mov       r10,	[rax]
    mov       rax,	r10
L3953:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc mstropnd
mc_writenasm.mstropnd:
;>>
    %define mc_writenasm.mstropnd.a 16
    %define mc_writenasm.mstropnd.sizeprefix 24
    %define mc_writenasm.mstropnd.opcode 32
    %define mc_writenasm.mstropnd.str2 -128
    %define mc_writenasm.mstropnd.plus -136
    %define mc_writenasm.mstropnd.t -144
    %define mc_writenasm.mstropnd.offset -152
    %define mc_writenasm.mstropnd.tc -160
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    xor       eax,	eax
    mov       [mc_writenasm.mstropnd.str],	al
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L3956
    cmp       r10,	2
    jz        L3957
    cmp       r10,	3
    jz        L3958
    cmp       r10,	5
    jz        L3959
    jmp       L3960
L3956:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_writenasm.strreg
    jmp       L3954
L3957:
    mov       rax,	[rbp + mc_writenasm.mstropnd.opcode]
    cmp       rax,	119
    jnz       L3962
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	1
    jnz       L3962
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    mov       r10,	[rax]
    cmp       r10,	0
    jl        L3964
    cmp       r10,	9
    jg        L3964
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L3963
L3964:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rel L5979]
    call      strcat
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L5980]
    call      msys.strword
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L3963:
    jmp       L3961
L3962:
    mov       rcx,	[rbp + mc_writenasm.mstropnd.a]
    call      mc_writenasm.strvalue
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
L3961:
    jmp       L3955
L3958:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	1
    jz        L3966
    cmp       r10,	2
    jz        L3967
    cmp       r10,	3
    jz        L3968
    jmp       L3969
L3966:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L3965
L3967:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movq      XMM4,	[rax]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L3965
L3968:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L5981]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movq      XMM4,	[rax]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
L3969:
L3965:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_writenasm.mstropnd.sizeprefix]
    call      mc_writenasm.getsizeprefix
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rel L5982]
    call      strcat
    lea       rax,	[rel L5983]
    mov       [rbp + mc_writenasm.mstropnd.plus],	rax
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	byte [rax+10]
    test      r10,	r10
    jz        L3971
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	byte [rax+10]
    mov       rcx,	r10
    mov       rdx,	8
    call      mc_writenasm.strreg
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rel L5984]
    mov       [rbp + mc_writenasm.mstropnd.plus],	rax
L3971:
L3970:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	byte [rax+11]
    test      r10,	r10
    jz        L3973
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	[rbp + mc_writenasm.mstropnd.plus]
    call      strcat
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	byte [rax+11]
    mov       rcx,	r10
    mov       rdx,	8
    call      mc_writenasm.strreg
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rel L5984]
    mov       [rbp + mc_writenasm.mstropnd.plus],	rax
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    cmp       r10,	1
    jle       L3975
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rel L5985]
    call      strcat
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	5
    and       r10,	15
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L3975:
L3974:
L3973:
L3972:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	5
    jz        L3978
    cmp       r10,	6
    jz        L3978
    cmp       r10,	8
    jnz       L3977
L3978:
    mov       rax,	[rbp + mc_writenasm.mstropnd.plus]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L3980
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	[rbp + mc_writenasm.mstropnd.plus]
    call      strcat
L3980:
L3979:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	6
    jnz       L3982
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rel L5986]
    call      strcat
L3982:
L3981:
    mov       rcx,	[rbp + mc_writenasm.mstropnd.a]
    call      mc_writenasm.strvalue
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L3976
L3977:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movsxd    r10,	dword [rax+12]
    mov       [rbp + mc_writenasm.mstropnd.offset],	r10
    test      r10,	r10
    jz        L3983
    lea       rcx,	[rbp + mc_writenasm.mstropnd.str2]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + mc_writenasm.mstropnd.offset]
    lea       rdx,	[rel L5987]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rbp + mc_writenasm.mstropnd.str2]
    call      strcat
L3983:
L3976:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rel L5988]
    call      strcat
    jmp       L3955
L3959:
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    and       r10,	31
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r11,	byte [rax+10]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_writenasm.strxreg
    jmp       L3954
L3960:
    call      msys.m$print_startcon
    lea       rcx,	[rel L5989]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_writenasm.mstropnd.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rel L5990]
    jmp       L3954
L3955:
    lea       rax,	[mc_writenasm.mstropnd.str]
L3954:
;---------------
    add       rsp,	192
    pop       rbp
    ret       
;End 
;Proc strvalue
mc_writenasm.strvalue:
;>>
    %define mc_writenasm.strvalue.a 16
    %define mc_writenasm.strvalue.str2 -128
    %define mc_writenasm.strvalue.def -136
    %define mc_writenasm.strvalue.value -144
    %define mc_writenasm.strvalue.offset -152
    %define mc_writenasm.strvalue.length -160
    %define mc_writenasm.strvalue.ss -168
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	208
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    mov       r10,	[rax]
    mov       [rbp + mc_writenasm.strvalue.def],	r10
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    mov       r10,	[rax]
    mov       [rbp + mc_writenasm.strvalue.value],	r10
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rel L5991]
    call      strcpy
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    movzx     r10,	word [rax+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	5
    jz        L3986
    cmp       r10,	1
    jz        L3987
    cmp       r10,	2
    jz        L3988
    cmp       r10,	3
    jz        L3989
    cmp       r10,	4
    jz        L3990
    cmp       r10,	7
    jz        L3991
    cmp       r10,	6
    jz        L3992
    cmp       r10,	8
    jz        L3993
    jmp       L3994
L3986:
    mov       rcx,	[rbp + mc_writenasm.strvalue.def]
    call      mc_writenasm.getdispname
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
;addoffset:
L3995:
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    movsxd    r10,	dword [rax+12]
    mov       [rbp + mc_writenasm.strvalue.offset],	r10
    test      r10,	r10
    jz        L3997
    lea       rcx,	[rbp + mc_writenasm.strvalue.str2]
    call      msys.m$print_startstr
    mov       rax,	[rbp + mc_writenasm.strvalue.offset]
    cmp       rax,	0
    jle       L3999
    lea       rax,	[rel L5992]
    jmp       L3998
L3999:
    lea       rax,	[rel L5993]
L3998:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[rbp + mc_writenasm.strvalue.offset]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rbp + mc_writenasm.strvalue.str2]
    call      strcat
L3997:
L3996:
    jmp       L3985
L3987:
    mov       rcx,	[rbp + mc_writenasm.strvalue.value]
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L3985
L3988:
    lea       rcx,	[mc_writenasm.strvalue.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    movq      XMM4,	[rax]
    movq      XMM0,	XMM4
    lea       rdx,	[rel L5994]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L3985
L3989:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rel L5995]
    call      strcat
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    movq      XMM4,	[rax]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L3985
L3990:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rel L5996]
    call      strcat
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    mov       r10,	[rax]
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	r10
    call      strcat
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rel L5996]
    call      strcat
    jmp       L3985
L3991:
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    mov       r10,	[rax]
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	r10
    call      strcat
    jmp       L3985
L3992:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rel L5997]
    call      strcat
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L3995
L3993:
    mov       rax,	[rbp + mc_writenasm.strvalue.a]
    mov       r10,	[rax]
    mov       rcx,	[mc_decls.currasmproc]
    mov       rdx,	r10
    call      mc_writenasm.gettempname
    jmp       L3984
L3994:
    lea       rcx,	[rel L5998]
    lea       rdx,	[rel L5999]
    call      mc_libmcl.merror
L3985:
    lea       rax,	[mc_writenasm.strvalue.str]
L3984:
;---------------
    add       rsp,	208
    pop       rbp
    ret       
;End 
;Proc asmopnd
mc_writenasm.asmopnd:
;>>
    %define mc_writenasm.asmopnd.a 16
    %define mc_writenasm.asmopnd.sizeprefix 24
    %define mc_writenasm.asmopnd.opcode 32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mc_writenasm.asmopnd.a]
    mov       rdx,	[rbp + mc_writenasm.asmopnd.sizeprefix]
    mov       r8,	[rbp + mc_writenasm.asmopnd.opcode]
    call      mc_writenasm.mstropnd
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L4000:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getregname
mc_writenasm.getregname:
;>>
    %define mc_writenasm.getregname.reg 16
    %define mc_writenasm.getregname.size 24
    %define mc_writenasm.getregname.str2 -16
    %define mc_writenasm.getregname.rs -24
    %define mc_writenasm.getregname.size2 -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_writenasm.getregname.size]
    mov       [rbp + mc_writenasm.getregname.size2],	rax
    mov       rax,	[rbp + mc_writenasm.getregname.size2]
    cmp       rax,	16
    jle       L4003
    mov       rax,	17
    mov       [rbp + mc_writenasm.getregname.size2],	rax
L4003:
L4002:
    mov       rax,	[rbp + mc_writenasm.getregname.reg]
    cmp       rax,	0
    jz        L4005
    cmp       rax,	15
    jz        L4006
    cmp       rax,	16
    jz        L4007
    jmp       L4008
L4005:
    lea       rax,	[rel L6000]
    jmp       L4001
L4006:
    lea       rax,	[rel L6001]
    mov       [rbp + mc_writenasm.getregname.rs],	rax
    jmp       L4004
L4007:
    lea       rax,	[rel L6002]
    mov       [rbp + mc_writenasm.getregname.rs],	rax
    jmp       L4004
L4008:
    mov       rax,	[rbp + mc_writenasm.getregname.reg]
    sub       rax,	1
    mov       rcx,	rax
    lea       rdx,	[rbp + mc_writenasm.getregname.str2]
    call      msys.getstrint
    lea       rax,	[rbp + mc_writenasm.getregname.str2]
    mov       [rbp + mc_writenasm.getregname.rs],	rax
L4004:
    lea       rcx,	[mc_writenasm.getregname.str]
    call      msys.m$print_startstr
    lea       rax,	[mc_writenasm.getregname.prefix]
    mov       r10,	[rbp + mc_writenasm.getregname.size2]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[rbp + mc_writenasm.getregname.rs]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getregname.str]
L4001:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc getxregname
mc_writenasm.getxregname:
;>>
    %define mc_writenasm.getxregname.reg 16
    %define mc_writenasm.getxregname.size 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_writenasm.getxregname.reg]
    cmp       rax,	0
    jnz       L4011
    lea       rax,	[rel L6003]
    jmp       L4009
L4011:
L4010:
    lea       rcx,	[mc_writenasm.getxregname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L6004]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rbp + mc_writenasm.getxregname.reg]
    sub       rax,	1
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getxregname.str]
L4009:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc asmstr
mc_writenasm.asmstr:
;>>
    %define mc_writenasm.asmstr.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    mov       rdx,	[rbp + mc_writenasm.asmstr.s]
    call      mlib.gs_str
L4012:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc asmchar
mc_writenasm.asmchar:
;>>
    %define mc_writenasm.asmchar.c 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    mov       rdx,	[rbp + mc_writenasm.asmchar.c]
    call      mlib.gs_char
L4013:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getdispname
mc_writenasm.getdispname:
;>>
    %define mc_writenasm.getdispname.d 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writenasm.getdispname.d]
    movzx     r10,	byte [rax+66]
    test      r10,	r10
    jz        L4016
    lea       rcx,	[mc_writenasm.getdispname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L6005]
    call      msys.m$print_setfmt
    lea       rcx,	[rel L6006]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_writenasm.getdispname.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getdispname.str]
    jmp       L4014
L4016:
L4015:
    movzx     rax,	byte [mc_decls.fpshortnames]
    test      rax,	rax
    jz        L4018
    mov       rax,	[rbp + mc_writenasm.getdispname.d]
    mov       r10,	[rax]
    mov       rax,	r10
    jmp       L4014
L4018:
L4017:
    mov       rcx,	[rbp + mc_writenasm.getdispname.d]
    xor       edx,	edx
    call      pc_api.getfullname
L4014:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc gettempname
mc_writenasm.gettempname:
;>>
    %define mc_writenasm.gettempname.d 16
    %define mc_writenasm.gettempname.n 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    movzx     rax,	byte [mc_decls.fpshortnames]
    test      rax,	rax
    jz        L4021
    lea       rcx,	[mc_writenasm.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L6007]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[rbp + mc_writenasm.gettempname.n]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4020
L4021:
    lea       rcx,	[mc_writenasm.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rel L6008]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mc_writenasm.gettempname.d]
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_writenasm.gettempname.n]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L4020:
    lea       rax,	[mc_writenasm.gettempname.str]
L4019:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc strreg
mc_writenasm.strreg:
;>>
    %define mc_writenasm.strreg.reg 16
    %define mc_writenasm.strreg.size 24
    %define mc_writenasm.strreg.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_writenasm.nregnames]
    mov       r10,	[rbp + mc_writenasm.strreg.size]
    shl       r10,	7
    lea       rax,	[rax + r10-128]
    mov       r10,	[rbp + mc_writenasm.strreg.reg]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
L4022:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc strxreg
mc_writenasm.strxreg:
;>>
    %define mc_writenasm.strxreg.reg 16
    %define mc_writenasm.strxreg.size 24
    %define mc_writenasm.strxreg.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_writenasm.strxreg.reg]
    mov       rdx,	1
    call      mc_writenasm.checkregvar
    mov       [rbp + mc_writenasm.strxreg.d],	rax
    mov       rax,	[rbp + mc_writenasm.strxreg.size]
    cmp       rax,	8
    jnz       L4025
    mov       rax,	[rbp + mc_writenasm.strxreg.d]
    test      rax,	rax
    jz        L4025
    mov       rcx,	[rbp + mc_writenasm.strxreg.d]
    call      mc_writenasm.getdispname
    jmp       L4024
L4025:
    mov       rcx,	[rbp + mc_writenasm.strxreg.reg]
    mov       rdx,	[rbp + mc_writenasm.strxreg.size]
    call      mc_writenasm.getxregname
L4024:
L4023:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc needsizeprefix
mc_writenasm.needsizeprefix:
;>>
    %define mc_writenasm.needsizeprefix.opcode 16
    %define mc_writenasm.needsizeprefix.a 24
    %define mc_writenasm.needsizeprefix.b 32
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rax,	[rbp + mc_writenasm.needsizeprefix.opcode]
    cmp       rax,	19
    jz        L4028
    cmp       rax,	20
    jz        L4028
    cmp       rax,	86
    jz        L4028
    cmp       rax,	87
    jz        L4028
    cmp       rax,	82
    jz        L4029
    cmp       rax,	83
    jz        L4029
    cmp       rax,	84
    jz        L4029
    cmp       rax,	85
    jz        L4029
    cmp       rax,	44
    jz        L4030
    cmp       rax,	46
    jz        L4030
    cmp       rax,	45
    jz        L4030
    jmp       L4031
L4028:
    mov       rax,	1
    jmp       L4026
L4029:
    mov       rax,	1
    jmp       L4026
L4030:
    mov       rax,	[rbp + mc_writenasm.needsizeprefix.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	3
    jnz       L4033
    mov       rax,	1
    jmp       L4026
L4033:
L4032:
    xor       eax,	eax
    jmp       L4026
L4031:
L4027:
    mov       rax,	[rbp + mc_writenasm.needsizeprefix.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L4036
    mov       rax,	[rbp + mc_writenasm.needsizeprefix.a]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jz        L4036
    mov       rax,	[rbp + mc_writenasm.needsizeprefix.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	1
    jz        L4036
    mov       rax,	[rbp + mc_writenasm.needsizeprefix.b]
    movzx     r10,	word [rax+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	5
    jnz       L4035
L4036:
    xor       eax,	eax
    jmp       L4026
L4035:
L4034:
    mov       rax,	1
L4026:
;---------------
    pop       rbp
    ret       
;End 
;Proc getsizeprefix
mc_writenasm.getsizeprefix:
;>>
    %define mc_writenasm.getsizeprefix.size 16
    %define mc_writenasm.getsizeprefix.enable 24
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_writenasm.getsizeprefix.enable]
    test      rax,	rax
    jnz       L4039
    lea       rax,	[rel L6009]
    jmp       L4037
L4039:
L4038:
    mov       rax,	[rbp + mc_writenasm.getsizeprefix.size]
    cmp       rax,	1
    jz        L4041
    cmp       rax,	2
    jz        L4042
    cmp       rax,	4
    jz        L4043
    cmp       rax,	8
    jz        L4044
    jmp       L4045
L4041:
    lea       rax,	[rel L6010]
    jmp       L4037
L4042:
    lea       rax,	[rel L6011]
    jmp       L4037
L4043:
    lea       rax,	[rel L6012]
    jmp       L4037
L4044:
    lea       rax,	[rel L6013]
    jmp       L4037
L4045:
L4040:
    lea       rax,	[rel L6014]
L4037:
;---------------
    pop       rbp
    ret       
;End 
;Proc checkregvar
mc_writenasm.checkregvar:
;>>
    %define mc_writenasm.checkregvar.reg 16
    %define mc_writenasm.checkregvar.ispfloat 24
    %define mc_writenasm.checkregvar.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    xor       eax,	eax
L4046:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc writeexe
mc_writeexe.writeexe:
;>>
    %define mc_writeexe.writeexe.outfile 16
    %define mc_writeexe.writeexe.dodll 24
    %define mc_writeexe.writeexe.header -24
    %define mc_writeexe.writeexe.optheader -264
    %define mc_writeexe.writeexe.offset -272
    %define mc_writeexe.writeexe.i -280
    %define mc_writeexe.writeexe.aa -288
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	320
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mc_writeexe.writeexe.outfile]
    call      mlib.extractfile
    mov       [mc_writeexe.dllfilename],	rax
    mov       rax,	[rbp + mc_writeexe.writeexe.dodll]
    mov       [mc_writeexe.isdll],	rax
    mov       rcx,	[mc_writeexe.filesize]
    call      mlib.pcm_allocz
    mov       [mc_writeexe.dataptr],	rax
    mov       [mc_writeexe.datastart],	rax
    call      mc_writeexe.writedosstub
    call      mc_writeexe.writepesig
    call      mc_writeexe.writefileheader
    call      mc_writeexe.writeoptheader
    mov       rax,	1
    mov       [rbp + mc_writeexe.writeexe.i],	rax
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4050
L4048:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.writeexe.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectionheader
L4049:
    mov       rax,	[rbp + mc_writeexe.writeexe.i]
    inc       rax
    mov       [rbp + mc_writeexe.writeexe.i],	rax
    cmp       rax,	[mc_writeexe.nsections]
    jle       L4048
L4050:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+32]
    mov       rcx,	r10
    call      mc_writeexe.writepadding
    mov       rax,	1
    mov       [rbp + mc_writeexe.writeexe.i],	rax
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4053
L4051:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.writeexe.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectiondata
L4052:
    mov       rax,	[rbp + mc_writeexe.writeexe.i]
    inc       rax
    mov       [rbp + mc_writeexe.writeexe.i],	rax
    cmp       rax,	[mc_writeexe.nsections]
    jle       L4051
L4053:
    movzx     rax,	byte [pc_decls.pverbose]
    test      rax,	rax
    jz        L4055
    call      msys.m$print_startcon
    lea       rcx,	[rel L6015]
    call      msys.m$print_str_nf
    mov       rax,	[mc_writeexe.dataptr]
    sub       rax,	[mc_writeexe.datastart]
    mov       rcx,	rax
    lea       rdx,	[rel L6016]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L4055:
L4054:
    mov       rax,	[mc_writeexe.dataptr]
    sub       rax,	[mc_writeexe.datastart]
    mov       rcx,	[rbp + mc_writeexe.writeexe.outfile]
    mov       rdx,	[mc_writeexe.datastart]
    mov       r8,	rax
    call      mlib.writefile
    cmp       rax,	0
    jnz       L4057
    call      msys.m$print_startcon
    lea       rcx,	[rel L6017]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4057:
L4056:
L4047:
;---------------
    add       rsp,	320
    pop       rbp
    ret       
;End 
;Proc genexe
mc_writeexe.genexe:
;>>
    %define mc_writeexe.genexe.entrypoint 16
    %define mc_writeexe.genexe.outfile 24
    %define mc_writeexe.genexe.dodll 32
    %define mc_writeexe.genexe.offset -8
    %define mc_writeexe.genexe.codeaddr -16
    %define mc_writeexe.genexe.offsetptr -24
    %define mc_writeexe.genexe.pr -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    call      mc_writeexe.initsectiontable
    mov       rcx,	[rbp + mc_writeexe.genexe.outfile]
    call      mlib.extractfile
    mov       [mc_writeexe.dllfilename],	rax
    mov       rax,	[rbp + mc_writeexe.genexe.dodll]
    mov       [mc_writeexe.isdll],	rax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4060
    mov       rax,	268435456
    jmp       L4059
L4060:
    mov       rax,	4194304
L4059:
    mov       [mc_writeexe.imagebase],	rax
    mov       rax,	[rbp + mc_writeexe.genexe.entrypoint]
    mov       [mc_writeexe.userentrypoint],	rax
    call      mc_writeexe.loadlibs
    call      mc_writeexe.scanst
    call      mc_writeexe.getoffsets
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.genexe.codeaddr],	rax
    movzx     rax,	byte [mc_decls.phighmem]
    test      rax,	rax
    jz        L4062
    mov       rax,	[mc_decls.riplist]
    mov       [rbp + mc_writeexe.genexe.pr],	rax
    jmp       L4066
L4063:
    mov       rax,	[rbp + mc_writeexe.genexe.pr]
    mov       r10d,	[rax+8]
    mov       rax,	[rbp + mc_writeexe.genexe.codeaddr]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.genexe.offsetptr],	rax
    mov       rax,	[rbp + mc_writeexe.genexe.pr]
    movsxd    r10,	dword [rax+12]
    mov       rax,	[rbp + mc_writeexe.genexe.offsetptr]
    mov       r11d,	[rax]
    sub       r11,	[mc_writeexe.imagebase]
    mov       rax,	[rbp + mc_writeexe.genexe.pr]
    mov       edi,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	r11
    mov       r8,	r10
    call      mc_writeexe.getripoffset
    mov       [rbp + mc_writeexe.genexe.offset],	rax
    mov       eax,	[rbp + mc_writeexe.genexe.offset]
    mov       r10,	[rbp + mc_writeexe.genexe.offsetptr]
    mov       [r10],	eax
L4064:
    mov       rax,	[rbp + mc_writeexe.genexe.pr]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.genexe.pr],	r10
L4066:
    mov       rax,	[rbp + mc_writeexe.genexe.pr]
    test      rax,	rax
    jnz       L4063
L4065:
L4062:
L4061:
L4058:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc loadlibs
mc_writeexe.loadlibs:
;>>
    %define mc_writeexe.loadlibs.i -8
    %define mc_writeexe.loadlibs.hinst -16
    %define mc_writeexe.loadlibs.file -24
    %define mc_writeexe.loadlibs.filename -328
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	368
;---------------
    mov       rax,	1
    mov       [rbp + mc_writeexe.loadlibs.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4070
L4068:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mc_writeexe.loadlibs.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11]
    cmp       rax,	36
    jz        L4072
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mc_writeexe.loadlibs.i]
    mov       r11,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    mov       rdx,	r11
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mwindows.os_getdllinst
    mov       [rbp + mc_writeexe.loadlibs.hinst],	rax
    mov       rax,	[rbp + mc_writeexe.loadlibs.hinst]
    cmp       rax,	0
    jnz       L4074
    call      msys.m$print_startcon
    lea       rcx,	[rel L6018]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L6019]
    call      mc_libmcl.axerror
L4074:
L4073:
    mov       rax,	[rbp + mc_writeexe.loadlibs.hinst]
    lea       r10,	[mc_writeexe.libinsttable]
    mov       r11,	[rbp + mc_writeexe.loadlibs.i]
    mov       [r10 + r11*8-8],	rax
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mlib.pcm_copyheapstring
    lea       r10,	[mc_writeexe.libinstnames]
    mov       r11,	[rbp + mc_writeexe.loadlibs.i]
    mov       [r10 + r11*8-8],	rax
L4072:
L4071:
L4069:
    mov       rax,	[rbp + mc_writeexe.loadlibs.i]
    inc       rax
    mov       [rbp + mc_writeexe.loadlibs.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L4068
L4070:
L4067:
;---------------
    add       rsp,	368
    pop       rbp
    ret       
;End 
;Proc initsectiontable
mc_writeexe.initsectiontable:
;>>
    %define mc_writeexe.initsectiontable.$T2 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    lea       rax,	[mc_writeexe.sectiontable]
    lea       r10,	[rel L6020]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	1
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_code]
    mov       [rax],	r10
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+40],	rax
    movzx     rax,	byte [pc_decls.pverbose]
    test      rax,	rax
    jz        L4077
    call      msys.m$print_startcon
    lea       rcx,	[rel L6021]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[rel L6022]
    call      msys.m$print_i64
    lea       rcx,	[rel L6023]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L6024]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[rel L6025]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L6026]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeexe.initsectiontable.$T2],	rax
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	[rbp + mc_writeexe.initsectiontable.$T2]
    add       r10,	rax
    mov       rcx,	r10
    lea       rdx,	[rel L6027]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rel L6028]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_zdatalen]
    lea       rdx,	[rel L6029]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
L4077:
L4076:
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    cmp       rax,	0
    jnz       L4079
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.addqword
L4079:
L4078:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    lea       r10,	[rel L6030]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	2
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_idata]
    mov       [rax],	r10
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+40],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[rax+40]
    mov       rcx,	r10
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+24],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_nidatarelocs]
    mov       [rax+64],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_idatarelocs]
    mov       [rax+56],	r10
    mov       rax,	[mc_decls.ss_zdatalen]
    cmp       rax,	0
    jnz       L4081
    mov       rax,	16
    mov       [mc_decls.ss_zdatalen],	rax
L4081:
L4080:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    lea       r10,	[rel L6031]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	3
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	[mc_decls.ss_zdatalen]
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+40]
    mov       rcx,	r10
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_ncoderelocs]
    mov       [rax+64],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_coderelocs]
    mov       [rax+56],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    lea       r10,	[rel L6032]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	5
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+24],	r10
    mov       rax,	4
    mov       [mc_writeexe.nsections],	rax
L4075:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc extractlibname
mc_writeexe.extractlibname:
;>>
    %define mc_writeexe.extractlibname.name 16
    %define mc_writeexe.extractlibname.libno 24
    %define mc_writeexe.extractlibname.moduleno 32
    %define mc_writeexe.extractlibname.s -8
    %define mc_writeexe.extractlibname.name2 -16
    %define mc_writeexe.extractlibname.str -272
    %define mc_writeexe.extractlibname.str2 -528
    %define mc_writeexe.extractlibname.i -536
    %define mc_writeexe.extractlibname.n -544
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	576
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       eax,	eax
    mov       [rbp + mc_writeexe.extractlibname.name2],	rax
;reenter:
L4083:
    mov       rax,	[rbp + mc_writeexe.extractlibname.name]
    mov       [rbp + mc_writeexe.extractlibname.s],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mc_writeexe.extractlibname.libno]
    mov       [r10],	rax
    jmp       L4085
L4084:
    mov       rax,	[rbp + mc_writeexe.extractlibname.s]
    movzx     r10,	byte [rax]
    cmp       r10,	46
    jnz       L4088
    mov       rax,	[rbp + mc_writeexe.extractlibname.s]
    sub       rax,	[rbp + mc_writeexe.extractlibname.name]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	[rbp + mc_writeexe.extractlibname.name]
    mov       r8,	rax
    call      memcpy
    mov       rax,	[rbp + mc_writeexe.extractlibname.s]
    sub       rax,	[rbp + mc_writeexe.extractlibname.name]
    xor       r10d,	r10d
    mov       [rbp + rax + mc_writeexe.extractlibname.str],	r10b
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[rel L6033]
    call      strcat
    mov       rax,	1
    mov       [rbp + mc_writeexe.extractlibname.i],	rax
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4091
L4089:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.extractlibname.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	r10
    call      mlib.eqstring
    test      rax,	rax
    jz        L4093
    mov       rax,	[rbp + mc_writeexe.extractlibname.i]
    mov       r10,	[rbp + mc_writeexe.extractlibname.libno]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r10,	[rax]
    lea       rax,	[mc_writeexe.dlltable]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    lea       rax,	[rax+8]
    inc       qword [rax]
    mov       rax,	[rbp + mc_writeexe.extractlibname.name2]
    test      rax,	rax
    jz        L4095
    mov       rax,	[rbp + mc_writeexe.extractlibname.name2]
    jmp       L4094
L4095:
    mov       rax,	[rbp + mc_writeexe.extractlibname.s]
    lea       rax,	[rax+1]
L4094:
    jmp       L4082
L4093:
L4092:
L4090:
    mov       rax,	[rbp + mc_writeexe.extractlibname.i]
    inc       rax
    mov       [rbp + mc_writeexe.extractlibname.i],	rax
    cmp       rax,	[mc_writeexe.ndlls]
    jle       L4089
L4091:
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4097
    lea       rcx,	[rel L6034]
    call      mc_libmcl.axerror
L4097:
L4096:
    inc       qword [mc_writeexe.ndlls]
    mov       rax,	[mc_writeexe.ndlls]
    mov       r10,	[rbp + mc_writeexe.extractlibname.libno]
    mov       [r10],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r11,	[r10]
    lea       r10,	[mc_writeexe.dlltable]
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r10,	[rax]
    lea       rax,	[mc_writeexe.dlltable]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	1
    mov       [rax+8],	r10
    mov       rax,	[rbp + mc_writeexe.extractlibname.name2]
    test      rax,	rax
    jz        L4099
    mov       rax,	[rbp + mc_writeexe.extractlibname.name2]
    jmp       L4098
L4099:
    mov       rax,	[rbp + mc_writeexe.extractlibname.s]
    lea       rax,	[rax+1]
L4098:
    jmp       L4082
L4088:
L4087:
    inc       qword [rbp + mc_writeexe.extractlibname.s]
L4085:
    mov       rax,	[rbp + mc_writeexe.extractlibname.s]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L4084
L4086:
    mov       rax,	1
    mov       [rbp + mc_writeexe.extractlibname.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4103
L4100:
    lea       rax,	[mc_writeexe.libinsttable]
    mov       r10,	[rbp + mc_writeexe.extractlibname.i]
    mov       r11,	[rax + r10*8-8]
    test      r11,	r11
    jz        L4105
    lea       rax,	[mc_writeexe.libinsttable]
    mov       r10,	[rbp + mc_writeexe.extractlibname.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    mov       rdx,	[rbp + mc_writeexe.extractlibname.name]
    call      mwindows.os_getdllprocaddr
    test      rax,	rax
    jz        L4107
    mov       rax,	[rbp + mc_writeexe.extractlibname.i]
    mov       [rbp + mc_writeexe.extractlibname.n],	rax
    jmp       L4102
L4107:
L4106:
L4105:
L4104:
L4101:
    mov       rax,	[rbp + mc_writeexe.extractlibname.i]
    inc       rax
    mov       [rbp + mc_writeexe.extractlibname.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L4100
L4103:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mc_writeexe.extractlibname.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L6035]
    call      mc_libmcl.axerror
L4102:
    lea       rax,	[mc_writeexe.libnotable]
    mov       r10,	[rbp + mc_writeexe.extractlibname.n]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + mc_writeexe.extractlibname.libno]
    mov       [rax],	r11
    test      r11,	r11
    jz        L4109
    mov       rax,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r10,	[rax]
    lea       rax,	[mc_writeexe.dlltable]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    lea       rax,	[rax+8]
    inc       qword [rax]
    mov       rax,	[rbp + mc_writeexe.extractlibname.name]
    jmp       L4082
L4109:
L4108:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mc_writeexe.extractlibname.n]
    mov       r11,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	r11
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[rel L6036]
    call      strcat
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4111
    lea       rcx,	[rel L6037]
    call      mc_libmcl.axerror
L4111:
L4110:
    inc       qword [mc_writeexe.ndlls]
    mov       rax,	[mc_writeexe.ndlls]
    mov       r10,	[rbp + mc_writeexe.extractlibname.libno]
    mov       [r10],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r11,	[r10]
    lea       r10,	[mc_writeexe.dlltable]
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r10,	[rax]
    lea       rax,	[mc_writeexe.dlltable]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	1
    mov       [rax+8],	r10
    mov       rax,	[rbp + mc_writeexe.extractlibname.libno]
    mov       r10,	[rax]
    lea       rax,	[mc_writeexe.libnotable]
    mov       r11,	[rbp + mc_writeexe.extractlibname.n]
    mov       [rax + r11*8-8],	r10
    mov       rax,	[rbp + mc_writeexe.extractlibname.name]
L4082:
;---------------
    add       rsp,	576
    pop       rbp
    ret       
;End 
;Proc scanst
mc_writeexe.scanst:
;>>
    %define mc_writeexe.scanst.i -8
    %define mc_writeexe.scanst.libno -16
    %define mc_writeexe.scanst.d -24
    %define mc_writeexe.scanst.name -32
    %define mc_writeexe.scanst.libname -40
    %define mc_writeexe.scanst.basename -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rax,	1
    mov       [rbp + mc_writeexe.scanst.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4115
L4113:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mc_writeexe.scanst.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_writeexe.scanst.d],	r11
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4117
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	3000
    jl        L4119
    lea       rcx,	[rel L6038]
    call      mc_libmcl.axerror
L4119:
L4118:
    inc       qword [mc_writeexe.nimports]
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rbp + mc_writeexe.scanst.libno]
    mov       r8,	1
    call      mc_writeexe.extractlibname
    mov       [rbp + mc_writeexe.scanst.name],	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.scanst.libno]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.scanst.name]
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.scanst.d]
    mov       [rax],	r10
    mov       ax,	[mc_writeexe.nimports]
    mov       r10,	[rbp + mc_writeexe.scanst.d]
    mov       [r10+74],	ax
    jmp       L4116
L4117:
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L4120
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      pc_api.getbasename
    mov       [rbp + mc_writeexe.scanst.basename],	rax
    mov       rax,	[mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4122
    mov       rcx,	[rbp + mc_writeexe.scanst.basename]
    mov       rdx,	[mc_writeexe.userentrypoint]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4124
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    mov       [mc_writeexe.stentrypoint],	rax
L4124:
L4123:
    jmp       L4121
L4122:
    mov       rcx,	[rbp + mc_writeexe.scanst.basename]
    lea       rdx,	[rel L6039]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4126
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4126
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    mov       [mc_writeexe.stentrypoint],	rax
L4126:
L4125:
L4121:
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1000
    jl        L4128
    lea       rcx,	[rel L6040]
    call      mc_libmcl.axerror
L4128:
L4127:
    inc       qword [mc_writeexe.nexports]
    lea       rax,	[mc_writeexe.exporttable]
    mov       r10,	[mc_writeexe.nexports]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	[rbp + mc_writeexe.scanst.d]
    mov       [rax],	r10
    mov       rax,	[rbp + mc_writeexe.scanst.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      pc_api.getbasename
    lea       r10,	[mc_writeexe.exporttable]
    mov       r11,	[mc_writeexe.nexports]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       [r10+8],	rax
L4120:
L4116:
L4114:
    mov       rax,	[rbp + mc_writeexe.scanst.i]
    inc       rax
    mov       [rbp + mc_writeexe.scanst.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4113
L4115:
L4112:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc relocdata
mc_writeexe.relocdata:
;>>
    %define mc_writeexe.relocdata.s 16
    %define mc_writeexe.relocdata.u -8
    %define mc_writeexe.relocdata.r -16
    %define mc_writeexe.relocdata.p -24
    %define mc_writeexe.relocdata.p32 -32
    %define mc_writeexe.relocdata.p64 -40
    %define mc_writeexe.relocdata.d -48
    %define mc_writeexe.relocdata.offset -56
    %define mc_writeexe.relocdata.index -64
    %define mc_writeexe.relocdata.thunkoffset -72
    %define mc_writeexe.relocdata.iatoffset -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.relocdata.p],	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       r10,	[rax+56]
    mov       [rbp + mc_writeexe.relocdata.r],	r10
    jmp       L4131
L4130:
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax+24]
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_writeexe.relocdata.d],	r11
    mov       rax,	[rbp + mc_writeexe.relocdata.d]
    movsx     r10,	word [rax+74]
    mov       [rbp + mc_writeexe.relocdata.index],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.relocdata.index]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+40]
    mov       [rbp + mc_writeexe.relocdata.thunkoffset],	r10
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax+8]
    cmp       r10,	4
    jz        L4134
    cmp       r10,	2
    jz        L4135
    cmp       r10,	1
    jz        L4135
    jmp       L4136
L4134:
    mov       rax,	[rbp + mc_writeexe.relocdata.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jnz       L4138
    lea       rcx,	[rel L6041]
    call      mc_libmcl.axerror
L4138:
L4137:
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_writeexe.relocdata.thunkoffset]
    sub       rax,	r10
    sub       rax,	4
    mov       r10,	[rbp + mc_writeexe.relocdata.r]
    mov       r11,	[r10+16]
    mov       r10,	[rbp + mc_writeexe.relocdata.p]
    mov       [r10 + r11],	eax
    jmp       L4133
L4135:
    mov       rax,	[rbp + mc_writeexe.relocdata.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4140
    mov       rax,	[mc_writeexe.imagebase]
    add       rax,	[rbp + mc_writeexe.relocdata.thunkoffset]
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	[r10+48]
    add       rax,	r11
    mov       r10,	[rbp + mc_writeexe.relocdata.r]
    mov       r11,	[r10+16]
    mov       r10,	[rbp + mc_writeexe.relocdata.p]
    mov       [r10 + r11],	eax
    jmp       L4139
L4140:
    xor       eax,	eax
    mov       [rbp + mc_writeexe.relocdata.u],	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.d]
    movzx     r10,	byte [rax+70]
    cmp       r10,	3
    jz        L4142
    cmp       r10,	2
    jz        L4143
    cmp       r10,	1
    jz        L4144
    jmp       L4145
L4142:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       [rbp + mc_writeexe.relocdata.u],	rax
    jmp       L4141
L4143:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       [rbp + mc_writeexe.relocdata.u],	rax
    jmp       L4141
L4144:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       [rbp + mc_writeexe.relocdata.u],	rax
    jmp       L4141
L4145:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_writeexe.relocdata.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_writeexe.relocdata.d]
    movzx     r10,	byte [rax+70]
    mov       rcx,	r10
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L6042]
    call      mc_libmcl.axerror
L4141:
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_writeexe.relocdata.p]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.relocdata.p32],	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4147
    mov       rax,	[rbp + mc_writeexe.relocdata.p32]
    mov       r10d,	[rax]
    mov       rax,	[rbp + mc_writeexe.relocdata.u]
    mov       r11,	[rax+48]
    add       r10,	r11
    add       r10,	[mc_writeexe.imagebase]
    mov       rax,	[rbp + mc_writeexe.relocdata.p32]
    mov       [rax],	r10d
    jmp       L4146
L4147:
    mov       rax,	[rbp + mc_writeexe.relocdata.p32]
    mov       [rbp + mc_writeexe.relocdata.p64],	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.p64]
    mov       r10,	[rax]
    mov       rax,	[rbp + mc_writeexe.relocdata.u]
    mov       r11,	[rax+48]
    add       r10,	r11
    add       r10,	[mc_writeexe.imagebase]
    mov       rax,	[rbp + mc_writeexe.relocdata.p64]
    mov       [rax],	r10
L4146:
L4139:
    jmp       L4133
L4136:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax+8]
    lea       rax,	[mc_objdecls.relocnames]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L6043]
    call      mc_libmcl.axerror
L4133:
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.relocdata.r],	r10
L4131:
    mov       rax,	[rbp + mc_writeexe.relocdata.r]
    test      rax,	rax
    jnz       L4130
L4132:
L4129:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc getbaserelocs
mc_writeexe.getbaserelocs:
;>>
    %define mc_writeexe.getbaserelocs.s 16
    %define mc_writeexe.getbaserelocs.r -8
    %define mc_writeexe.getbaserelocs.p -16
    %define mc_writeexe.getbaserelocs.d -24
    %define mc_writeexe.getbaserelocs.index -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.s]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getbaserelocs.p],	rax
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.s]
    mov       r10,	[rax+56]
    mov       [rbp + mc_writeexe.getbaserelocs.r],	r10
    jmp       L4150
L4149:
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    mov       r10,	[rax+24]
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_writeexe.getbaserelocs.d],	r11
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jz        L4153
    cmp       r10,	1
    jz        L4153
    jmp       L4154
L4153:
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4156
    jmp       L4155
L4156:
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4158
    jmp       L4157
L4158:
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    mov       r10,	[rax+8]
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.s]
    mov       r11,	[rax+48]
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    mov       rdi,	[rax+16]
    add       r11,	rdi
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_writeexe.newbasereloc
L4157:
L4155:
L4154:
L4152:
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.getbaserelocs.r],	r10
L4150:
    mov       rax,	[rbp + mc_writeexe.getbaserelocs.r]
    test      rax,	rax
    jnz       L4149
L4151:
L4148:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc writerecordx
mc_writeexe.writerecordx:
;>>
    %define mc_writeexe.writerecordx.r 16
    %define mc_writeexe.writerecordx.length 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[mc_writeexe.dataptr]
    mov       rdx,	[rbp + mc_writeexe.writerecordx.r]
    mov       r8,	[rbp + mc_writeexe.writerecordx.length]
    call      memcpy
    mov       rax,	[rbp + mc_writeexe.writerecordx.length]
    add       [mc_writeexe.dataptr],	rax
L4159:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc writedosstub
mc_writeexe.writedosstub:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    lea       rcx,	[mc_writeexe.writedosstub.stubdata]
    mov       rdx,	128
    call      mc_writeexe.writerecordx
L4160:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc writepesig
mc_writeexe.writepesig:
;>>
;---------------
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    mov       r10b,	80
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    mov       r10b,	69
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
L4161:
;---------------
    ret       
;End 
;Proc writepadding
mc_writeexe.writepadding:
;>>
    %define mc_writeexe.writepadding.offset 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_writeexe.datastart]
    mov       r10,	[rbp + mc_writeexe.writepadding.offset]
    lea       rax,	[rax + r10]
    mov       [mc_writeexe.dataptr],	rax
L4162:
;---------------
    pop       rbp
    ret       
;End 
;Proc writefileheader
mc_writeexe.writefileheader:
;>>
    %define mc_writeexe.writefileheader.header -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    lea       rax,	[rbp + mc_writeexe.writefileheader.header]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    mov       ax,	34404
    mov       [rbp + mc_writeexe.writefileheader.header],	ax
    mov       ax,	[mc_writeexe.nsections]
    mov       [rbp + mc_writeexe.writefileheader.header+2],	ax
    mov       ax,	240
    mov       [rbp + mc_writeexe.writefileheader.header+16],	ax
    mov       ax,	559
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4165
    mov       ax,	8750
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
L4165:
L4164:
    lea       rcx,	[rbp + mc_writeexe.writefileheader.header]
    mov       rdx,	20
    call      mc_writeexe.writerecordx
L4163:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc writeoptheader
mc_writeexe.writeoptheader:
;>>
    %define mc_writeexe.writeoptheader.header -240
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	272
;---------------
    lea       rax,	[rbp + mc_writeexe.writeoptheader.header]
    xor       r10,	r10
    mov       r11,	30
L6044:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L6044
    mov       ax,	523
    mov       [rbp + mc_writeexe.writeoptheader.header],	ax
    mov       al,	1
    mov       [rbp + mc_writeexe.writeoptheader.header+2],	al
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+3],	al
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+24]
    mov       [rbp + mc_writeexe.writeoptheader.header+4],	r10d
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[rax+24]
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r11,	[rax+24]
    add       r10,	r11
    mov       [rbp + mc_writeexe.writeoptheader.header+8],	r10d
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	[rax+40]
    mov       rcx,	r10
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.writeoptheader.header+12],	eax
    mov       rax,	[mc_writeexe.stentrypoint]
    cmp       rax,	0
    jnz       L4168
    mov       rax,	[mc_writeexe.stentrypoint2]
    mov       [mc_writeexe.stentrypoint],	rax
L4168:
L4167:
    mov       rax,	[mc_writeexe.stentrypoint]
    cmp       rax,	0
    jnz       L4170
    mov       rax,	[mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4172
    call      msys.m$print_startcon
    mov       rcx,	[mc_writeexe.userentrypoint]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rel L6045]
    call      mc_libmcl.axerror
    jmp       L4171
L4172:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4174
    lea       rcx,	[rel L6046]
    call      mc_libmcl.axerror
L4174:
L4173:
L4171:
    jmp       L4169
L4170:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+48]
    mov       rax,	[mc_writeexe.stentrypoint]
    movsxd    r11,	dword [rax+52]
    add       r10,	r11
    mov       [rbp + mc_writeexe.writeoptheader.header+16],	r10d
L4169:
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+20],	eax
    mov       rax,	[mc_writeexe.imagebase]
    mov       [rbp + mc_writeexe.writeoptheader.header+24],	rax
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+32],	eax
    mov       eax,	512
    mov       [rbp + mc_writeexe.writeoptheader.header+36],	eax
    mov       ax,	4
    mov       [rbp + mc_writeexe.writeoptheader.header+40],	ax
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+42],	ax
    mov       ax,	5
    mov       [rbp + mc_writeexe.writeoptheader.header+48],	ax
    mov       ax,	2
    mov       [rbp + mc_writeexe.writeoptheader.header+50],	ax
    mov       eax,	[mc_writeexe.imagesize]
    mov       [rbp + mc_writeexe.writeoptheader.header+56],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+32]
    mov       [rbp + mc_writeexe.writeoptheader.header+60],	r10d
    mov       ax,	3
    mov       [rbp + mc_writeexe.writeoptheader.header+68],	ax
    mov       rax,	4194304
    mov       [rbp + mc_writeexe.writeoptheader.header+72],	rax
    mov       rax,	2097152
    mov       [rbp + mc_writeexe.writeoptheader.header+80],	rax
    mov       rax,	1048576
    mov       [rbp + mc_writeexe.writeoptheader.header+88],	rax
    mov       rax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+96],	rax
    mov       eax,	16
    mov       [rbp + mc_writeexe.writeoptheader.header+108],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	[rax+48]
    mov       [rbp + mc_writeexe.writeoptheader.header+120],	r10d
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	[rax+40]
    sub       r10,	[mc_writeexe.exportdirvirtsize]
    sub       r10,	[mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+124],	r10d
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4176
    mov       ax,	64
    mov       [rbp + mc_writeexe.writeoptheader.header+70],	ax
    mov       eax,	[mc_writeexe.exportdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+112],	eax
    mov       eax,	[mc_writeexe.exportdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+116],	eax
    mov       eax,	[mc_writeexe.blockdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+152],	eax
    mov       eax,	[mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+156],	eax
L4176:
L4175:
    mov       eax,	[mc_writeexe.fileiatoffset]
    mov       [rbp + mc_writeexe.writeoptheader.header+208],	eax
    mov       eax,	[mc_writeexe.fileiatsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+212],	eax
    lea       rcx,	[rbp + mc_writeexe.writeoptheader.header]
    mov       rdx,	240
    call      mc_writeexe.writerecordx
L4166:
;---------------
    add       rsp,	272
    pop       rbp
    ret       
;End 
;Proc writesectionheader
mc_writeexe.writesectionheader:
;>>
    %define mc_writeexe.writesectionheader.s 16
    %define mc_writeexe.writesectionheader.sheader -40
    %define mc_writeexe.writesectionheader.aa -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[rbp + mc_writeexe.writesectionheader.sheader]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       rax,	[rbp + mc_writeexe.writesectionheader.s]
    mov       r10,	[rax+8]
    lea       rax,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rcx,	rax
    mov       rdx,	r10
    call      strcpy
    mov       rax,	[rbp + mc_writeexe.writesectionheader.s]
    mov       r10,	[rax+40]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+8],	r10d
    mov       rax,	[rbp + mc_writeexe.writesectionheader.s]
    mov       r10,	[rax+48]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+12],	r10d
    mov       rax,	[rbp + mc_writeexe.writesectionheader.s]
    mov       r10,	[rax+32]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+20],	r10d
    mov       rax,	[rbp + mc_writeexe.writesectionheader.s]
    mov       r10,	[rax+24]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+16],	r10d
    mov       rax,	[rbp + mc_writeexe.writesectionheader.s]
    mov       r10,	[rax+16]
    cmp       r10,	3
    jz        L4179
    cmp       r10,	2
    jz        L4180
    cmp       r10,	1
    jz        L4181
    cmp       r10,	5
    jz        L4182
    jmp       L4183
L4179:
    mov       rax,	3226468480
    mov       [rbp + mc_writeexe.writesectionheader.aa],	rax
    mov       eax,	[rbp + mc_writeexe.writesectionheader.aa]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	eax
    jmp       L4178
L4180:
    mov       rax,	3226468416
    mov       [rbp + mc_writeexe.writesectionheader.aa],	rax
    mov       eax,	[rbp + mc_writeexe.writesectionheader.aa]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	eax
    jmp       L4178
L4181:
    mov       rax,	1615855648
    mov       [rbp + mc_writeexe.writesectionheader.aa],	rax
    mov       eax,	[rbp + mc_writeexe.writesectionheader.aa]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	eax
    jmp       L4178
L4182:
    mov       rax,	3224371264
    mov       [rbp + mc_writeexe.writesectionheader.aa],	rax
    mov       eax,	[rbp + mc_writeexe.writesectionheader.aa]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	eax
L4183:
L4178:
    lea       rcx,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rdx,	40
    call      mc_writeexe.writerecordx
L4177:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc writesectiondata
mc_writeexe.writesectiondata:
;>>
    %define mc_writeexe.writesectiondata.s 16
    %define mc_writeexe.writesectiondata.$T1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r10,	[rax+16]
    cmp       r10,	5
    jz        L4186
    cmp       r10,	3
    jz        L4187
    jmp       L4188
L4186:
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r10,	[rax+40]
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r11,	[rax]
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_writeexe.writerecordx
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r11,	[rax+40]
    cmp       r10,	r11
    jle       L4190
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r11,	[rax+40]
    sub       r10,	r11
    add       [mc_writeexe.dataptr],	r10
L4190:
L4189:
    jmp       L4185
L4187:
    jmp       L4185
L4188:
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r10,	[rax+24]
    mov       [rbp + mc_writeexe.writesectiondata.$T1],	r10
    mov       rax,	[rbp + mc_writeexe.writesectiondata.s]
    mov       r10,	[rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.writesectiondata.$T1]
    call      mc_writeexe.writerecordx
L4185:
L4184:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc writeexporttable
mc_writeexe.writeexporttable:
;>>
    %define mc_writeexe.writeexporttable.pstart 16
    %define mc_writeexe.writeexporttable.sortindex -16000
    %define mc_writeexe.writeexporttable.phdr -16008
    %define mc_writeexe.writeexporttable.paddrtable -16016
    %define mc_writeexe.writeexporttable.pnametable -16024
    %define mc_writeexe.writeexporttable.pordtable -16032
    %define mc_writeexe.writeexporttable.pdllname -16040
    %define mc_writeexe.writeexporttable.pnames -16048
    %define mc_writeexe.writeexporttable.addrtableoffset -16056
    %define mc_writeexe.writeexporttable.nametableoffset -16064
    %define mc_writeexe.writeexporttable.ordtableoffset -16072
    %define mc_writeexe.writeexporttable.dllnameoffset -16080
    %define mc_writeexe.writeexporttable.namesoffset -16088
    %define mc_writeexe.writeexporttable.virtoffset -16096
    %define mc_writeexe.writeexporttable.sectionno -16104
    %define mc_writeexe.writeexporttable.d -16112
    %define mc_writeexe.writeexporttable.basename -16120
    %define mc_writeexe.writeexporttable.i -16128
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16160
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       [rbp + mc_writeexe.writeexporttable.phdr],	rax
    mov       eax,	1602876664
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+4],	eax
    mov       eax,	1
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+16],	eax
    mov       eax,	[mc_writeexe.nexports]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+20],	eax
    mov       eax,	[mc_writeexe.nexports]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+24],	eax
    mov       rax,	40
    mov       [rbp + mc_writeexe.writeexporttable.addrtableoffset],	rax
    mov       rax,	[mc_writeexe.nexports]
    imul      rax,	4
    mov       r10,	[rbp + mc_writeexe.writeexporttable.addrtableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.nametableoffset],	r10
    mov       rax,	[mc_writeexe.nexports]
    imul      rax,	4
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.ordtableoffset],	r10
    mov       rax,	[mc_writeexe.nexports]
    imul      rax,	2
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.dllnameoffset],	r10
    mov       rcx,	[mc_writeexe.dllfilename]
    call      strlen
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       r10,	rax
    add       r10,	1
    mov       [rbp + mc_writeexe.writeexporttable.namesoffset],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	[rax+48]
    add       r10,	[mc_writeexe.exportdiroffset]
    mov       [rbp + mc_writeexe.writeexporttable.virtoffset],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.addrtableoffset]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.writeexporttable.paddrtable],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.writeexporttable.pnametable],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.writeexporttable.pordtable],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.writeexporttable.pdllname],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    lea       rax,	[rax + r10]
    mov       [rbp + mc_writeexe.writeexporttable.pnames],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+12],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.addrtableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+28],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+32],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.phdr]
    mov       [r10+36],	eax
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.pdllname]
    mov       rdx,	[mc_writeexe.dllfilename]
    call      strcpy
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	2000
    jle       L4193
    lea       rcx,	[rel L6047]
    call      mc_libmcl.axerror
L4193:
L4192:
    lea       rcx,	[rbp + mc_writeexe.writeexporttable.sortindex]
    call      mc_writeexe.sortexports
    mov       rax,	1
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4196
L4194:
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       r10,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       rax,	[mc_writeexe.exporttable]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.writeexporttable.d],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       r10,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       rax,	[mc_writeexe.exporttable]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	[rax+8]
    mov       [rbp + mc_writeexe.writeexporttable.basename],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movzx     r10,	byte [rax+70]
    mov       rcx,	r10
    call      mc_writeexe.getsectionno
    mov       [rbp + mc_writeexe.writeexporttable.sectionno],	rax
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.pnames]
    mov       rdx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strcpy
    mov       rax,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.pnametable]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.writeexporttable.pnametable],	4
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    add       rax,	1
    add       [rbp + mc_writeexe.writeexporttable.namesoffset],	rax
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    add       rax,	1
    add       [rbp + mc_writeexe.writeexporttable.pnames],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movsxd    r10,	dword [rax+52]
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r11,	[rbp + mc_writeexe.writeexporttable.sectionno]
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       rax,	[rax + r11-72]
    mov       r11,	[rax+48]
    add       r10,	r11
    mov       rax,	[rbp + mc_writeexe.writeexporttable.paddrtable]
    mov       [rax],	r10d
    add       qword [rbp + mc_writeexe.writeexporttable.paddrtable],	4
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    sub       rax,	1
    mov       r10,	[rbp + mc_writeexe.writeexporttable.pordtable]
    mov       [r10],	ax
    add       qword [rbp + mc_writeexe.writeexporttable.pordtable],	2
L4195:
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    inc       rax
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    cmp       rax,	[mc_writeexe.nexports]
    jle       L4194
L4196:
L4191:
;---------------
    add       rsp,	16160
    pop       rbp
    ret       
;End 
;Proc getexporttablesize
mc_writeexe.getexporttablesize:
;>>
    %define mc_writeexe.getexporttablesize.size -8
    %define mc_writeexe.getexporttablesize.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	40
    mov       [rbp + mc_writeexe.getexporttablesize.size],	rax
    mov       rax,	[mc_writeexe.nexports]
    imul      rax,	4
    add       [rbp + mc_writeexe.getexporttablesize.size],	rax
    mov       rax,	[mc_writeexe.nexports]
    imul      rax,	4
    add       [rbp + mc_writeexe.getexporttablesize.size],	rax
    mov       rax,	[mc_writeexe.nexports]
    imul      rax,	2
    add       [rbp + mc_writeexe.getexporttablesize.size],	rax
    mov       rcx,	[mc_writeexe.dllfilename]
    call      strlen
    add       rax,	1
    add       [rbp + mc_writeexe.getexporttablesize.size],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getexporttablesize.i],	rax
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4200
L4198:
    lea       rax,	[mc_writeexe.exporttable]
    mov       r10,	[rbp + mc_writeexe.getexporttablesize.i]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	[rax]
    mov       rax,	[r10]
    mov       rcx,	rax
    call      strlen
    add       rax,	1
    add       [rbp + mc_writeexe.getexporttablesize.size],	rax
L4199:
    mov       rax,	[rbp + mc_writeexe.getexporttablesize.i]
    inc       rax
    mov       [rbp + mc_writeexe.getexporttablesize.i],	rax
    cmp       rax,	[mc_writeexe.nexports]
    jle       L4198
L4200:
    mov       rax,	[rbp + mc_writeexe.getexporttablesize.size]
L4197:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc newbasereloc
mc_writeexe.newbasereloc:
;>>
    %define mc_writeexe.newbasereloc.addr 16
    %define mc_writeexe.newbasereloc.reltype 24
    %define mc_writeexe.newbasereloc.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       [rbp + mc_writeexe.newbasereloc.p],	rax
    mov       eax,	[rbp + mc_writeexe.newbasereloc.addr]
    mov       r10,	[rbp + mc_writeexe.newbasereloc.p]
    mov       [r10+8],	eax
    mov       eax,	[rbp + mc_writeexe.newbasereloc.reltype]
    mov       r10,	[rbp + mc_writeexe.newbasereloc.p]
    mov       [r10+12],	eax
    mov       rax,	[mc_writeexe.basereloclist]
    mov       r10,	[rbp + mc_writeexe.newbasereloc.p]
    mov       [r10],	rax
    mov       rax,	[rbp + mc_writeexe.newbasereloc.p]
    mov       [mc_writeexe.basereloclist],	rax
    inc       qword [mc_writeexe.nbaserelocs]
    mov       rax,	[rbp + mc_writeexe.newbasereloc.addr]
    cmp       [mc_writeexe.maxrelocaddr],	rax
    jge       L6048
    mov       [mc_writeexe.maxrelocaddr],	rax
L6048:
L4201:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc scanbaserelocs
mc_writeexe.scanbaserelocs:
;>>
    %define mc_writeexe.scanbaserelocs.baseaddr -8
    %define mc_writeexe.scanbaserelocs.addr -16
    %define mc_writeexe.scanbaserelocs.nextblock -24
    %define mc_writeexe.scanbaserelocs.p -32
    %define mc_writeexe.scanbaserelocs.i -40
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rax,	4096
    mov       [rbp + mc_writeexe.scanbaserelocs.baseaddr],	rax
    xor       eax,	eax
    mov       [mc_writeexe.nbaseblocks],	rax
L4203:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.baseaddr]
    add       rax,	4096
    mov       [rbp + mc_writeexe.scanbaserelocs.nextblock],	rax
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	500
    jl        L4207
    lea       rcx,	[rel L6049]
    call      mc_libmcl.axerror
L4207:
L4206:
    inc       qword [mc_writeexe.nbaseblocks]
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.baseaddr]
    lea       r10,	[mc_writeexe.blockbases]
    mov       r11,	[mc_writeexe.nbaseblocks]
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[mc_writeexe.blockcounts]
    mov       r11,	[mc_writeexe.nbaseblocks]
    mov       [r10 + r11*4-4],	eax
    mov       rax,	[mc_writeexe.basereloclist]
    mov       [rbp + mc_writeexe.scanbaserelocs.p],	rax
    jmp       L4209
L4208:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.p]
    mov       r10d,	[rax+8]
    mov       [rbp + mc_writeexe.scanbaserelocs.addr],	r10
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.addr]
    cmp       rax,	[rbp + mc_writeexe.scanbaserelocs.baseaddr]
    jl        L4212
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.addr]
    cmp       rax,	[rbp + mc_writeexe.scanbaserelocs.nextblock]
    jge       L4212
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[mc_writeexe.nbaseblocks]
    lea       rax,	[rax + r10*4-4]
    inc       dword [rax]
L4212:
L4211:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.p]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.scanbaserelocs.p],	r10
L4209:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.p]
    test      rax,	rax
    jnz       L4208
L4210:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.nextblock]
    mov       [rbp + mc_writeexe.scanbaserelocs.baseaddr],	rax
L4204:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.baseaddr]
    cmp       rax,	[mc_writeexe.maxrelocaddr]
    jle       L4203
L4205:
    mov       rax,	1
    mov       [rbp + mc_writeexe.scanbaserelocs.i],	rax
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4215
L4213:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    movsxd    r11,	dword [rax + r10*4-4]
    test      r11,	r11
    jz        L4217
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    movsxd    r11,	dword [rax + r10*4-4]
    and       r11d,	1
    test      r11,	r11
    jz        L4219
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    lea       rax,	[rax + r10*4-4]
    inc       dword [rax]
    lea       rax,	[mc_writeexe.blockpadding]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    lea       rax,	[rax + r10-1]
    inc       byte [rax]
L4219:
L4218:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    movsxd    r11,	dword [rax + r10*4-4]
    imul      r11,	2
    add       r11,	8
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    mov       [rax + r10*4-4],	r11d
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	[rbp + mc_writeexe.scanbaserelocs.i]
    movsxd    r11,	dword [rax + r10*4-4]
    add       [mc_writeexe.basetablesize],	r11
L4217:
L4216:
L4214:
    mov       rax,	[rbp + mc_writeexe.scanbaserelocs.i]
    inc       rax
    mov       [rbp + mc_writeexe.scanbaserelocs.i],	rax
    cmp       rax,	[mc_writeexe.nbaseblocks]
    jle       L4213
L4215:
L4202:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc writebasereloctable
mc_writeexe.writebasereloctable:
;>>
    %define mc_writeexe.writebasereloctable.pstart 16
    %define mc_writeexe.writebasereloctable.p32 -8
    %define mc_writeexe.writebasereloctable.p16 -16
    %define mc_writeexe.writebasereloctable.baseaddr -24
    %define mc_writeexe.writebasereloctable.addr -32
    %define mc_writeexe.writebasereloctable.nextblock -40
    %define mc_writeexe.writebasereloctable.q -48
    %define mc_writeexe.writebasereloctable.i -56
    %define mc_writeexe.writebasereloctable.$T1 -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.pstart]
    mov       [rbp + mc_writeexe.writebasereloctable.p32],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.writebasereloctable.i],	rax
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4223
L4221:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.i]
    movsxd    r11,	dword [rax + r10*4-4]
    test      r11,	r11
    jz        L4225
    lea       rax,	[mc_writeexe.blockbases]
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.p32]
    mov       [rax],	r11d
    add       qword [rbp + mc_writeexe.writebasereloctable.p32],	4
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.i]
    movsxd    r11,	dword [rax + r10*4-4]
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.p32]
    mov       [rax],	r11d
    add       qword [rbp + mc_writeexe.writebasereloctable.p32],	4
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.p32]
    mov       [rbp + mc_writeexe.writebasereloctable.p16],	rax
    mov       rax,	[mc_writeexe.basereloclist]
    mov       [rbp + mc_writeexe.writebasereloctable.q],	rax
    lea       rax,	[mc_writeexe.blockbases]
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_writeexe.writebasereloctable.baseaddr],	r11
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.baseaddr]
    add       rax,	4096
    mov       [rbp + mc_writeexe.writebasereloctable.nextblock],	rax
    jmp       L4227
L4226:
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.q]
    mov       r10d,	[rax+8]
    mov       [rbp + mc_writeexe.writebasereloctable.addr],	r10
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.addr]
    cmp       rax,	[rbp + mc_writeexe.writebasereloctable.baseaddr]
    jl        L4230
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.addr]
    cmp       rax,	[rbp + mc_writeexe.writebasereloctable.nextblock]
    jge       L4230
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.addr]
    sub       rax,	[rbp + mc_writeexe.writebasereloctable.baseaddr]
    mov       [rbp + mc_writeexe.writebasereloctable.$T1],	rax
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.q]
    movsxd    r10,	dword [rax+12]
    cmp       r10,	2
    jnz       L4232
    mov       rax,	3
    jmp       L4231
L4232:
    mov       rax,	10
L4231:
    shl       rax,	12
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.$T1]
    add       r10,	rax
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.p16]
    mov       [rax],	r10w
    add       qword [rbp + mc_writeexe.writebasereloctable.p16],	2
L4230:
L4229:
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.q]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.writebasereloctable.q],	r10
L4227:
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.q]
    test      rax,	rax
    jnz       L4226
L4228:
    lea       rax,	[mc_writeexe.blockpadding]
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L4234
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.p16]
    add       qword [rbp + mc_writeexe.writebasereloctable.p16],	2
    xor       r10d,	r10d
    mov       [rax],	r10w
L4234:
L4233:
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.p16]
    mov       [rbp + mc_writeexe.writebasereloctable.p32],	rax
L4225:
L4224:
L4222:
    mov       rax,	[rbp + mc_writeexe.writebasereloctable.i]
    inc       rax
    mov       [rbp + mc_writeexe.writebasereloctable.i],	rax
    cmp       rax,	[mc_writeexe.nbaseblocks]
    jle       L4221
L4223:
L4220:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc sortexports
mc_writeexe.sortexports:
;>>
    %define mc_writeexe.sortexports.sortindex 16
    %define mc_writeexe.sortexports.d -8
    %define mc_writeexe.sortexports.e -16
    %define mc_writeexe.sortexports.swapped -24
    %define mc_writeexe.sortexports.av_1 -32
    %define mc_writeexe.sortexports.i -40
    %define mc_writeexe.sortexports.$T1 -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mc_writeexe.sortexports.i],	rax
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4238
L4236:
    mov       rax,	[rbp + mc_writeexe.sortexports.i]
    mov       r10,	[rbp + mc_writeexe.sortexports.sortindex]
    mov       r11,	[rbp + mc_writeexe.sortexports.i]
    mov       [r10 + r11*8-8],	rax
L4237:
    mov       rax,	[rbp + mc_writeexe.sortexports.i]
    inc       rax
    mov       [rbp + mc_writeexe.sortexports.i],	rax
    cmp       rax,	[mc_writeexe.nexports]
    jle       L4236
L4238:
L4239:
    xor       eax,	eax
    mov       [rbp + mc_writeexe.sortexports.swapped],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.sortexports.i],	rax
    mov       rax,	[mc_writeexe.nexports]
    sub       rax,	1
    mov       [rbp + mc_writeexe.sortexports.av_1],	rax
    mov       rax,	[rbp + mc_writeexe.sortexports.av_1]
    cmp       rax,	1
    jl        L4244
L4242:
    mov       rax,	[rbp + mc_writeexe.sortexports.sortindex]
    mov       r10,	[rbp + mc_writeexe.sortexports.i]
    mov       r11,	[rax + r10*8-8]
    lea       rax,	[mc_writeexe.exporttable]
    shl       r11,	4
    lea       rax,	[rax + r11-16]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.sortexports.d],	r10
    mov       rax,	[rbp + mc_writeexe.sortexports.sortindex]
    mov       r10,	[rbp + mc_writeexe.sortexports.i]
    mov       r11,	[rax + r10*8]
    lea       rax,	[mc_writeexe.exporttable]
    shl       r11,	4
    lea       rax,	[rax + r11-16]
    mov       r10,	[rax]
    mov       [rbp + mc_writeexe.sortexports.e],	r10
    mov       rax,	[rbp + mc_writeexe.sortexports.e]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      pc_api.getbasename
    mov       [rbp + mc_writeexe.sortexports.$T1],	rax
    mov       rax,	[rbp + mc_writeexe.sortexports.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.sortexports.$T1]
    call      strcmp
    movsxd    rax,	eax
    cmp       rax,	0
    jle       L4246
    mov       rax,	1
    mov       [rbp + mc_writeexe.sortexports.swapped],	rax
    mov       rax,	[rbp + mc_writeexe.sortexports.sortindex]
    mov       r10,	[rbp + mc_writeexe.sortexports.i]
    lea       rax,	[rax + r10*8-8]
    mov       r10,	[rbp + mc_writeexe.sortexports.sortindex]
    mov       r11,	[rbp + mc_writeexe.sortexports.i]
    lea       r10,	[r10 + r11*8]
    mov       r11,	[rax]
    mov       rdi,	[r10]
    mov       [r10],	r11
    mov       [rax],	rdi
L4246:
L4245:
L4243:
    mov       rax,	[rbp + mc_writeexe.sortexports.i]
    inc       rax
    mov       [rbp + mc_writeexe.sortexports.i],	rax
    cmp       rax,	[rbp + mc_writeexe.sortexports.av_1]
    jle       L4242
L4244:
L4240:
    mov       rax,	[rbp + mc_writeexe.sortexports.swapped]
    test      rax,	rax
    jnz       L4239
L4241:
L4235:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc getsectionno
mc_writeexe.getsectionno:
;>>
    %define mc_writeexe.getsectionno.segment 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.getsectionno.segment]
    cmp       rax,	3
    jz        L4249
    cmp       rax,	2
    jz        L4250
    cmp       rax,	1
    jz        L4251
    jmp       L4252
L4249:
    mov       rax,	3
    jmp       L4248
L4250:
    mov       rax,	2
    jmp       L4248
L4251:
    mov       rax,	1
    jmp       L4248
L4252:
    lea       rcx,	[rel L6050]
    call      mc_libmcl.axerror
    xor       eax,	eax
L4248:
L4247:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc getoffsets
mc_writeexe.getoffsets:
;>>
    %define mc_writeexe.getoffsets.fileoffset -8
    %define mc_writeexe.getoffsets.imageoffset -16
    %define mc_writeexe.getoffsets.i -24
    %define mc_writeexe.getoffsets.diroffset -32
    %define mc_writeexe.getoffsets.impdirno -40
    %define mc_writeexe.getoffsets.hinttableoffset -48
    %define mc_writeexe.getoffsets.j -56
    %define mc_writeexe.getoffsets.n -64
    %define mc_writeexe.getoffsets.codesize -72
    %define mc_writeexe.getoffsets.length -80
    %define mc_writeexe.getoffsets.thunkoffset -88
    %define mc_writeexe.getoffsets.offset -96
    %define mc_writeexe.getoffsets.dirstartoffset -104
    %define mc_writeexe.getoffsets.pcode -112
    %define mc_writeexe.getoffsets.pimpdir -120
    %define mc_writeexe.getoffsets.pdir -128
    %define mc_writeexe.getoffsets.paddr -136
    %define mc_writeexe.getoffsets.pname -144
    %define mc_writeexe.getoffsets.iatoffset -152
    %define mc_writeexe.getoffsets.phint -160
    %define mc_writeexe.getoffsets.pextra -168
    %define mc_writeexe.getoffsets.xxx -176
    %define mc_writeexe.getoffsets.av_1 -184
    %define mc_writeexe.getoffsets.thunkptr -192
    %define mc_writeexe.getoffsets.codebase -200
    %define mc_writeexe.getoffsets.thunkaddr -208
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	240
;---------------
    mov       rax,	392
    mov       [rbp + mc_writeexe.getoffsets.fileoffset],	rax
    mov       rax,	40
    imul      rax,	[mc_writeexe.nsections]
    add       [rbp + mc_writeexe.getoffsets.fileoffset],	rax
    mov       rcx,	[rbp + mc_writeexe.getoffsets.fileoffset]
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.getoffsets.fileoffset],	rax
    mov       rax,	4096
    mov       [rbp + mc_writeexe.getoffsets.imageoffset],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+40]
    mov       [rbp + mc_writeexe.getoffsets.codesize],	r10
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.codesize]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.pcode],	rax
    jmp       L4255
L4254:
    mov       rax,	[rbp + mc_writeexe.getoffsets.pcode]
    inc       qword [rbp + mc_writeexe.getoffsets.pcode]
    mov       r10b,	144
    mov       [rax],	r10b
    inc       qword [rbp + mc_writeexe.getoffsets.codesize]
L4255:
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    and       rax,	7
    test      rax,	rax
    jnz       L4254
L4256:
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rbp + mc_writeexe.getoffsets.thunkoffset],	rax
    mov       rax,	[mc_writeexe.nimports]
    imul      rax,	8
    add       [rbp + mc_writeexe.getoffsets.codesize],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    sub       rax,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    add       rax,	16
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	rax
    call      mc_genss.buffercheck
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4259
L4257:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rax+16]
    cmp       r10,	3
    jz        L4261
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rbp + mc_writeexe.getoffsets.fileoffset]
    mov       [rax+32],	r10
L4261:
L4260:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rax+16]
    cmp       r10,	3
    jz        L4263
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rax+40]
    mov       rax,	[rbp + mc_writeexe.getoffsets.fileoffset]
    add       rax,	r10
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.getoffsets.fileoffset],	rax
L4263:
L4262:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rbp + mc_writeexe.getoffsets.imageoffset]
    mov       [rax+48],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rax+16]
    cmp       r10,	5
    jnz       L4265
    mov       rax,	[rbp + mc_writeexe.getoffsets.imageoffset]
    mov       [rbp + mc_writeexe.getoffsets.diroffset],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    mov       [rbp + mc_writeexe.getoffsets.impdirno],	rax
L4265:
L4264:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rax+40]
    mov       rax,	[rbp + mc_writeexe.getoffsets.imageoffset]
    add       rax,	r10
    mov       rcx,	rax
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.getoffsets.imageoffset],	rax
L4258:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.nsections]
    jle       L4257
L4259:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4267
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
L4267:
L4266:
    mov       rax,	[mc_writeexe.ndlls]
    add       rax,	1
    imul      rax,	20
    add       [rbp + mc_writeexe.getoffsets.diroffset],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4270
L4268:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+8]
    add       r10,	1
    imul      r10,	8
    add       [rbp + mc_writeexe.getoffsets.diroffset],	r10
L4269:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.ndlls]
    jle       L4268
L4270:
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [mc_writeexe.fileiatoffset],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4273
L4271:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [rax+24],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+8]
    add       r10,	1
    imul      r10,	8
    add       [rbp + mc_writeexe.getoffsets.diroffset],	r10
L4272:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.ndlls]
    jle       L4271
L4273:
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    sub       rax,	[mc_writeexe.fileiatoffset]
    mov       [mc_writeexe.fileiatsize],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [rbp + mc_writeexe.getoffsets.hinttableoffset],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4276
L4274:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+16]
    mov       rcx,	r10
    call      strlen
    add       rax,	3
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    test      rax,	rax
    jz        L4278
    inc       qword [rbp + mc_writeexe.getoffsets.length]
L4278:
L4277:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [rax+24],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       [rbp + mc_writeexe.getoffsets.diroffset],	rax
L4275:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.nimports]
    jle       L4274
L4276:
    mov       rcx,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       rdx,	4
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.getoffsets.diroffset],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4281
L4279:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      strlen
    add       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    test      rax,	rax
    jz        L4283
    inc       qword [rbp + mc_writeexe.getoffsets.length]
L4283:
L4282:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+8]
    imul      r10,	4
    add       [rbp + mc_writeexe.getoffsets.diroffset],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [rax+32],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       [rbp + mc_writeexe.getoffsets.diroffset],	rax
L4280:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.ndlls]
    jle       L4279
L4281:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.impdirno]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rax+48]
    mov       [rbp + mc_writeexe.getoffsets.dirstartoffset],	r10
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4285
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [mc_writeexe.exportdirvirtaddr],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [mc_writeexe.exportdiroffset],	rax
    call      mc_writeexe.getexporttablesize
    mov       [mc_writeexe.exportdirvirtsize],	rax
    mov       rax,	[mc_writeexe.exportdirvirtsize]
    add       [rbp + mc_writeexe.getoffsets.diroffset],	rax
    call      mc_writeexe.scanbaserelocs
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    mov       [mc_writeexe.blockdirvirtaddr],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [mc_writeexe.blockdiroffset],	rax
    mov       rax,	[mc_writeexe.basetablesize]
    mov       [mc_writeexe.blockdirvirtsize],	rax
    mov       rax,	[mc_writeexe.blockdirvirtsize]
    add       [rbp + mc_writeexe.getoffsets.diroffset],	rax
L4285:
L4284:
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.offset],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.impdirno]
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rbp + mc_writeexe.getoffsets.offset]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	[rbp + mc_writeexe.getoffsets.impdirno]
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.fileoffset]
    add       rax,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [mc_writeexe.filesize],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.diroffset]
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       r10,	[rbp + mc_writeexe.getoffsets.imageoffset]
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       [mc_writeexe.imagesize],	rax
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    call      mlib.pcm_allocz
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	[rbp + mc_writeexe.getoffsets.impdirno]
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10],	rax
    mov       [rbp + mc_writeexe.getoffsets.pimpdir],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       [rbp + mc_writeexe.getoffsets.pdir],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4288
L4286:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [rax],	r10d
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [rax+16],	r10d
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+32]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [rax+12],	r10d
    add       qword [rbp + mc_writeexe.getoffsets.pdir],	20
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+24]
    mov       [rbp + mc_writeexe.getoffsets.iatoffset],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.paddr],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+16]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.pname],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4291
L4289:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+8]
    cmp       r10,	[rbp + mc_writeexe.getoffsets.i]
    jnz       L4293
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_writeexe.getoffsets.paddr]
    mov       [rax],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.pname]
    mov       [rax],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    mov       [rax+32],	r10
    mov       rax,	8
    add       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    add       qword [rbp + mc_writeexe.getoffsets.pname],	8
    add       qword [rbp + mc_writeexe.getoffsets.paddr],	8
L4293:
L4292:
L4290:
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[mc_writeexe.nimports]
    jle       L4289
L4291:
L4287:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.ndlls]
    jle       L4286
L4288:
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4296
L4294:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+24]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.phint],	rax
    add       qword [rbp + mc_writeexe.getoffsets.phint],	2
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+16]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	r10
    call      strcpy
L4295:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.nimports]
    jle       L4294
L4296:
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.xxx],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4299
L4297:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+40]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.pextra],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+8]
    mov       [rbp + mc_writeexe.getoffsets.av_1],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    cmp       rax,	1
    jl        L4302
L4300:
    mov       eax,	[rbp + mc_writeexe.getoffsets.xxx]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pextra]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.pextra],	4
L4301:
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    jle       L4300
L4302:
    mov       rax,	20
    add       [rbp + mc_writeexe.getoffsets.xxx],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax+32]
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.phint],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	[rax]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	r10
    call      strcpy
L4298:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.ndlls]
    jle       L4297
L4299:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4304
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[mc_writeexe.exportdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writeexporttable
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[mc_writeexe.blockdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writebasereloctable
L4304:
L4303:
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.thunkptr],	rax
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.codebase],	rax
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4307
L4305:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       rax,	[rbp + mc_writeexe.getoffsets.codebase]
    lea       r10,	[mc_writeexe.importtable]
    mov       r11,	[rbp + mc_writeexe.getoffsets.i]
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11]
    mov       [r10+40],	rax
    movzx     rax,	byte [mc_decls.phighmem]
    cmp       rax,	0
    jnz       L4309
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+32]
    mov       rax,	[mc_writeexe.imagebase]
    add       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	rax
    mov       eax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.thunkptr],	4
    jmp       L4308
L4309:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.i]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rax+32]
    mov       rax,	[mc_writeexe.imagebase]
    add       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    sub       rax,	[mc_writeexe.imagebase]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       r10,	[rbp + mc_writeexe.getoffsets.codebase]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_writeexe.getripoffset
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.thunkptr],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	144
    mov       [rax],	r10b
L4308:
L4306:
    mov       rax,	[rbp + mc_writeexe.getoffsets.i]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.i],	rax
    cmp       rax,	[mc_writeexe.nimports]
    jle       L4305
L4307:
L4253:
;---------------
    add       rsp,	240
    pop       rbp
    ret       
;End 
;Proc getripoffset
mc_writeexe.getripoffset:
;>>
    %define mc_writeexe.getripoffset.addr 16
    %define mc_writeexe.getripoffset.dest 24
    %define mc_writeexe.getripoffset.extra 32
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rax+48]
    add       [rbp + mc_writeexe.getripoffset.addr],	r10
    mov       rax,	[rbp + mc_writeexe.getripoffset.addr]
    add       rax,	4
    mov       r10,	[rbp + mc_writeexe.getripoffset.dest]
    sub       r10,	rax
    sub       r10,	[rbp + mc_writeexe.getripoffset.extra]
    mov       rax,	r10
L4310:
;---------------
    pop       rbp
    ret       
;End 
;Proc writecoff
mc_writeobj.writecoff:
;>>
    %define mc_writeobj.writecoff.outfile 16
    %define mc_writeobj.writecoff.header -24
    %define mc_writeobj.writecoff.zsection -64
    %define mc_writeobj.writecoff.isection -104
    %define mc_writeobj.writecoff.csection -144
    %define mc_writeobj.writecoff.offset -152
    %define mc_writeobj.writecoff.aa -160
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[rbp + mc_writeobj.writecoff.header]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       ax,	34404
    mov       [rbp + mc_writeobj.writecoff.header],	ax
    mov       ax,	3
    mov       [rbp + mc_writeobj.writecoff.header+2],	ax
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rcx,	rax
    lea       rdx,	[rel L6051]
    call      strcpy
    mov       eax,	[mc_decls.ss_zdatalen]
    mov       [rbp + mc_writeobj.writecoff.zsection+16],	eax
    mov       eax,	3225419904
    mov       [rbp + mc_writeobj.writecoff.zsection+36],	eax
    mov       rax,	[mc_decls.ss_nidatarelocs]
    cmp       rax,	65536
    jge       L4314
    mov       rax,	[mc_decls.ss_ncoderelocs]
    cmp       rax,	65536
    jl        L4313
L4314:
    lea       rcx,	[rel L6052]
    call      mc_libmcl.axerror
L4313:
L4312:
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    mov       rcx,	rax
    lea       rdx,	[rel L6053]
    call      strcpy
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.isection+16],	eax
    mov       ax,	[mc_decls.ss_nidatarelocs]
    mov       [rbp + mc_writeobj.writecoff.isection+32],	ax
    mov       eax,	3226468416
    mov       [rbp + mc_writeobj.writecoff.isection+36],	eax
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    mov       rcx,	rax
    lea       rdx,	[rel L6054]
    call      strcpy
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.csection+16],	eax
    mov       ax,	[mc_decls.ss_ncoderelocs]
    mov       [rbp + mc_writeobj.writecoff.csection+32],	ax
    mov       eax,	1615855648
    mov       [rbp + mc_writeobj.writecoff.csection+36],	eax
    mov       rcx,	[rbp + mc_writeobj.writecoff.outfile]
    call      mc_writeobj.initsymboltable
    call      mc_writeobj.convertsymboltable
    mov       rax,	20
    mov       [rbp + mc_writeobj.writecoff.offset],	rax
    mov       rax,	120
    add       [rbp + mc_writeobj.writecoff.offset],	rax
    movzx     rax,	word [rbp + mc_writeobj.writecoff.isection+32]
    test      rax,	rax
    jz        L4316
    mov       eax,	[rbp + mc_writeobj.writecoff.offset]
    mov       [rbp + mc_writeobj.writecoff.isection+24],	eax
    movzx     rax,	word [rbp + mc_writeobj.writecoff.isection+32]
    imul      rax,	10
    add       [rbp + mc_writeobj.writecoff.offset],	rax
L4316:
L4315:
    movzx     rax,	word [rbp + mc_writeobj.writecoff.csection+32]
    test      rax,	rax
    jz        L4318
    mov       eax,	[rbp + mc_writeobj.writecoff.offset]
    mov       [rbp + mc_writeobj.writecoff.csection+24],	eax
    movzx     rax,	word [rbp + mc_writeobj.writecoff.csection+32]
    imul      rax,	10
    add       [rbp + mc_writeobj.writecoff.offset],	rax
L4318:
L4317:
    mov       eax,	[rbp + mc_writeobj.writecoff.offset]
    mov       [rbp + mc_writeobj.writecoff.isection+20],	eax
    mov       eax,	[rbp + mc_writeobj.writecoff.isection+16]
    add       [rbp + mc_writeobj.writecoff.offset],	rax
    mov       eax,	[rbp + mc_writeobj.writecoff.offset]
    mov       [rbp + mc_writeobj.writecoff.csection+20],	eax
    mov       eax,	[rbp + mc_writeobj.writecoff.csection+16]
    add       [rbp + mc_writeobj.writecoff.offset],	rax
    mov       eax,	[rbp + mc_writeobj.writecoff.offset]
    mov       [rbp + mc_writeobj.writecoff.header+8],	eax
    mov       rax,	[mc_writeobj.nsymbols]
    imul      rax,	18
    add       [rbp + mc_writeobj.writecoff.offset],	rax
    mov       eax,	[mc_writeobj.nsymbols]
    mov       [rbp + mc_writeobj.writecoff.header+12],	eax
    mov       rax,	[mc_writeobj.nextstringoffset]
    add       [rbp + mc_writeobj.writecoff.offset],	rax
    mov       rcx,	[rbp + mc_writeobj.writecoff.offset]
    call      malloc
    mov       [mc_writeobj.dataptr],	rax
    mov       [mc_writeobj.datastart],	rax
    lea       rcx,	[rbp + mc_writeobj.writecoff.header]
    mov       rdx,	20
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.isection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.csection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    mov       rcx,	[mc_decls.ss_idatarelocs]
    mov       rdx,	[mc_decls.ss_nidatarelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[mc_decls.ss_coderelocs]
    mov       rdx,	[mc_decls.ss_ncoderelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_writeobj.writedata
    mov       rcx,	[mc_decls.ss_code]
    call      mc_writeobj.writedata
    call      mc_writeobj.writesymboltable
    call      mc_writeobj.writestringtable
    movzx     rax,	byte [pc_decls.pverbose]
    test      rax,	rax
    jz        L4320
    call      msys.m$print_startcon
    lea       rcx,	[rel L6055]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mc_writeobj.writecoff.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4320:
L4319:
    mov       rax,	[mc_writeobj.dataptr]
    sub       rax,	[mc_writeobj.datastart]
    mov       rcx,	[rbp + mc_writeobj.writecoff.outfile]
    mov       rdx,	[mc_writeobj.datastart]
    mov       r8,	rax
    call      mlib.writefile
L4311:
;---------------
    add       rsp,	192
    pop       rbp
    ret       
;End 
;Proc writerecord
mc_writeobj.writerecord:
;>>
    %define mc_writeobj.writerecord.r 16
    %define mc_writeobj.writerecord.length 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	[rbp + mc_writeobj.writerecord.r]
    mov       r8,	[rbp + mc_writeobj.writerecord.length]
    call      memcpy
    mov       rax,	[rbp + mc_writeobj.writerecord.length]
    add       [mc_writeobj.dataptr],	rax
L4321:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc writerelocs
mc_writeobj.writerelocs:
;>>
    %define mc_writeobj.writerelocs.r 16
    %define mc_writeobj.writerelocs.nrelocs 24
    %define mc_writeobj.writerelocs.d -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mc_writeobj.writerelocs.nrelocs]
    cmp       rax,	0
    jnz       L4324
    jmp       L4322
L4324:
L4323:
    jmp       L4326
L4325:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jz        L4329
    cmp       r10,	1
    jz        L4329
    jmp       L4330
L4329:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+24]
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_writeobj.writerelocs.d],	r11
    mov       rax,	[rbp + mc_writeobj.writerelocs.d]
    movzx     r10,	byte [rax+70]
    cmp       r10,	3
    jz        L4332
    cmp       r10,	2
    jz        L4333
    cmp       r10,	1
    jz        L4334
    cmp       r10,	0
    jz        L4335
    jmp       L4336
L4332:
    mov       eax,	2
    mov       [mc_writeobj.writerelocs.s+4],	eax
    jmp       L4331
L4333:
    mov       eax,	4
    mov       [mc_writeobj.writerelocs.s+4],	eax
    jmp       L4331
L4334:
    mov       eax,	6
    mov       [mc_writeobj.writerelocs.s+4],	eax
    jmp       L4331
L4335:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+24]
    add       r10,	[mc_writeobj.stoffset]
    mov       [mc_writeobj.writerelocs.s+4],	r10d
    jmp       L4331
L4336:
    lea       rcx,	[rel L6056]
    call      mc_libmcl.axerror
L4331:
    jmp       L4328
L4330:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+24]
    add       r10,	[mc_writeobj.stoffset]
    mov       [mc_writeobj.writerelocs.s+4],	r10d
L4328:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+8]
    mov       [mc_writeobj.writerelocs.s+8],	r10w
    movzx     rax,	byte [mc_decls.phighmem]
    cmp       rax,	0
    jz        L4338
    cmp       rax,	2
    jz        L4339
    jmp       L4340
L4338:
    jmp       L4337
L4339:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4342
    mov       ax,	4
    mov       [mc_writeobj.writerelocs.s+8],	ax
    mov       rax,	4
    mov       r10,	[rbp + mc_writeobj.writerelocs.r]
    mov       [r10+8],	rax
L4342:
L4341:
    jmp       L4337
L4340:
    lea       rcx,	[rel L6057]
    call      mc_libmcl.axerror
L4337:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax+16]
    mov       [mc_writeobj.writerelocs.s],	r10d
    mov       rcx,	[mc_writeobj.dataptr]
    lea       rdx,	[mc_writeobj.writerelocs.s]
    mov       r8,	10
    call      memcpy
    add       qword [mc_writeobj.dataptr],	10
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    mov       r10,	[rax]
    mov       [rbp + mc_writeobj.writerelocs.r],	r10
L4326:
    mov       rax,	[rbp + mc_writeobj.writerelocs.r]
    test      rax,	rax
    jnz       L4325
L4327:
L4322:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc writedata
mc_writeobj.writedata:
;>>
    %define mc_writeobj.writedata.data 16
    %define mc_writeobj.writedata.$T1 -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mc_writeobj.writedata.data]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writedata.$T1],	rax
    mov       rcx,	[rbp + mc_writeobj.writedata.data]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	[rbp + mc_writeobj.writedata.$T1]
    call      memcpy
    mov       rcx,	[rbp + mc_writeobj.writedata.data]
    call      mc_genss.bufferlength
    add       [mc_writeobj.dataptr],	rax
L4343:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc writesymboltable
mc_writeobj.writesymboltable:
;>>
    %define mc_writeobj.writesymboltable.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mc_writeobj.writesymboltable.i],	rax
    mov       rax,	[mc_writeobj.nsymbols]
    cmp       rax,	1
    jl        L4347
L4345:
    lea       rax,	[mc_writeobj.symboltable]
    mov       r10,	[rbp + mc_writeobj.writesymboltable.i]
    shl       r10,	1
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	18
    call      mc_writeobj.writerecord
L4346:
    mov       rax,	[rbp + mc_writeobj.writesymboltable.i]
    inc       rax
    mov       [rbp + mc_writeobj.writesymboltable.i],	rax
    cmp       rax,	[mc_writeobj.nsymbols]
    jle       L4345
L4347:
L4344:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc writestringtable
mc_writeobj.writestringtable:
;>>
    %define mc_writeobj.writestringtable.p -8
    %define mc_writeobj.writestringtable.i -16
    %define mc_writeobj.writestringtable.n -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rax,	[mc_writeobj.dataptr]
    mov       [rbp + mc_writeobj.writestringtable.p],	rax
    mov       eax,	[mc_writeobj.nextstringoffset]
    mov       r10,	[rbp + mc_writeobj.writestringtable.p]
    mov       [r10],	eax
    add       qword [mc_writeobj.dataptr],	4
    mov       rax,	1
    mov       [rbp + mc_writeobj.writestringtable.i],	rax
    mov       rax,	[mc_writeobj.nstrings]
    cmp       rax,	1
    jl        L4351
L4349:
    lea       rax,	[mc_writeobj.stringlengths]
    mov       r10,	[rbp + mc_writeobj.writestringtable.i]
    mov       r11,	[rax + r10*8-8]
    add       r11,	1
    mov       [rbp + mc_writeobj.writestringtable.n],	r11
    lea       rax,	[mc_writeobj.stringtable]
    mov       r10,	[rbp + mc_writeobj.writestringtable.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	r11
    mov       r8,	[rbp + mc_writeobj.writestringtable.n]
    call      memcpy
    mov       rax,	[rbp + mc_writeobj.writestringtable.n]
    add       [mc_writeobj.dataptr],	rax
L4350:
    mov       rax,	[rbp + mc_writeobj.writestringtable.i]
    inc       rax
    mov       [rbp + mc_writeobj.writestringtable.i],	rax
    cmp       rax,	[mc_writeobj.nstrings]
    jle       L4349
L4351:
L4348:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc makesymbol
mc_writeobj.makesymbol:
;>>
    %define mc_writeobj.makesymbol.name 16
    %define mc_writeobj.makesymbol.value 24
    %define mc_writeobj.makesymbol.sectionno 32
    %define mc_writeobj.makesymbol.symtype 40
    %define mc_writeobj.makesymbol.storage 48
    %define mc_writeobj.makesymbol.naux 56
    %define mc_writeobj.makesymbol.length -8
    %define mc_writeobj.makesymbol.namelen -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    mov       rcx,	[rbp + mc_writeobj.makesymbol.name]
    call      strlen
    mov       [rbp + mc_writeobj.makesymbol.namelen],	rax
    mov       rax,	[rbp + mc_writeobj.makesymbol.namelen]
    cmp       rax,	8
    jge       L4354
    lea       rax,	[mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeobj.makesymbol.name]
    call      strcpy
    jmp       L4353
L4354:
    mov       rax,	[rbp + mc_writeobj.makesymbol.namelen]
    cmp       rax,	8
    jnz       L4355
    lea       rax,	[mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeobj.makesymbol.name]
    mov       r8,	[rbp + mc_writeobj.makesymbol.namelen]
    call      memcpy
    jmp       L4353
L4355:
    xor       eax,	eax
    mov       [mc_writeobj.makesymbol.r],	eax
    mov       rcx,	[rbp + mc_writeobj.makesymbol.name]
    mov       rdx,	[rbp + mc_writeobj.makesymbol.namelen]
    call      mc_writeobj.addstringentry
    mov       [mc_writeobj.makesymbol.r+4],	eax
L4353:
    mov       eax,	[rbp + mc_writeobj.makesymbol.value]
    mov       [mc_writeobj.makesymbol.r+8],	eax
    mov       ax,	[rbp + mc_writeobj.makesymbol.sectionno]
    mov       [mc_writeobj.makesymbol.r+12],	ax
    mov       ax,	[rbp + mc_writeobj.makesymbol.symtype]
    mov       [mc_writeobj.makesymbol.r+14],	ax
    mov       al,	[rbp + mc_writeobj.makesymbol.storage]
    mov       [mc_writeobj.makesymbol.r+16],	al
    mov       al,	[rbp + mc_writeobj.makesymbol.naux]
    mov       [mc_writeobj.makesymbol.r+17],	al
    lea       rax,	[mc_writeobj.makesymbol.r]
L4352:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc addsymbol
mc_writeobj.addsymbol:
;>>
    %define mc_writeobj.addsymbol.r 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_writeobj.nsymbols]
    cmp       rax,	13000
    jl        L4358
    lea       rcx,	[rel L6058]
    call      mc_libmcl.axerror
L4358:
L4357:
    inc       qword [mc_writeobj.nsymbols]
    mov       rax,	[mc_writeobj.nsymbols]
    lea       r10,	[mc_writeobj.symboltable]
    shl       rax,	1
    lea       rax,	[rax + rax*8]
    lea       r10,	[r10 + rax]
    mov       rcx,	r10
    mov       rdx,	[rbp + mc_writeobj.addsymbol.r]
    mov       r8,	18
    call      memcpy
L4356:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc initsymboltable
mc_writeobj.initsymboltable:
;>>
    %define mc_writeobj.initsymboltable.filename 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    mov       [mc_writeobj.nsymbols],	rax
    push      1
    push      103
    lea       rcx,	[rel L6059]
    xor       edx,	edx
    mov       r8,	-2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[rbp + mc_writeobj.initsymboltable.filename]
    call      mc_writeobj.strtoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[rel L6060]
    xor       edx,	edx
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    xor       ecx,	ecx
    xor       edx,	edx
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[rel L6061]
    xor       edx,	edx
    mov       r8,	2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	[mc_decls.ss_nidatarelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[rel L6062]
    xor       edx,	edx
    mov       r8,	3
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[mc_decls.ss_ncoderelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
L4359:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc strtoaux
mc_writeobj.strtoaux:
;>>
    %define mc_writeobj.strtoaux.s 16
    %define mc_writeobj.strtoaux.p -8
    %define mc_writeobj.strtoaux.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[mc_writeobj.strtoaux.r]
    mov       [rbp + mc_writeobj.strtoaux.p],	rax
    mov       rcx,	[rbp + mc_writeobj.strtoaux.p]
    xor       edx,	edx
    mov       r8,	18
    call      memset
    xor       eax,	eax
    mov       [rbp + mc_writeobj.strtoaux.n],	rax
    jmp       L4362
L4361:
    mov       rax,	[rbp + mc_writeobj.strtoaux.s]
    inc       qword [rbp + mc_writeobj.strtoaux.s]
    movzx     r10,	byte [rax]
    mov       rax,	[rbp + mc_writeobj.strtoaux.p]
    inc       qword [rbp + mc_writeobj.strtoaux.p]
    mov       [rax],	r10b
    inc       qword [rbp + mc_writeobj.strtoaux.n]
L4362:
    mov       rax,	[rbp + mc_writeobj.strtoaux.s]
    movzx     r10,	byte [rax]
    cmp       r10,	0
    jz        L4364
    mov       rax,	[rbp + mc_writeobj.strtoaux.n]
    cmp       rax,	18
    jl        L4361
L4364:
L4363:
    lea       rax,	[mc_writeobj.strtoaux.r]
L4360:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc sectiontoaux
mc_writeobj.sectiontoaux:
;>>
    %define mc_writeobj.sectiontoaux.data 16
    %define mc_writeobj.sectiontoaux.nrelocs 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[mc_writeobj.sectiontoaux.r]
    xor       r10,	r10
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10w
    mov       rax,	[rbp + mc_writeobj.sectiontoaux.data]
    cmp       rax,	0
    jnz       L4367
    mov       eax,	[mc_decls.ss_zdatalen]
    mov       [mc_writeobj.sectiontoaux.r],	eax
    jmp       L4366
L4367:
    mov       rcx,	[rbp + mc_writeobj.sectiontoaux.data]
    call      mc_genss.bufferlength
    mov       [mc_writeobj.sectiontoaux.r],	eax
L4366:
    mov       ax,	[rbp + mc_writeobj.sectiontoaux.nrelocs]
    mov       [mc_writeobj.sectiontoaux.r+4],	ax
    lea       rax,	[mc_writeobj.sectiontoaux.r]
L4365:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc addstringentry
mc_writeobj.addstringentry:
;>>
    %define mc_writeobj.addstringentry.s 16
    %define mc_writeobj.addstringentry.length 24
    %define mc_writeobj.addstringentry.offset -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[mc_writeobj.nextstringoffset]
    mov       [rbp + mc_writeobj.addstringentry.offset],	rax
    mov       rax,	[mc_writeobj.nstrings]
    cmp       rax,	5000
    jle       L4370
    lea       rcx,	[rel L6063]
    call      mc_libmcl.axerror
L4370:
L4369:
    inc       qword [mc_writeobj.nstrings]
    mov       rax,	[mc_writeobj.nstrings]
    mov       r10,	[rbp + mc_writeobj.addstringentry.s]
    lea       r11,	[mc_writeobj.stringtable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rbp + mc_writeobj.addstringentry.length]
    lea       r10,	[mc_writeobj.stringlengths]
    mov       r11,	[mc_writeobj.nstrings]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rbp + mc_writeobj.addstringentry.length]
    add       rax,	1
    add       [mc_writeobj.nextstringoffset],	rax
    mov       rax,	[rbp + mc_writeobj.addstringentry.offset]
L4368:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc convertsymboltable
mc_writeobj.convertsymboltable:
;>>
    %define mc_writeobj.convertsymboltable.s -8
    %define mc_writeobj.convertsymboltable.name -16
    %define mc_writeobj.convertsymboltable.i -24
    %define mc_writeobj.convertsymboltable.sect -32
    %define mc_writeobj.convertsymboltable.scope -40
    %define mc_writeobj.convertsymboltable.$T3 -48
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rax,	[mc_writeobj.nsymbols]
    sub       rax,	1
    mov       [mc_writeobj.stoffset],	rax
    xor       eax,	eax
    mov       [mc_writeobj.nstrings],	rax
    mov       rax,	4
    mov       [mc_writeobj.nextstringoffset],	rax
    mov       rax,	1
    mov       [rbp + mc_writeobj.convertsymboltable.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4374
L4372:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mc_writeobj.convertsymboltable.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mc_writeobj.convertsymboltable.s],	r11
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.s]
    mov       r10,	[rax]
    mov       [rbp + mc_writeobj.convertsymboltable.name],	r10
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.s]
    movzx     r10,	byte [rax+70]
    cmp       r10,	3
    jz        L4376
    cmp       r10,	2
    jz        L4377
    cmp       r10,	1
    jz        L4378
    jmp       L4379
L4376:
    mov       rax,	1
    mov       [rbp + mc_writeobj.convertsymboltable.sect],	rax
    jmp       L4375
L4377:
    mov       rax,	2
    mov       [rbp + mc_writeobj.convertsymboltable.sect],	rax
    jmp       L4375
L4378:
    mov       rax,	3
    mov       [rbp + mc_writeobj.convertsymboltable.sect],	rax
    jmp       L4375
L4379:
    xor       eax,	eax
    mov       [rbp + mc_writeobj.convertsymboltable.sect],	rax
L4375:
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.s]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4381
    xor       eax,	eax
    mov       [rbp + mc_writeobj.convertsymboltable.sect],	rax
L4381:
L4380:
    xor       eax,	eax
    mov       [rbp + mc_writeobj.convertsymboltable.scope],	rax
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.s]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jnz       L4384
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.s]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L4383
L4384:
    mov       rax,	2
    mov       [rbp + mc_writeobj.convertsymboltable.scope],	rax
    jmp       L4382
L4383:
    mov       rax,	3
    mov       [rbp + mc_writeobj.convertsymboltable.scope],	rax
L4382:
    push      0
    push      qword [rbp + mc_writeobj.convertsymboltable.scope]
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.s]
    movsxd    r10,	dword [rax+52]
    mov       [rbp + mc_writeobj.convertsymboltable.$T3],	r10
    mov       rcx,	[rbp + mc_writeobj.convertsymboltable.s]
    sub       rsp,	32
    call      mc_writeobj.getqualname
    add       rsp,	32
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeobj.convertsymboltable.$T3]
    mov       r8,	[rbp + mc_writeobj.convertsymboltable.sect]
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
L4373:
    mov       rax,	[rbp + mc_writeobj.convertsymboltable.i]
    inc       rax
    mov       [rbp + mc_writeobj.convertsymboltable.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4372
L4374:
L4371:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc getqualname
mc_writeobj.getqualname:
;>>
    %define mc_writeobj.getqualname.d 16
    %define mc_writeobj.getqualname.chain -128
    %define mc_writeobj.getqualname.n -136
    %define mc_writeobj.getqualname.e -144
    %define mc_writeobj.getqualname.i -152
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mc_writeobj.getqualname.n],	rax
    mov       rax,	[rbp + mc_writeobj.getqualname.d]
    mov       [rbp + mc_writeobj.getqualname.e],	rax
    mov       rax,	[rbp + mc_writeobj.getqualname.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jnz       L4388
    mov       rax,	[rbp + mc_writeobj.getqualname.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L4387
    mov       rax,	[rbp + mc_writeobj.getqualname.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L6064]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4387
L4388:
    mov       rax,	[rbp + mc_writeobj.getqualname.d]
    mov       r10,	[rax]
    mov       rax,	r10
    jmp       L4385
L4387:
L4386:
L4389:
    inc       qword [rbp + mc_writeobj.getqualname.n]
    mov       rax,	[rbp + mc_writeobj.getqualname.n]
    mov       r10,	[rbp + mc_writeobj.getqualname.e]
    mov       [rbp + rax*8 + mc_writeobj.getqualname.chain-8],	r10
    mov       rax,	[rbp + mc_writeobj.getqualname.e]
    mov       r10,	[rax+32]
    mov       [rbp + mc_writeobj.getqualname.e],	r10
L4390:
    mov       rax,	[rbp + mc_writeobj.getqualname.e]
    cmp       rax,	0
    jnz       L4389
L4391:
    mov       rax,	[rbp + mc_writeobj.getqualname.n]
    mov       r10,	[rbp + rax*8 + mc_writeobj.getqualname.chain-8]
    mov       rax,	[r10]
    lea       rcx,	[mc_writeobj.getqualname.str]
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbp + mc_writeobj.getqualname.n]
    sub       rax,	1
    mov       [rbp + mc_writeobj.getqualname.i],	rax
    mov       rax,	[rbp + mc_writeobj.getqualname.i]
    cmp       rax,	1
    jl        L4394
L4392:
    lea       rcx,	[mc_writeobj.getqualname.str]
    lea       rdx,	[rel L6065]
    call      strcat
    mov       rax,	[rbp + mc_writeobj.getqualname.i]
    mov       r10,	[rbp + rax*8 + mc_writeobj.getqualname.chain-8]
    mov       rax,	[r10]
    lea       rcx,	[mc_writeobj.getqualname.str]
    mov       rdx,	rax
    call      strcat
L4393:
    mov       rax,	[rbp + mc_writeobj.getqualname.i]
    dec       rax
    mov       [rbp + mc_writeobj.getqualname.i],	rax
    cmp       rax,	1
    jge       L4392
L4394:
    lea       rcx,	[mc_writeobj.getqualname.str]
    call      mlib.pcm_copyheapstring
L4385:
;---------------
    add       rsp,	192
    pop       rbp
    ret       
;End 
;Proc writememlib
mx_run.writememlib:
;>>
    %define mx_run.writememlib.filename 16
    %define mx_run.writememlib.plib -8
    %define mx_run.writememlib.n -16
    %define mx_run.writememlib.k -24
    %define mx_run.writememlib.lib -240
    %define mx_run.writememlib.ndlls -248
    %define mx_run.writememlib.nlibs -256
    %define mx_run.writememlib.i -264
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	304
    mov       [rbp+16],	rcx
;---------------
    lea       rax,	[rbp + mx_run.writememlib.lib]
    xor       r10,	r10
    mov       r11,	27
L6066:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L6066
    mov       rcx,	[mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_run.roundsegment
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_run.roundsegment
    lea       rax,	[rel L6067]
    mov       [rbp + mx_run.writememlib.lib],	rax
    mov       rax,	[rbp + mx_run.writememlib.filename]
    mov       [rbp + mx_run.writememlib.lib+184],	rax
    mov       rcx,	[rbp + mx_run.writememlib.filename]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_run.writememlib.lib+192],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writememlib.lib+208],	rax
    call      mx_run.countsymbols
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.writerelocs
    mov       rax,	[mc_decls.ss_zdatalen]
    mov       [rbp + mx_run.writememlib.lib+24],	rax
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+8],	rax
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+16],	rax
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+72],	rax
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+80],	rax
    xor       eax,	eax
    mov       [rbp + mx_run.writememlib.ndlls],	rax
    xor       eax,	eax
    mov       [rbp + mx_run.writememlib.nlibs],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writememlib.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4398
L4396:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mx_run.writememlib.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11]
    cmp       rax,	36
    jz        L4400
    inc       qword [rbp + mx_run.writememlib.ndlls]
L4400:
L4399:
L4397:
    mov       rax,	[rbp + mx_run.writememlib.i]
    inc       rax
    mov       [rbp + mx_run.writememlib.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L4396
L4398:
    mov       rax,	[rbp + mx_run.writememlib.ndlls]
    mov       [rbp + mx_run.writememlib.lib+40],	rax
    mov       rax,	[rbp + mx_run.writememlib.nlibs]
    mov       [rbp + mx_run.writememlib.lib+48],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_run.writememlib.ndlls]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+96],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_run.writememlib.nlibs]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+104],	rax
    xor       eax,	eax
    mov       [rbp + mx_run.writememlib.k],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writememlib.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4403
L4401:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mx_run.writememlib.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11]
    cmp       rax,	36
    jz        L4405
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mx_run.writememlib.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + mx_run.writememlib.lib+96]
    inc       qword [rbp + mx_run.writememlib.k]
    mov       r10,	[rbp + mx_run.writememlib.k]
    mov       [rax + r10*8-8],	r11
L4405:
L4404:
L4402:
    mov       rax,	[rbp + mx_run.writememlib.i]
    inc       rax
    mov       [rbp + mx_run.writememlib.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L4401
L4403:
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.addsymbols
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       [rbp + mx_run.writememlib.plib],	rax
    mov       rcx,	[rbp + mx_run.writememlib.plib]
    lea       rdx,	[rbp + mx_run.writememlib.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	[rbp + mx_run.writememlib.plib]
L4395:
;---------------
    add       rsp,	304
    pop       rbp
    ret       
;End 
;Proc roundsegment
mx_run.roundsegment:
;>>
    %define mx_run.roundsegment.p 16
    %define mx_run.roundsegment.align 24
    %define mx_run.roundsegment.value 32
    %define mx_run.roundsegment.length -8
    %define mx_run.roundsegment.newlength -16
    %define mx_run.roundsegment.av_1 -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mx_run.roundsegment.p]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.roundsegment.length],	rax
    mov       rcx,	[rbp + mx_run.roundsegment.length]
    mov       rdx,	[rbp + mx_run.roundsegment.align]
    call      mlib.roundtoblock
    mov       [rbp + mx_run.roundsegment.newlength],	rax
    mov       rcx,	[rbp + mx_run.roundsegment.p]
    mov       rdx,	[rbp + mx_run.roundsegment.align]
    call      mc_genss.buffercheck
    mov       rax,	[rbp + mx_run.roundsegment.newlength]
    sub       rax,	[rbp + mx_run.roundsegment.length]
    mov       [rbp + mx_run.roundsegment.av_1],	rax
    mov       rax,	[rbp + mx_run.roundsegment.av_1]
    cmp       rax,	0
    jle       L4409
L4407:
    mov       rax,	[rbp + mx_run.roundsegment.p]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mx_run.roundsegment.value]
    mov       [r10],	al
L4408:
    dec       qword [rbp + mx_run.roundsegment.av_1]
    jnz       L4407
L4409:
L4406:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc writerelocs
mx_run.writerelocs:
;>>
    %define mx_run.writerelocs.lib 16
    %define mx_run.writerelocs.oldr -8
    %define mx_run.writerelocs.newr -16
    %define mx_run.writerelocs.n -24
    %define mx_run.writerelocs.k -32
    %define mx_run.writerelocs.d -40
    %define mx_run.writerelocs.baseptr64 -48
    %define mx_run.writerelocs.i -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mc_decls.ss_nidatarelocs]
    add       rax,	[mc_decls.ss_ncoderelocs]
    mov       r10,	[rbp + mx_run.writerelocs.lib]
    mov       [r10+32],	rax
    mov       rax,	[rbp + mx_run.writerelocs.lib]
    mov       r10,	[rax+32]
    imul      r10,	8
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_run.writerelocs.lib]
    mov       [r10+88],	rax
    xor       eax,	eax
    mov       [rbp + mx_run.writerelocs.k],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writerelocs.i],	rax
L4411:
    mov       rax,	[rbp + mx_run.writerelocs.i]
    cmp       rax,	1
    jnz       L4415
    mov       rax,	[mc_decls.ss_idatarelocs]
    jmp       L4414
L4415:
    mov       rax,	[mc_decls.ss_coderelocs]
L4414:
    mov       [rbp + mx_run.writerelocs.oldr],	rax
    jmp       L4419
L4416:
    lea       rax,	[rbp + mx_run.writerelocs.newr]
    xor       r10,	r10
    mov       [rax],	r10
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    mov       r10,	[rax+16]
    mov       [rbp + mx_run.writerelocs.newr],	r10d
    mov       rax,	[rbp + mx_run.writerelocs.i]
    cmp       rax,	1
    jnz       L4421
    mov       rax,	2
    jmp       L4420
L4421:
    mov       rax,	1
L4420:
    mov       [rbp + mx_run.writerelocs.newr+6],	al
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    mov       r10,	[rax+24]
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_run.writerelocs.d],	r11
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    mov       r10,	[rax+8]
    cmp       r10,	4
    jz        L4423
    cmp       r10,	2
    jz        L4424
    cmp       r10,	1
    jz        L4424
    jmp       L4425
L4423:
    mov       rax,	[rbp + mx_run.writerelocs.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4427
    mov       rax,	[rbp + mx_run.writerelocs.d]
    movsx     r10,	word [rax+102]
    mov       [rbp + mx_run.writerelocs.newr+4],	r10w
    mov       al,	5
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4426
L4427:
    lea       rcx,	[rel L6068]
    call      mc_libmcl.axerror
L4426:
    jmp       L4422
L4424:
    mov       rax,	[rbp + mx_run.writerelocs.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4429
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4431
    mov       rax,	3
    jmp       L4430
L4431:
    mov       rax,	4
L4430:
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    mov       rax,	[rbp + mx_run.writerelocs.d]
    movsx     r10,	word [rax+102]
    mov       [rbp + mx_run.writerelocs.newr+4],	r10w
    jmp       L4428
L4429:
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4433
    mov       al,	1
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4432
L4433:
    mov       al,	2
    mov       [rbp + mx_run.writerelocs.newr+7],	al
L4432:
    mov       rax,	[rbp + mx_run.writerelocs.d]
    movzx     r10,	byte [rax+70]
    mov       [rbp + mx_run.writerelocs.newr+4],	r10b
L4428:
    jmp       L4422
L4425:
    lea       rcx,	[rel L6069]
    call      mc_libmcl.axerror
L4422:
    mov       rax,	[rbp + mx_run.writerelocs.lib]
    mov       r10,	[rax+88]
    inc       qword [rbp + mx_run.writerelocs.k]
    mov       rax,	[rbp + mx_run.writerelocs.k]
    mov       r11,	[rbp + mx_run.writerelocs.newr]
    mov       [r10 + rax*8-8],	r11
L4417:
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    mov       r10,	[rax]
    mov       [rbp + mx_run.writerelocs.oldr],	r10
L4419:
    mov       rax,	[rbp + mx_run.writerelocs.oldr]
    test      rax,	rax
    jnz       L4416
L4418:
L4412:
    mov       rax,	[rbp + mx_run.writerelocs.i]
    inc       rax
    mov       [rbp + mx_run.writerelocs.i],	rax
    cmp       rax,	2
    jle       L4411
L4413:
L4410:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc addsymbols
mx_run.addsymbols:
;>>
    %define mx_run.addsymbols.lib 16
    %define mx_run.addsymbols.d -8
    %define mx_run.addsymbols.stentry -16
    %define mx_run.addsymbols.epoffset -24
    %define mx_run.addsymbols.n -32
    %define mx_run.addsymbols.k -40
    %define mx_run.addsymbols.name -48
    %define mx_run.addsymbols.i -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mx_run.addsymbols.stentry],	rax
    mov       rax,	-1
    mov       [rbp + mx_run.addsymbols.epoffset],	rax
    mov       rax,	[mx_decls.nsymimports]
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+56],	rax
    mov       rax,	[mx_decls.nsymexports]
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+64],	rax
    mov       rax,	[mx_decls.nsymimports]
    imul      rax,	8
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+112],	rax
    mov       rax,	[mx_decls.nsymexports]
    imul      rax,	8
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+120],	rax
    mov       rcx,	[mx_decls.nsymexports]
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+128],	rax
    mov       rax,	[mx_decls.nsymexports]
    imul      rax,	8
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+136],	rax
    xor       eax,	eax
    mov       [rbp + mx_run.addsymbols.k],	rax
    mov       rax,	1
    mov       [rbp + mx_run.addsymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4437
L4435:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_run.addsymbols.i]
    mov       r11,	[rax + r10*8-8]
    movsx     rax,	word [r11+102]
    test      rax,	rax
    jz        L4439
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_run.addsymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_run.addsymbols.d],	r11
    mov       rax,	[rbp + mx_run.addsymbols.d]
    mov       r10,	[rax]
    mov       rax,	[rbp + mx_run.addsymbols.lib]
    mov       r11,	[rax+112]
    inc       qword [rbp + mx_run.addsymbols.k]
    mov       rax,	[rbp + mx_run.addsymbols.k]
    mov       [r11 + rax*8-8],	r10
L4439:
L4438:
L4436:
    mov       rax,	[rbp + mx_run.addsymbols.i]
    inc       rax
    mov       [rbp + mx_run.addsymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4435
L4437:
    xor       eax,	eax
    mov       [rbp + mx_run.addsymbols.k],	rax
    mov       rax,	1
    mov       [rbp + mx_run.addsymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4442
L4440:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_run.addsymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_run.addsymbols.d],	r11
    mov       rax,	[rbp + mx_run.addsymbols.d]
    movsx     r10,	word [rax+104]
    test      r10,	r10
    jz        L4444
    mov       rax,	[rbp + mx_run.addsymbols.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L6070]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4446
    mov       rax,	[rbp + mx_run.addsymbols.d]
    mov       [rbp + mx_run.addsymbols.stentry],	rax
L4446:
L4445:
    mov       rax,	[rbp + mx_run.addsymbols.d]
    mov       r10,	[rax]
    mov       rax,	[rbp + mx_run.addsymbols.lib]
    mov       r11,	[rax+120]
    inc       qword [rbp + mx_run.addsymbols.k]
    mov       rax,	[rbp + mx_run.addsymbols.k]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rbp + mx_run.addsymbols.d]
    movzx     r10,	byte [rax+70]
    mov       rax,	[rbp + mx_run.addsymbols.lib]
    mov       r11,	[rax+128]
    mov       rax,	[rbp + mx_run.addsymbols.k]
    mov       [r11 + rax-1],	r10b
    mov       rax,	[rbp + mx_run.addsymbols.d]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mx_run.addsymbols.lib]
    mov       r11,	[rax+136]
    mov       rax,	[rbp + mx_run.addsymbols.k]
    mov       [r11 + rax*8-8],	r10
L4444:
L4443:
L4441:
    mov       rax,	[rbp + mx_run.addsymbols.i]
    inc       rax
    mov       [rbp + mx_run.addsymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4440
L4442:
    mov       rax,	[rbp + mx_run.addsymbols.stentry]
    test      rax,	rax
    jz        L4448
    mov       rax,	[rbp + mx_run.addsymbols.stentry]
    movsxd    r10,	dword [rax+52]
    mov       rax,	[rbp + mx_run.addsymbols.lib]
    mov       [rax+144],	r10
    jmp       L4447
L4448:
    mov       rax,	-1
    mov       r10,	[rbp + mx_run.addsymbols.lib]
    mov       [r10+144],	rax
L4447:
L4434:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc countsymbols
mx_run.countsymbols:
;>>
    %define mx_run.countsymbols.d -8
    %define mx_run.countsymbols.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
;---------------
    mov       rax,	1
    mov       [rbp + mx_run.countsymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4452
L4450:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_run.countsymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_run.countsymbols.d],	r11
    mov       rax,	[rbp + mx_run.countsymbols.d]
    movzx     r10,	byte [rax+57]
    test      r10,	r10
    jz        L4454
    inc       qword [mx_decls.nsymexports]
    mov       rax,	[mx_decls.nsymexports]
    mov       r10,	[rbp + mx_run.countsymbols.d]
    mov       [r10+104],	ax
L4454:
L4453:
    mov       rax,	[rbp + mx_run.countsymbols.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4456
    inc       qword [mx_decls.nsymimports]
    mov       rax,	[mx_decls.nsymimports]
    mov       r10,	[rbp + mx_run.countsymbols.d]
    mov       [r10+102],	ax
L4456:
L4455:
L4451:
    mov       rax,	[rbp + mx_run.countsymbols.i]
    inc       rax
    mov       [rbp + mx_run.countsymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4450
L4452:
L4449:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc runlibfile
mx_run.runlibfile:
;>>
    %define mx_run.runlibfile.filename 16
    %define mx_run.runlibfile.cmdskip 24
    %define mx_run.runlibfile.plib -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mx_run.runlibfile.filename]
    call      mx_run.writememlib
    mov       [rbp + mx_run.runlibfile.plib],	rax
    mov       rcx,	[rbp + mx_run.runlibfile.plib]
    call      mx_lib.loadmemmcu
    mov       rcx,	[rbp + mx_run.runlibfile.plib]
    call      mx_lib.fixuplib
    mov       rcx,	[rbp + mx_run.runlibfile.plib]
    mov       rdx,	[rbp + mx_run.runlibfile.cmdskip]
    call      mx_lib.runprogram
L4457:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc readlibfile
mx_lib.readlibfile:
;>>
    %define mx_lib.readlibfile.filespec 16
    %define mx_lib.readlibfile.p 24
    %define mx_lib.readlibfile.plib -8
    %define mx_lib.readlibfile.lib -224
    %define mx_lib.readlibfile.sig -232
    %define mx_lib.readlibfile.dir -240
    %define mx_lib.readlibfile.n -248
    %define mx_lib.readlibfile.tablesize -256
    %define mx_lib.readlibfile.q -264
    %define mx_lib.readlibfile.i -272
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	304
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    lea       rax,	[rbp + mx_lib.readlibfile.lib]
    xor       r10,	r10
    mov       r11,	27
L6071:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L6071
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.sig],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.sig]
    cmp       rax,	441992013
    jz        L4460
    call      msys.m$print_startcon
    lea       rcx,	[rel L6072]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4460:
L4459:
    mov       rcx,	[rbp + mx_lib.readlibfile.filespec]
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+184],	rax
    mov       rcx,	[rbp + mx_lib.readlibfile.filespec]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+192],	rax
L4461:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       [rbp + mx_lib.readlibfile.dir],	rax
    cmp       rax,	14
    jae       L4464
    lea       r10,	[rel L4463]
    jmp       [r10 + rax*8]
    segment .data
L4463:
    dq  L4496
    dq  L4465
    dq  L4468
    dq  L4467
    dq  L4466
    dq  L4493
    dq  L4469
    dq  L4473
    dq  L4477
    dq  L4481
    dq  L4485
    dq  L4489
    dq  L4494
    dq  L4495
    segment .text
L4465:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       [rbp + mx_lib.readlibfile.lib],	rax
    jmp       L4461
L4466:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+24],	rax
    jmp       L4461
L4467:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+16],	rax
    mov       rcx,	[rbp + mx_lib.readlibfile.n]
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+80],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+80]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	[rbp + mx_lib.readlibfile.n]
    call      memcpy
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4461
L4468:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+8],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.p]
    mov       [rbp + mx_lib.readlibfile.lib+72],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4461
L4469:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+40],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_lib.readlibfile.n]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+96],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.readlibfile.i],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    cmp       rax,	1
    jl        L4472
L4470:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+96]
    mov       r11,	[rbp + mx_lib.readlibfile.i]
    mov       [r10 + r11*8-8],	rax
L4471:
    mov       rax,	[rbp + mx_lib.readlibfile.i]
    inc       rax
    mov       [rbp + mx_lib.readlibfile.i],	rax
    cmp       rax,	[rbp + mx_lib.readlibfile.n]
    jle       L4470
L4472:
    jmp       L4461
L4473:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+48],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_lib.readlibfile.n]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+104],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.readlibfile.i],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    cmp       rax,	1
    jl        L4476
L4474:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+104]
    mov       r11,	[rbp + mx_lib.readlibfile.i]
    mov       [r10 + r11*8-8],	rax
L4475:
    mov       rax,	[rbp + mx_lib.readlibfile.i]
    inc       rax
    mov       [rbp + mx_lib.readlibfile.i],	rax
    cmp       rax,	[rbp + mx_lib.readlibfile.n]
    jle       L4474
L4476:
    jmp       L4461
L4477:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+56],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_lib.readlibfile.n]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+112],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.readlibfile.i],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    cmp       rax,	1
    jl        L4480
L4478:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+112]
    mov       r11,	[rbp + mx_lib.readlibfile.i]
    mov       [r10 + r11*8-8],	rax
L4479:
    mov       rax,	[rbp + mx_lib.readlibfile.i]
    inc       rax
    mov       [rbp + mx_lib.readlibfile.i],	rax
    cmp       rax,	[rbp + mx_lib.readlibfile.n]
    jle       L4478
L4480:
    jmp       L4461
L4481:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+64],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_lib.readlibfile.n]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+120],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.readlibfile.i],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    cmp       rax,	1
    jl        L4484
L4482:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+120]
    mov       r11,	[rbp + mx_lib.readlibfile.i]
    mov       [r10 + r11*8-8],	rax
L4483:
    mov       rax,	[rbp + mx_lib.readlibfile.i]
    inc       rax
    mov       [rbp + mx_lib.readlibfile.i],	rax
    cmp       rax,	[rbp + mx_lib.readlibfile.n]
    jle       L4482
L4484:
    jmp       L4461
L4485:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       rcx,	[rbp + mx_lib.readlibfile.n]
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+128],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.readlibfile.i],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    cmp       rax,	1
    jl        L4488
L4486:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       r10,	[rbp + mx_lib.readlibfile.lib+128]
    mov       r11,	[rbp + mx_lib.readlibfile.i]
    mov       [r10 + r11-1],	al
L4487:
    mov       rax,	[rbp + mx_lib.readlibfile.i]
    inc       rax
    mov       [rbp + mx_lib.readlibfile.i],	rax
    cmp       rax,	[rbp + mx_lib.readlibfile.n]
    jle       L4486
L4488:
    jmp       L4461
L4489:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       rax,	8
    imul      rax,	[rbp + mx_lib.readlibfile.n]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+136],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.readlibfile.i],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    cmp       rax,	1
    jl        L4492
L4490:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r10,	[rbp + mx_lib.readlibfile.lib+136]
    mov       r11,	[rbp + mx_lib.readlibfile.i]
    mov       [r10 + r11*8-8],	rax
L4491:
    mov       rax,	[rbp + mx_lib.readlibfile.i]
    inc       rax
    mov       [rbp + mx_lib.readlibfile.i],	rax
    cmp       rax,	[rbp + mx_lib.readlibfile.n]
    jle       L4490
L4492:
    jmp       L4461
L4493:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       [rbp + mx_lib.readlibfile.lib+32],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+32]
    imul      rax,	8
    mov       [rbp + mx_lib.readlibfile.n],	rax
    mov       rcx,	[rbp + mx_lib.readlibfile.n]
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+88],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+88]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	[rbp + mx_lib.readlibfile.n]
    call      memcpy
    mov       rax,	[rbp + mx_lib.readlibfile.n]
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4461
L4494:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+144],	rax
    jmp       L4461
L4495:
    jmp       L4462
L4496:
    jmp       L4461
L4464:
    call      msys.m$print_startcon
    lea       rcx,	[rel L6073]
    call      msys.m$print_str_nf
    lea       rax,	[mx_decls.mcxdirnames]
    mov       r10,	[rbp + mx_lib.readlibfile.dir]
    mov       r11,	[rax + r10*8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
    jmp       L4461
L4462:
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       [rbp + mx_lib.readlibfile.plib],	rax
    mov       rcx,	[rbp + mx_lib.readlibfile.plib]
    lea       rdx,	[rbp + mx_lib.readlibfile.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	[rbp + mx_lib.readlibfile.plib]
L4458:
;---------------
    add       rsp,	304
    pop       rbp
    ret       
;End 
;Proc readbyte
mx_lib.readbyte:
;>>
    %define mx_lib.readbyte.p 16
    push      rbp
    mov       rbp,	rsp
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.readbyte.p]
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     rax,	byte [r10]
L4497:
;---------------
    pop       rbp
    ret       
;End 
;Proc readu32
mx_lib.readu32:
;>>
    %define mx_lib.readu32.p 16
    %define mx_lib.readu32.x -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.readu32.p]
    mov       r10,	[rax]
    mov       eax,	[r10]
    mov       [rbp + mx_lib.readu32.x],	rax
    mov       rax,	[rbp + mx_lib.readu32.p]
    add       qword [rax],	4
    mov       rax,	[rbp + mx_lib.readu32.x]
L4498:
;---------------
    add       rsp,	16
    pop       rbp
    ret       
;End 
;Proc readstring
mx_lib.readstring:
;>>
    %define mx_lib.readstring.p 16
    %define mx_lib.readstring.s -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.readstring.p]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readstring.s],	rax
L4500:
L4501:
    mov       rax,	[rbp + mx_lib.readstring.p]
    inc       qword [rax]
    mov       rax,	[rax]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jnz       L4500
L4502:
    mov       rax,	[rbp + mx_lib.readstring.p]
    inc       qword [rax]
    mov       rax,	[rbp + mx_lib.readstring.s]
L4499:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc alloclibdata
mx_lib.alloclibdata:
;>>
    %define mx_lib.alloclibdata.lib 16
    %define mx_lib.alloclibdata.tablesize -8
    %define mx_lib.alloclibdata.n -16
    %define mx_lib.alloclibdata.p -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+24]
    mov       rcx,	r10
    call      mlib.pcm_allocz
    mov       r10,	[rbp + mx_lib.alloclibdata.lib]
    mov       [r10+152],	rax
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+56]
    imul      r10,	16
    mov       [rbp + mx_lib.alloclibdata.tablesize],	r10
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+8]
    mov       [rbp + mx_lib.alloclibdata.n],	r10
    mov       rax,	[rbp + mx_lib.alloclibdata.n]
    add       rax,	[rbp + mx_lib.alloclibdata.tablesize]
    mov       rcx,	rax
    call      mwindows.os_allocexecmem
    mov       [rbp + mx_lib.alloclibdata.p],	rax
    mov       rax,	[rbp + mx_lib.alloclibdata.p]
    cmp       rax,	0
    jnz       L4505
    lea       rcx,	[rel L6074]
    lea       rdx,	[rel L6075]
    call      mx_lib.error
L4505:
L4504:
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+72]
    mov       rcx,	[rbp + mx_lib.alloclibdata.p]
    mov       rdx,	r10
    mov       r8,	[rbp + mx_lib.alloclibdata.n]
    call      memcpy
    mov       rax,	[rbp + mx_lib.alloclibdata.p]
    mov       r10,	[rbp + mx_lib.alloclibdata.n]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	[rbp + mx_lib.alloclibdata.tablesize]
    call      memset
    mov       rax,	[rbp + mx_lib.alloclibdata.p]
    mov       r10,	[rbp + mx_lib.alloclibdata.lib]
    mov       [r10+72],	rax
    mov       rax,	[rbp + mx_lib.alloclibdata.tablesize]
    mov       r10,	[rbp + mx_lib.alloclibdata.lib]
    mov       [r10+160],	rax
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+64]
    mov       rax,	8
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_lib.alloclibdata.lib]
    mov       [r10+168],	rax
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+56]
    mov       rax,	2
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r10,	[rbp + mx_lib.alloclibdata.lib]
    mov       [r10+176],	rax
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+144]
    mov       rax,	4294967295
    cmp       r10,	rax
    jz        L4507
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r10,	[rax+72]
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       r11,	[rax+144]
    lea       r10,	[r10 + r11]
    mov       rax,	[rbp + mx_lib.alloclibdata.lib]
    mov       [rax+200],	r10
L4507:
L4506:
L4503:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc error
mx_lib.error:
;>>
    %define mx_lib.error.mess 16
    %define mx_lib.error.param 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mx_lib.error.param]
    movzx     r10,	byte [rax]
    test      r10,	r10
    jz        L4510
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mx_lib.error.mess]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mx_lib.error.param]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4509
L4510:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mx_lib.error.mess]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4509:
    call      msys.m$print_startcon
    lea       rcx,	[rel L6076]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4508:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc loadmemmcu
mx_lib.loadmemmcu:
;>>
    %define mx_lib.loadmemmcu.lib 16
    %define mx_lib.loadmemmcu.newlib -8
    %define mx_lib.loadmemmcu.name -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.loadmemmcu.lib]
    mov       r10,	[rax+192]
    mov       [rbp + mx_lib.loadmemmcu.name],	r10
    mov       rax,	[rbp + mx_lib.loadmemmcu.lib]
    mov       r10,	[rax+184]
    mov       rcx,	[rbp + mx_lib.loadmemmcu.name]
    mov       rdx,	r10
    call      mx_lib.checknew
    mov       rcx,	[rbp + mx_lib.loadmemmcu.name]
    call      mx_lib.mxaddlib
    mov       [rbp + mx_lib.loadmemmcu.newlib],	rax
    mov       rax,	[rbp + mx_lib.loadmemmcu.lib]
    lea       r10,	[mx_decls.libtable]
    mov       r11,	[rbp + mx_lib.loadmemmcu.newlib]
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	[rbp + mx_lib.loadmemmcu.lib]
    call      mx_lib.loadimports
L4511:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc checknew
mx_lib.checknew:
;>>
    %define mx_lib.checknew.name 16
    %define mx_lib.checknew.filename 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mx_lib.checknew.name]
    call      mx_lib.findlib
    test      rax,	rax
    jz        L4514
    lea       rcx,	[rel L6077]
    mov       rdx,	[rbp + mx_lib.checknew.filename]
    call      mx_lib.error
L4514:
L4513:
L4512:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc findlib
mx_lib.findlib:
;>>
    %define mx_lib.findlib.name 16
    %define mx_lib.findlib.n -8
    %define mx_lib.findlib.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.findlib.i],	rax
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4518
L4516:
    lea       rax,	[mx_decls.libnametable]
    mov       r10,	[rbp + mx_lib.findlib.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	[rbp + mx_lib.findlib.name]
    mov       rdx,	r11
    call      mlib.eqstring
    test      rax,	rax
    jz        L4520
    mov       rax,	[rbp + mx_lib.findlib.i]
    jmp       L4515
L4520:
L4519:
L4517:
    mov       rax,	[rbp + mx_lib.findlib.i]
    inc       rax
    mov       [rbp + mx_lib.findlib.i],	rax
    cmp       rax,	[mx_decls.nlibs]
    jle       L4516
L4518:
    xor       eax,	eax
L4515:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mxaddlib
mx_lib.mxaddlib:
;>>
    %define mx_lib.mxaddlib.name 16
    %define mx_lib.mxaddlib.n -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	20
    jl        L4523
    lea       rcx,	[rel L6078]
    lea       rdx,	[rel L6079]
    call      mx_lib.error
L4523:
L4522:
    inc       qword [mx_decls.nlibs]
    mov       rax,	[mx_decls.nlibs]
    mov       r10,	[rbp + mx_lib.mxaddlib.name]
    lea       r11,	[mx_decls.libnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[mx_decls.nlibs]
L4521:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc fixuplib
mx_lib.fixuplib:
;>>
    %define mx_lib.fixuplib.lib 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mx_lib.loaddlls
    call      mx_lib.checksymbols
    call      mx_lib.dorelocations
L4524:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc loaddlls
mx_lib.loaddlls:
;>>
    %define mx_lib.loaddlls.inst -8
    %define mx_lib.loaddlls.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.loaddlls.i],	rax
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4528
L4526:
    lea       rax,	[mx_decls.dllinsttable]
    mov       r10,	[rbp + mx_lib.loaddlls.i]
    mov       r11,	[rax + r10*8-8]
    test      r11,	r11
    jnz       L4530
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	[rbp + mx_lib.loaddlls.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      mwindows.os_getdllinst
    mov       [rbp + mx_lib.loaddlls.inst],	rax
    mov       rax,	[rbp + mx_lib.loaddlls.inst]
    cmp       rax,	0
    jnz       L4532
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	[rbp + mx_lib.loaddlls.i]
    mov       r11,	[rax + r10*8-8]
    lea       rcx,	[rel L6080]
    mov       rdx,	r11
    call      mx_lib.error
L4532:
L4531:
    mov       rax,	[rbp + mx_lib.loaddlls.inst]
    lea       r10,	[mx_decls.dllinsttable]
    mov       r11,	[rbp + mx_lib.loaddlls.i]
    mov       [r10 + r11*8-8],	rax
L4530:
L4529:
L4527:
    mov       rax,	[rbp + mx_lib.loaddlls.i]
    inc       rax
    mov       [rbp + mx_lib.loaddlls.i],	rax
    cmp       rax,	[mx_decls.ndlllibs]
    jle       L4526
L4528:
L4525:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc finddllsymbol
mx_lib.finddllsymbol:
;>>
    %define mx_lib.finddllsymbol.name 16
    %define mx_lib.finddllsymbol.dllindex 24
    %define mx_lib.finddllsymbol.p -8
    %define mx_lib.finddllsymbol.i -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    xor       eax,	eax
    mov       r10,	[rbp + mx_lib.finddllsymbol.dllindex]
    mov       [r10],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.finddllsymbol.i],	rax
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4536
L4534:
    lea       rax,	[mx_decls.dllinsttable]
    mov       r10,	[rbp + mx_lib.finddllsymbol.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    mov       rdx,	[rbp + mx_lib.finddllsymbol.name]
    call      mwindows.os_getdllprocaddr
    mov       [rbp + mx_lib.finddllsymbol.p],	rax
    mov       rax,	[rbp + mx_lib.finddllsymbol.p]
    test      rax,	rax
    jz        L4538
    mov       rax,	[rbp + mx_lib.finddllsymbol.i]
    mov       r10,	[rbp + mx_lib.finddllsymbol.dllindex]
    mov       [r10],	rax
    mov       rax,	[rbp + mx_lib.finddllsymbol.p]
    jmp       L4533
L4538:
L4537:
L4535:
    mov       rax,	[rbp + mx_lib.finddllsymbol.i]
    inc       rax
    mov       [rbp + mx_lib.finddllsymbol.i],	rax
    cmp       rax,	[mx_decls.ndlllibs]
    jle       L4534
L4536:
    xor       eax,	eax
L4533:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc checksymbols
mx_lib.checksymbols:
;>>
    %define mx_lib.checksymbols.dllindex -8
    %define mx_lib.checksymbols.undef -16
    %define mx_lib.checksymbols.p -24
    %define mx_lib.checksymbols.i -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    xor       eax,	eax
    mov       [rbp + mx_lib.checksymbols.undef],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.checksymbols.i],	rax
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4542
L4540:
    lea       rax,	[mx_decls.symboldefined]
    mov       r10,	[rbp + mx_lib.checksymbols.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jnz       L4544
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	[rbp + mx_lib.checksymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    lea       rdx,	[rbp + mx_lib.checksymbols.dllindex]
    call      mx_lib.finddllsymbol
    mov       [rbp + mx_lib.checksymbols.p],	rax
    mov       rax,	[rbp + mx_lib.checksymbols.p]
    test      rax,	rax
    jz        L4546
    mov       rax,	[rbp + mx_lib.checksymbols.p]
    lea       r10,	[mx_decls.symboladdress]
    mov       r11,	[rbp + mx_lib.checksymbols.i]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rbp + mx_lib.checksymbols.dllindex]
    lea       r10,	[mx_decls.symboldllindex]
    mov       r11,	[rbp + mx_lib.checksymbols.i]
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mx_decls.symboldefined]
    mov       r11,	[rbp + mx_lib.checksymbols.i]
    mov       [r10 + r11-1],	al
    jmp       L4545
L4546:
    call      msys.m$print_startcon
    lea       rcx,	[rel L6081]
    call      msys.m$print_str_nf
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	[rbp + mx_lib.checksymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       qword [rbp + mx_lib.checksymbols.undef]
L4545:
L4544:
L4543:
L4541:
    mov       rax,	[rbp + mx_lib.checksymbols.i]
    inc       rax
    mov       [rbp + mx_lib.checksymbols.i],	rax
    cmp       rax,	[mx_decls.nsymbols]
    jle       L4540
L4542:
    mov       rax,	[rbp + mx_lib.checksymbols.undef]
    test      rax,	rax
    jz        L4548
L4548:
L4547:
L4539:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc dorelocations
mx_lib.dorelocations:
;>>
    %define mx_lib.dorelocations.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.dorelocations.i],	rax
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4552
L4550:
    lea       rax,	[mx_decls.librelocated]
    mov       r10,	[rbp + mx_lib.dorelocations.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jnz       L4554
    lea       rax,	[mx_decls.libtable]
    mov       r10,	[rbp + mx_lib.dorelocations.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      mx_lib.reloclib
L4554:
L4553:
L4551:
    mov       rax,	[rbp + mx_lib.dorelocations.i]
    inc       rax
    mov       [rbp + mx_lib.dorelocations.i],	rax
    cmp       rax,	[mx_decls.nlibs]
    jle       L4550
L4552:
L4549:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc reloclib
mx_lib.reloclib:
;>>
    %define mx_lib.reloclib.lib 16
    %define mx_lib.reloclib.index -8
    %define mx_lib.reloclib.targetoffset -16
    %define mx_lib.reloclib.name -24
    %define mx_lib.reloclib.p -32
    %define mx_lib.reloclib.q -40
    %define mx_lib.reloclib.qaddr -48
    %define mx_lib.reloclib.r -56
    %define mx_lib.reloclib.av_1 -64
    %define mx_lib.reloclib.av_2 -72
    %define mx_lib.reloclib.i -80
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+72]
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r11,	[rax+8]
    lea       r10,	[r10 + r11]
    mov       [rbp + mx_lib.reloclib.p],	r10
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+56]
    imul      r10,	8
    mov       rax,	[rbp + mx_lib.reloclib.p]
    lea       rax,	[rax + r10]
    mov       [rbp + mx_lib.reloclib.qaddr],	rax
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+56]
    mov       [rbp + mx_lib.reloclib.av_1],	r10
    mov       rax,	[rbp + mx_lib.reloclib.av_1]
    cmp       rax,	1
    jl        L4558
L4556:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+112]
    mov       rax,	[rbp + mx_lib.reloclib.i]
    mov       r11,	[r10 + rax*8-8]
    mov       [rbp + mx_lib.reloclib.name],	r11
    mov       rax,	[rbp + mx_lib.reloclib.p]
    inc       qword [rbp + mx_lib.reloclib.p]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mx_lib.reloclib.p]
    inc       qword [rbp + mx_lib.reloclib.p]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mx_lib.reloclib.p]
    inc       qword [rbp + mx_lib.reloclib.p]
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	[rbp + mx_lib.reloclib.p]
    inc       qword [rbp + mx_lib.reloclib.p]
    mov       r10b,	37
    mov       [rax],	r10b
    mov       eax,	[rbp + mx_lib.reloclib.qaddr]
    mov       r10,	[rbp + mx_lib.reloclib.p]
    mov       [r10],	eax
    add       qword [rbp + mx_lib.reloclib.p],	4
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+176]
    mov       rax,	[rbp + mx_lib.reloclib.i]
    movsx     r11,	word [r10 + rax*2-2]
    mov       [rbp + mx_lib.reloclib.index],	r11
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	[rbp + mx_lib.reloclib.index]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + mx_lib.reloclib.qaddr]
    add       qword [rbp + mx_lib.reloclib.qaddr],	8
    mov       [rax],	r11
L4557:
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	[rbp + mx_lib.reloclib.av_1]
    jle       L4556
L4558:
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+32]
    mov       [rbp + mx_lib.reloclib.av_2],	r10
    mov       rax,	[rbp + mx_lib.reloclib.av_2]
    cmp       rax,	1
    jl        L4561
L4559:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+88]
    mov       rax,	[rbp + mx_lib.reloclib.i]
    mov       r11,	[r10 + rax*8-8]
    mov       [rbp + mx_lib.reloclib.r],	r11
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4563
    cmp       rax,	2
    jz        L4564
    cmp       rax,	3
    jz        L4565
    jmp       L4566
L4563:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+72]
    mov       eax,	[rbp + mx_lib.reloclib.r]
    lea       r10,	[r10 + rax]
    mov       [rbp + mx_lib.reloclib.p],	r10
    jmp       L4562
L4564:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+80]
    mov       eax,	[rbp + mx_lib.reloclib.r]
    lea       r10,	[r10 + rax]
    mov       [rbp + mx_lib.reloclib.p],	r10
    jmp       L4562
L4565:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+152]
    mov       eax,	[rbp + mx_lib.reloclib.r]
    lea       r10,	[r10 + rax]
    mov       [rbp + mx_lib.reloclib.p],	r10
L4566:
L4562:
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+7]
    cmp       rax,	1
    jz        L4568
    cmp       rax,	2
    jz        L4569
    cmp       rax,	4
    jz        L4570
    cmp       rax,	3
    jz        L4571
    cmp       rax,	5
    jz        L4572
    jmp       L4573
L4568:
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       r10d,	[rax]
    mov       [rbp + mx_lib.reloclib.targetoffset],	r10
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4575
    cmp       rax,	2
    jz        L4576
    cmp       rax,	3
    jz        L4577
    jmp       L4578
L4575:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+72]
    mov       rax,	[rbp + mx_lib.reloclib.targetoffset]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10d
    jmp       L4574
L4576:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+80]
    mov       rax,	[rbp + mx_lib.reloclib.targetoffset]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10d
    jmp       L4574
L4577:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+152]
    mov       rax,	[rbp + mx_lib.reloclib.targetoffset]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10d
L4578:
L4574:
    jmp       L4567
L4569:
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       r10d,	[rax]
    mov       [rbp + mx_lib.reloclib.targetoffset],	r10
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4580
    cmp       rax,	2
    jz        L4581
    cmp       rax,	3
    jz        L4582
    jmp       L4583
L4580:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+72]
    mov       rax,	[rbp + mx_lib.reloclib.targetoffset]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10
    jmp       L4579
L4581:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+80]
    mov       rax,	[rbp + mx_lib.reloclib.targetoffset]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10
    jmp       L4579
L4582:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+152]
    mov       rax,	[rbp + mx_lib.reloclib.targetoffset]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10
L4583:
L4579:
    jmp       L4567
L4570:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+176]
    movzx     rax,	word [rbp + mx_lib.reloclib.r+4]
    movsx     r11,	word [r10 + rax*2-2]
    mov       [rbp + mx_lib.reloclib.index],	r11
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	[rbp + mx_lib.reloclib.index]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    add       [rax],	r11
    jmp       L4567
L4571:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+176]
    movzx     rax,	word [rbp + mx_lib.reloclib.r+4]
    movsx     r11,	word [r10 + rax*2-2]
    mov       [rbp + mx_lib.reloclib.index],	r11
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	[rbp + mx_lib.reloclib.index]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	[rbp + mx_lib.reloclib.p]
    add       [rax],	r11d
    jmp       L4567
L4572:
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4585
    lea       rcx,	[rel L6082]
    lea       rdx,	[rel L6083]
    call      mx_lib.error
L4585:
L4584:
    movzx     rax,	word [rbp + mx_lib.reloclib.r+4]
    mov       [rbp + mx_lib.reloclib.index],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+72]
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r11,	[rax+8]
    lea       r10,	[r10 + r11]
    mov       rax,	[rbp + mx_lib.reloclib.index]
    sub       rax,	1
    imul      rax,	8
    lea       r10,	[r10 + rax]
    mov       [rbp + mx_lib.reloclib.q],	r10
    mov       rax,	[rbp + mx_lib.reloclib.p]
    lea       rax,	[rax+4]
    mov       r10,	[rbp + mx_lib.reloclib.q]
    sub       r10,	rax
    mov       rax,	[rbp + mx_lib.reloclib.p]
    mov       [rax],	r10d
L4573:
L4567:
L4560:
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	[rbp + mx_lib.reloclib.av_2]
    jle       L4559
L4561:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[rax+208]
    mov       al,	1
    lea       r11,	[mx_decls.librelocated]
    mov       [r11 + r10-1],	al
L4555:
;---------------
    add       rsp,	112
    pop       rbp
    ret       
;End 
;Proc loadimports
mx_lib.loadimports:
;>>
    %define mx_lib.loadimports.plib 16
    %define mx_lib.loadimports.qlib -8
    %define mx_lib.loadimports.name -16
    %define mx_lib.loadimports.av_1 -24
    %define mx_lib.loadimports.i -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.loadimports.i],	rax
    mov       rax,	[rbp + mx_lib.loadimports.plib]
    mov       r10,	[rax+48]
    mov       [rbp + mx_lib.loadimports.av_1],	r10
    mov       rax,	[rbp + mx_lib.loadimports.av_1]
    cmp       rax,	1
    jl        L4589
L4587:
    mov       rax,	[rbp + mx_lib.loadimports.plib]
    mov       r10,	[rax+104]
    mov       rax,	[rbp + mx_lib.loadimports.i]
    mov       r11,	[r10 + rax*8-8]
    mov       rcx,	r11
    call      mx_lib.dosublib
L4588:
    mov       rax,	[rbp + mx_lib.loadimports.i]
    inc       rax
    mov       [rbp + mx_lib.loadimports.i],	rax
    cmp       rax,	[rbp + mx_lib.loadimports.av_1]
    jle       L4587
L4589:
    mov       rcx,	[rbp + mx_lib.loadimports.plib]
    call      mx_lib.alloclibdata
    mov       rcx,	[rbp + mx_lib.loadimports.plib]
    call      mx_lib.dosymbols
L4586:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc dosublib
mx_lib.dosublib:
;>>
    %define mx_lib.dosublib.name 16
    %define mx_lib.dosublib.qlib -8
    %define mx_lib.dosublib.n -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mx_lib.dosublib.name]
    call      mx_lib.findlib
    mov       [rbp + mx_lib.dosublib.n],	rax
    mov       rax,	[rbp + mx_lib.dosublib.n]
    test      rax,	rax
    jnz       L4592
    mov       rcx,	[rbp + mx_lib.dosublib.name]
    call      mx_lib.mxaddlib
    mov       [rbp + mx_lib.dosublib.n],	rax
    call      msys.m$print_startcon
    lea       rcx,	[rel L6084]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mx_lib.dosublib.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mx_lib.dosublib.name]
    lea       rdx,	[rel L6085]
    call      mlib.addext
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.dosublib.n]
    call      mx_lib.loadlibfile
    mov       [rbp + mx_lib.dosublib.qlib],	rax
    mov       rcx,	[rbp + mx_lib.dosublib.qlib]
    call      mx_lib.loadimports
L4592:
L4591:
L4590:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc loadlibfile
mx_lib.loadlibfile:
;>>
    %define mx_lib.loadlibfile.filename 16
    %define mx_lib.loadlibfile.libno 24
    %define mx_lib.loadlibfile.plib -8
    %define mx_lib.loadlibfile.p -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mx_lib.loadlibfile.filename]
    call      mx_lib.readmxfile
    mov       [rbp + mx_lib.loadlibfile.p],	rax
    mov       rax,	[rbp + mx_lib.loadlibfile.p]
    cmp       rax,	0
    jnz       L4595
    lea       rcx,	[rel L6086]
    mov       rdx,	[rbp + mx_lib.loadlibfile.filename]
    call      mx_lib.error
L4595:
L4594:
    mov       rcx,	[rbp + mx_lib.loadlibfile.filename]
    mov       rdx,	[rbp + mx_lib.loadlibfile.p]
    call      mx_lib.readlibfile
    mov       [rbp + mx_lib.loadlibfile.plib],	rax
    mov       rax,	[rbp + mx_lib.loadlibfile.libno]
    mov       r10,	[rbp + mx_lib.loadlibfile.plib]
    mov       [r10+208],	rax
    mov       rax,	[rbp + mx_lib.loadlibfile.plib]
    lea       r10,	[mx_decls.libtable]
    mov       r11,	[rbp + mx_lib.loadlibfile.libno]
    mov       [r10 + r11*8-8],	rax
L4593:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc dosymbols
mx_lib.dosymbols:
;>>
    %define mx_lib.dosymbols.lib 16
    %define mx_lib.dosymbols.ix -8
    %define mx_lib.dosymbols.libx -16
    %define mx_lib.dosymbols.dllx -24
    %define mx_lib.dosymbols.baseaddr -32
    %define mx_lib.dosymbols.av_1 -40
    %define mx_lib.dosymbols.av_2 -48
    %define mx_lib.dosymbols.av_3 -56
    %define mx_lib.dosymbols.i -64
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.dosymbols.i],	rax
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+40]
    mov       [rbp + mx_lib.dosymbols.av_1],	r10
    mov       rax,	[rbp + mx_lib.dosymbols.av_1]
    cmp       rax,	1
    jl        L4599
L4597:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+96]
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    mov       r11,	[r10 + rax*8-8]
    mov       rcx,	r11
    call      mx_lib.adddll
L4598:
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    inc       rax
    mov       [rbp + mx_lib.dosymbols.i],	rax
    cmp       rax,	[rbp + mx_lib.dosymbols.av_1]
    jle       L4597
L4599:
    mov       rax,	1
    mov       [rbp + mx_lib.dosymbols.i],	rax
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+56]
    mov       [rbp + mx_lib.dosymbols.av_2],	r10
    mov       rax,	[rbp + mx_lib.dosymbols.av_2]
    cmp       rax,	1
    jl        L4602
L4600:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+112]
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    mov       r11,	[r10 + rax*8-8]
    mov       rcx,	r11
    call      mx_lib.addsymbol
    mov       [rbp + mx_lib.dosymbols.ix],	rax
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+176]
    mov       ax,	[rbp + mx_lib.dosymbols.ix]
    mov       r11,	[rbp + mx_lib.dosymbols.i]
    mov       [r10 + r11*2-2],	ax
L4601:
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    inc       rax
    mov       [rbp + mx_lib.dosymbols.i],	rax
    cmp       rax,	[rbp + mx_lib.dosymbols.av_2]
    jle       L4600
L4602:
    mov       rax,	1
    mov       [rbp + mx_lib.dosymbols.i],	rax
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+64]
    mov       [rbp + mx_lib.dosymbols.av_3],	r10
    mov       rax,	[rbp + mx_lib.dosymbols.av_3]
    cmp       rax,	1
    jl        L4605
L4603:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+120]
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    mov       r11,	[r10 + rax*8-8]
    mov       rcx,	r11
    call      mx_lib.addsymbol
    mov       [rbp + mx_lib.dosymbols.ix],	rax
    lea       rax,	[mx_decls.symboldefined]
    mov       r10,	[rbp + mx_lib.dosymbols.ix]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jz        L4607
    call      msys.m$print_startcon
    lea       rcx,	[rel L6087]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+120]
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    mov       r11,	[r10 + rax*8-8]
    mov       rcx,	r11
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4604
L4607:
L4606:
    mov       al,	1
    lea       r10,	[mx_decls.symboldefined]
    mov       r11,	[rbp + mx_lib.dosymbols.ix]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+128]
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    movzx     r11,	byte [r10 + rax-1]
    cmp       r11,	1
    jz        L4609
    cmp       r11,	2
    jz        L4610
    cmp       r11,	3
    jz        L4611
    jmp       L4612
L4609:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+72]
    mov       [rbp + mx_lib.dosymbols.baseaddr],	r10
    jmp       L4608
L4610:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+80]
    mov       [rbp + mx_lib.dosymbols.baseaddr],	r10
    jmp       L4608
L4611:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+152]
    mov       [rbp + mx_lib.dosymbols.baseaddr],	r10
    jmp       L4608
L4612:
    xor       eax,	eax
    mov       [rbp + mx_lib.dosymbols.baseaddr],	rax
L4608:
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+136]
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    mov       r11,	[r10 + rax*8-8]
    mov       rax,	[rbp + mx_lib.dosymbols.baseaddr]
    lea       rax,	[rax + r11]
    lea       r10,	[mx_decls.symboladdress]
    mov       r11,	[rbp + mx_lib.dosymbols.ix]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rbp + mx_lib.dosymbols.lib]
    mov       r10,	[rax+208]
    lea       rax,	[mx_decls.symbollibindex]
    mov       r11,	[rbp + mx_lib.dosymbols.ix]
    mov       [rax + r11*2-2],	r10w
L4604:
    mov       rax,	[rbp + mx_lib.dosymbols.i]
    inc       rax
    mov       [rbp + mx_lib.dosymbols.i],	rax
    cmp       rax,	[rbp + mx_lib.dosymbols.av_3]
    jle       L4603
L4605:
L4596:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc readmxfile
mx_lib.readmxfile:
;>>
    %define mx_lib.readmxfile.filename 16
    %define mx_lib.readmxfile.p -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mx_lib.readmxfile.filename]
    call      mlib.readfile
    mov       [rbp + mx_lib.readmxfile.p],	rax
    mov       rax,	[rbp + mx_lib.readmxfile.p]
    cmp       rax,	0
    jnz       L4615
    xor       eax,	eax
    jmp       L4613
L4615:
L4614:
    mov       al,	13
    mov       r10,	[rbp + mx_lib.readmxfile.p]
    mov       r11,	[mlib.rfsize]
    mov       [r10 + r11],	al
    mov       rax,	[rbp + mx_lib.readmxfile.p]
L4613:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc adddll
mx_lib.adddll:
;>>
    %define mx_lib.adddll.name 16
    %define mx_lib.adddll.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.adddll.i],	rax
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4619
L4617:
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	[rbp + mx_lib.adddll.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	[rbp + mx_lib.adddll.name]
    mov       rdx,	r11
    call      mlib.eqstring
    test      rax,	rax
    jz        L4621
    jmp       L4616
L4621:
L4620:
L4618:
    mov       rax,	[rbp + mx_lib.adddll.i]
    inc       rax
    mov       [rbp + mx_lib.adddll.i],	rax
    cmp       rax,	[mx_decls.ndlllibs]
    jle       L4617
L4619:
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	20
    jl        L4623
    lea       rcx,	[rel L6088]
    lea       rdx,	[rel L6089]
    call      mx_lib.error
L4623:
L4622:
    inc       qword [mx_decls.ndlllibs]
    mov       rax,	[mx_decls.ndlllibs]
    mov       r10,	[rbp + mx_lib.adddll.name]
    lea       r11,	[mx_decls.dllnametable]
    mov       [r11 + rax*8-8],	r10
L4616:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc addsymbol
mx_lib.addsymbol:
;>>
    %define mx_lib.addsymbol.name 16
    %define mx_lib.addsymbol.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.addsymbol.i],	rax
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4627
L4625:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	[rbp + mx_lib.addsymbol.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	[rbp + mx_lib.addsymbol.name]
    mov       rdx,	r11
    call      mlib.eqstring
    test      rax,	rax
    jz        L4629
    mov       rax,	[rbp + mx_lib.addsymbol.i]
    jmp       L4624
L4629:
L4628:
L4626:
    mov       rax,	[rbp + mx_lib.addsymbol.i]
    inc       rax
    mov       [rbp + mx_lib.addsymbol.i],	rax
    cmp       rax,	[mx_decls.nsymbols]
    jle       L4625
L4627:
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	3000
    jl        L4631
    lea       rcx,	[rel L6090]
    lea       rdx,	[rel L6091]
    call      mx_lib.error
L4631:
L4630:
    inc       qword [mx_decls.nsymbols]
    mov       rax,	[mx_decls.nsymbols]
    mov       r10,	[rbp + mx_lib.addsymbol.name]
    lea       r11,	[mx_decls.symbolnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[mx_decls.nsymbols]
L4624:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc setspecialglobals
mx_lib.setspecialglobals:
;>>
    %define mx_lib.setspecialglobals.cmdskip 16
    %define mx_lib.setspecialglobals.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.setspecialglobals.i],	rax
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4635
L4633:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	[rbp + mx_lib.setspecialglobals.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11]
    cmp       rax,	36
    jnz       L4637
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	[rbp + mx_lib.setspecialglobals.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    lea       rdx,	[rel L6092]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4639
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	[rbp + mx_lib.setspecialglobals.i]
    mov       r11,	[rax + r10*8-8]
    mov       al,	[rbp + mx_lib.setspecialglobals.cmdskip]
    mov       [r11],	al
L4639:
L4638:
L4637:
L4636:
L4634:
    mov       rax,	[rbp + mx_lib.setspecialglobals.i]
    inc       rax
    mov       [rbp + mx_lib.setspecialglobals.i],	rax
    cmp       rax,	[mx_decls.nsymbols]
    jle       L4633
L4635:
L4632:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc runprogram
mx_lib.runprogram:
;>>
    %define mx_lib.runprogram.lib 16
    %define mx_lib.runprogram.cmdskip 24
    %define mx_lib.runprogram.fnptr -8
    %define mx_lib.runprogram.libno -16
    %define mx_lib.runprogram.i -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rax,	[rbp + mx_lib.runprogram.lib]
    mov       r10,	[rax+208]
    mov       [rbp + mx_lib.runprogram.libno],	r10
    mov       rax,	1
    mov       [rbp + mx_lib.runprogram.i],	rax
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4643
L4641:
    mov       rax,	[rbp + mx_lib.runprogram.i]
    cmp       rax,	[rbp + mx_lib.runprogram.libno]
    jz        L4645
    lea       rax,	[mx_decls.libinitdone]
    mov       r10,	[rbp + mx_lib.runprogram.i]
    movzx     r11,	byte [rax + r10-1]
    test      r11,	r11
    jnz       L4645
    lea       rax,	[mx_decls.libtable]
    mov       r10,	[rbp + mx_lib.runprogram.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      mx_lib.calllibinit
L4645:
L4644:
L4642:
    mov       rax,	[rbp + mx_lib.runprogram.i]
    inc       rax
    mov       [rbp + mx_lib.runprogram.i],	rax
    cmp       rax,	[mx_decls.nlibs]
    jle       L4641
L4643:
    mov       rax,	[rbp + mx_lib.runprogram.lib]
    mov       r10,	[rax+200]
    cmp       r10,	0
    jnz       L4647
    lea       rcx,	[rel L6093]
    lea       rdx,	[rel L6094]
    call      mx_lib.error
L4647:
L4646:
    mov       rcx,	[rbp + mx_lib.runprogram.cmdskip]
    call      mx_lib.setspecialglobals
    mov       rax,	[rbp + mx_lib.runprogram.lib]
    mov       r10,	[rax+200]
    mov       [rbp + mx_lib.runprogram.fnptr],	r10
    mov       rax,	[rbp + mx_lib.runprogram.fnptr]
    call      rax
    mov       al,	1
    lea       r10,	[mx_decls.libinitdone]
    mov       r11,	[rbp + mx_lib.runprogram.libno]
    mov       [r10 + r11-1],	al
L4640:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc calllibinit
mx_lib.calllibinit:
;>>
    %define mx_lib.calllibinit.lib 16
    %define mx_lib.calllibinit.fnptr -8
    %define mx_lib.calllibinit.libno -16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.calllibinit.lib]
    mov       r10,	[rax+208]
    mov       [rbp + mx_lib.calllibinit.libno],	r10
    mov       rax,	[rbp + mx_lib.calllibinit.lib]
    mov       r10,	[rax+200]
    test      r10,	r10
    jz        L4650
    mov       rax,	[rbp + mx_lib.calllibinit.lib]
    mov       r10,	[rax+200]
    mov       [rbp + mx_lib.calllibinit.fnptr],	r10
    mov       rax,	[rbp + mx_lib.calllibinit.fnptr]
    call      rax
L4650:
L4649:
    mov       rax,	[rbp + mx_lib.calllibinit.lib]
    mov       r10,	[rax+208]
    mov       al,	1
    lea       r11,	[mx_decls.libinitdone]
    mov       [r11 + r10-1],	al
L4648:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc findsymbol
mx_lib.findsymbol:
;>>
    %define mx_lib.findsymbol.name 16
    %define mx_lib.findsymbol.i -8
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+16],	rcx
;---------------
    mov       rax,	1
    mov       [rbp + mx_lib.findsymbol.i],	rax
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4654
L4652:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	[rbp + mx_lib.findsymbol.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    mov       rdx,	[rbp + mx_lib.findsymbol.name]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4656
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	[rbp + mx_lib.findsymbol.i]
    mov       r11,	[rax + r10*8-8]
    mov       rax,	r11
    jmp       L4651
L4656:
L4655:
L4653:
    mov       rax,	[rbp + mx_lib.findsymbol.i]
    inc       rax
    mov       [rbp + mx_lib.findsymbol.i],	rax
    cmp       rax,	[mx_decls.nsymbols]
    jle       L4652
L4654:
    xor       eax,	eax
L4651:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc loadmx
mx_lib.loadmx:
;>>
    %define mx_lib.loadmx.filename 16
    %define mx_lib.loadmx.plib -8
    %define mx_lib.loadmx.newlib -16
    %define mx_lib.loadmx.name -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mx_lib.loadmx.filename]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.loadmx.name],	rax
    mov       rcx,	[rbp + mx_lib.loadmx.name]
    mov       rdx,	[rbp + mx_lib.loadmx.filename]
    call      mx_lib.checknew
    mov       rcx,	[rbp + mx_lib.loadmx.name]
    call      mx_lib.mxaddlib
    mov       [rbp + mx_lib.loadmx.newlib],	rax
    mov       rcx,	[rbp + mx_lib.loadmx.filename]
    mov       rdx,	[rbp + mx_lib.loadmx.newlib]
    call      mx_lib.loadlibfile
    mov       [rbp + mx_lib.loadmx.plib],	rax
    mov       rcx,	[rbp + mx_lib.loadmx.plib]
    call      mx_lib.loadimports
    mov       rax,	[rbp + mx_lib.loadmx.plib]
L4657:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc loadmemmcb
mx_lib.loadmemmcb:
;>>
    %define mx_lib.loadmemmcb.filename 16
    %define mx_lib.loadmemmcb.p 24
    %define mx_lib.loadmemmcb.plib -8
    %define mx_lib.loadmemmcb.newlib -16
    %define mx_lib.loadmemmcb.name -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[rbp + mx_lib.loadmemmcb.filename]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.loadmemmcb.name],	rax
    mov       rcx,	[rbp + mx_lib.loadmemmcb.name]
    mov       rdx,	[rbp + mx_lib.loadmemmcb.filename]
    call      mx_lib.checknew
    mov       rcx,	[rbp + mx_lib.loadmemmcb.name]
    call      mx_lib.mxaddlib
    mov       [rbp + mx_lib.loadmemmcb.newlib],	rax
    mov       rcx,	[rbp + mx_lib.loadmemmcb.filename]
    mov       rdx,	[rbp + mx_lib.loadmemmcb.p]
    call      mx_lib.readlibfile
    mov       [rbp + mx_lib.loadmemmcb.plib],	rax
    mov       rax,	[rbp + mx_lib.loadmemmcb.newlib]
    mov       r10,	[rbp + mx_lib.loadmemmcb.plib]
    mov       [r10+208],	rax
    mov       rax,	[rbp + mx_lib.loadmemmcb.plib]
    lea       r10,	[mx_decls.libtable]
    mov       r11,	[rbp + mx_lib.loadmemmcb.newlib]
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	[rbp + mx_lib.loadmemmcb.plib]
    call      mx_lib.loadimports
    mov       rax,	[rbp + mx_lib.loadmemmcb.plib]
L4658:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc writemcx
mx_write.writemcx:
;>>
    %define mx_write.writemcx.filename 16
    %define mx_write.writemcx.n -8
    %define mx_write.writemcx.ndlls -16
    %define mx_write.writemcx.nlibs -24
    %define mx_write.writemcx.i -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_write.roundsegment
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_write.roundsegment
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mx_write.dest],	rax
    mov       rcx,	441992013
    call      mx_write.genword32
    mov       rcx,	1
    call      mx_write.genbyte
    lea       rcx,	[rel L6095]
    call      mx_write.genstring
    call      mx_run.countsymbols
    call      mx_write.writerelocs
    mov       rcx,	4
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_zdatalen]
    call      mx_write.genword32
    mov       rcx,	2
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mx_write.writemcx.n],	r10
    mov       rcx,	rax
    call      mx_write.genword32
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_write.writemcx.n]
    call      mx_write.genblock
    mov       rcx,	3
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mx_write.writemcx.n],	r10
    mov       rcx,	rax
    call      mx_write.genword32
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_write.writemcx.n]
    call      mx_write.genblock
    xor       eax,	eax
    mov       [rbp + mx_write.writemcx.ndlls],	rax
    xor       eax,	eax
    mov       [rbp + mx_write.writemcx.nlibs],	rax
    mov       rax,	1
    mov       [rbp + mx_write.writemcx.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4662
L4660:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mx_write.writemcx.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11]
    cmp       rax,	36
    jz        L4664
    inc       qword [rbp + mx_write.writemcx.ndlls]
L4664:
L4663:
L4661:
    mov       rax,	[rbp + mx_write.writemcx.i]
    inc       rax
    mov       [rbp + mx_write.writemcx.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L4660
L4662:
    mov       rcx,	6
    call      mx_write.genbyte
    mov       rcx,	[rbp + mx_write.writemcx.ndlls]
    call      mx_write.genword32
    mov       rax,	1
    mov       [rbp + mx_write.writemcx.i],	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4667
L4665:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mx_write.writemcx.i]
    mov       r11,	[rax + r10*8-8]
    movzx     rax,	byte [r11]
    cmp       rax,	36
    jz        L4669
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	[rbp + mx_write.writemcx.i]
    mov       r11,	[rax + r10*8-8]
    mov       rcx,	r11
    call      mx_write.genstring
L4669:
L4668:
L4666:
    mov       rax,	[rbp + mx_write.writemcx.i]
    inc       rax
    mov       [rbp + mx_write.writemcx.i],	rax
    cmp       rax,	[pc_decls.nplibfiles]
    jle       L4665
L4667:
    call      mx_write.writesymbols
    mov       rcx,	13
    call      mx_write.genbyte
    mov       rax,	[mx_write.dest]
    mov       r10,	[rax+8]
    mov       rax,	[mx_write.dest]
    mov       r11,	[rax]
    sub       r10,	r11
    mov       rax,	[mx_write.dest]
    mov       r11,	[rax]
    mov       rcx,	[rbp + mx_write.writemcx.filename]
    mov       rdx,	r11
    mov       r8,	r10
    call      mlib.writefile
L4659:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc writerelocs
mx_write.writerelocs:
;>>
    %define mx_write.writerelocs.oldr -8
    %define mx_write.writerelocs.newr -16
    %define mx_write.writerelocs.n -24
    %define mx_write.writerelocs.count -32
    %define mx_write.writerelocs.d -40
    %define mx_write.writerelocs.baseptr64 -48
    %define mx_write.writerelocs.i -56
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
;---------------
    mov       rcx,	5
    call      mx_write.genbyte
    mov       rax,	[mc_decls.ss_nidatarelocs]
    add       rax,	[mc_decls.ss_ncoderelocs]
;DUPLOP
    mov       r10,	rax
    mov       [rbp + mx_write.writerelocs.n],	r10
    mov       rcx,	rax
    call      mx_write.genword32
    xor       eax,	eax
    mov       [rbp + mx_write.writerelocs.count],	rax
    mov       rax,	1
    mov       [rbp + mx_write.writerelocs.i],	rax
L4671:
    mov       rax,	[rbp + mx_write.writerelocs.i]
    cmp       rax,	1
    jnz       L4675
    mov       rax,	[mc_decls.ss_idatarelocs]
    jmp       L4674
L4675:
    mov       rax,	[mc_decls.ss_coderelocs]
L4674:
    mov       [rbp + mx_write.writerelocs.oldr],	rax
    jmp       L4679
L4676:
    inc       qword [rbp + mx_write.writerelocs.count]
    lea       rax,	[rbp + mx_write.writerelocs.newr]
    xor       r10,	r10
    mov       [rax],	r10
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    mov       r10,	[rax+16]
    mov       [rbp + mx_write.writerelocs.newr],	r10d
    mov       rax,	[rbp + mx_write.writerelocs.i]
    cmp       rax,	1
    jnz       L4681
    mov       rax,	2
    jmp       L4680
L4681:
    mov       rax,	1
L4680:
    mov       [rbp + mx_write.writerelocs.newr+6],	al
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    mov       r10,	[rax+24]
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_write.writerelocs.d],	r11
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    mov       r10,	[rax+8]
    cmp       r10,	4
    jz        L4683
    cmp       r10,	2
    jz        L4684
    cmp       r10,	1
    jz        L4684
    jmp       L4685
L4683:
    mov       rax,	[rbp + mx_write.writerelocs.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4687
    mov       rax,	[rbp + mx_write.writerelocs.d]
    movsx     r10,	word [rax+102]
    mov       [rbp + mx_write.writerelocs.newr+4],	r10w
    mov       al,	5
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L4686
L4687:
    lea       rcx,	[rel L6096]
    call      mc_libmcl.axerror
L4686:
    jmp       L4682
L4684:
    mov       rax,	[rbp + mx_write.writerelocs.d]
    movzx     r10,	byte [rax+56]
    test      r10,	r10
    jz        L4689
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4691
    mov       rax,	3
    jmp       L4690
L4691:
    mov       rax,	4
L4690:
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    mov       rax,	[rbp + mx_write.writerelocs.d]
    movsx     r10,	word [rax+102]
    mov       [rbp + mx_write.writerelocs.newr+4],	r10w
    jmp       L4688
L4689:
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    mov       r10,	[rax+8]
    cmp       r10,	2
    jnz       L4693
    mov       al,	1
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L4692
L4693:
    mov       al,	2
    mov       [rbp + mx_write.writerelocs.newr+7],	al
L4692:
    mov       rax,	[rbp + mx_write.writerelocs.d]
    movzx     r10,	byte [rax+70]
    mov       [rbp + mx_write.writerelocs.newr+4],	r10b
L4688:
    jmp       L4682
L4685:
    lea       rcx,	[rel L6097]
    call      mc_libmcl.axerror
L4682:
    lea       rcx,	[rbp + mx_write.writerelocs.newr]
    mov       rdx,	8
    call      mx_write.genblock
L4677:
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    mov       r10,	[rax]
    mov       [rbp + mx_write.writerelocs.oldr],	r10
L4679:
    mov       rax,	[rbp + mx_write.writerelocs.oldr]
    test      rax,	rax
    jnz       L4676
L4678:
L4672:
    mov       rax,	[rbp + mx_write.writerelocs.i]
    inc       rax
    mov       [rbp + mx_write.writerelocs.i],	rax
    cmp       rax,	2
    jle       L4671
L4673:
L4670:
;---------------
    add       rsp,	96
    pop       rbp
    ret       
;End 
;Proc writesymbols
mx_write.writesymbols:
;>>
    %define mx_write.writesymbols.d -8
    %define mx_write.writesymbols.n -16
    %define mx_write.writesymbols.name -24
    %define mx_write.writesymbols.i -32
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    mov       rcx,	8
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymimports]
    call      mx_write.genword32
    mov       rax,	1
    mov       [rbp + mx_write.writesymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4697
L4695:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_write.writesymbols.i]
    mov       r11,	[rax + r10*8-8]
    movsx     rax,	word [r11+102]
    test      rax,	rax
    jz        L4699
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_write.writesymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_write.writesymbols.d],	r11
    mov       rax,	[rbp + mx_write.writesymbols.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mx_write.genstring
L4699:
L4698:
L4696:
    mov       rax,	[rbp + mx_write.writesymbols.i]
    inc       rax
    mov       [rbp + mx_write.writesymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4695
L4697:
    mov       rcx,	9
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genword32
    mov       rax,	1
    mov       [rbp + mx_write.writesymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4702
L4700:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_write.writesymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_write.writesymbols.d],	r11
    mov       rax,	[rbp + mx_write.writesymbols.d]
    movsx     r10,	word [rax+104]
    test      r10,	r10
    jz        L4704
    mov       rax,	[rbp + mx_write.writesymbols.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    lea       rdx,	[rel L6098]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4706
    mov       rax,	[rbp + mx_write.writesymbols.d]
    mov       [mx_write.entrypoint],	rax
L4706:
L4705:
    mov       rax,	[rbp + mx_write.writesymbols.d]
    mov       r10,	[rax]
    mov       rcx,	r10
    call      mx_write.genstring
L4704:
L4703:
L4701:
    mov       rax,	[rbp + mx_write.writesymbols.i]
    inc       rax
    mov       [rbp + mx_write.writesymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4700
L4702:
    mov       rcx,	10
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genword32
    mov       rax,	1
    mov       [rbp + mx_write.writesymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4709
L4707:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_write.writesymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_write.writesymbols.d],	r11
    mov       rax,	[rbp + mx_write.writesymbols.d]
    movsx     r10,	word [rax+104]
    test      r10,	r10
    jz        L4711
    mov       rax,	[rbp + mx_write.writesymbols.d]
    movzx     r10,	byte [rax+70]
    mov       rcx,	r10
    call      mx_write.genbyte
L4711:
L4710:
L4708:
    mov       rax,	[rbp + mx_write.writesymbols.i]
    inc       rax
    mov       [rbp + mx_write.writesymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4707
L4709:
    mov       rcx,	11
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genword32
    mov       rax,	1
    mov       [rbp + mx_write.writesymbols.i],	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4714
L4712:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	[rbp + mx_write.writesymbols.i]
    mov       r11,	[rax + r10*8-8]
    mov       [rbp + mx_write.writesymbols.d],	r11
    mov       rax,	[rbp + mx_write.writesymbols.d]
    movsx     r10,	word [rax+104]
    test      r10,	r10
    jz        L4716
    mov       rax,	[rbp + mx_write.writesymbols.d]
    movsxd    r10,	dword [rax+52]
    mov       rcx,	r10
    call      mx_write.genword32
L4716:
L4715:
L4713:
    mov       rax,	[rbp + mx_write.writesymbols.i]
    inc       rax
    mov       [rbp + mx_write.writesymbols.i],	rax
    cmp       rax,	[mc_decls.ss_nsymbols]
    jle       L4712
L4714:
    mov       rcx,	12
    call      mx_write.genbyte
    mov       rax,	[mx_write.entrypoint]
    test      rax,	rax
    jz        L4718
    mov       rax,	[mx_write.entrypoint]
    movsxd    r10,	dword [rax+52]
    mov       rcx,	r10
    call      mx_write.genword32
    jmp       L4717
L4718:
    mov       rcx,	4294967295
    call      mx_write.genword32
L4717:
L4694:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc roundsegment
mx_write.roundsegment:
;>>
    %define mx_write.roundsegment.p 16
    %define mx_write.roundsegment.align 24
    %define mx_write.roundsegment.value 32
    %define mx_write.roundsegment.length -8
    %define mx_write.roundsegment.newlength -16
    %define mx_write.roundsegment.av_1 -24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
;---------------
    mov       rcx,	[rbp + mx_write.roundsegment.p]
    call      mc_genss.bufferlength
    mov       [rbp + mx_write.roundsegment.length],	rax
    mov       rcx,	[rbp + mx_write.roundsegment.length]
    mov       rdx,	[rbp + mx_write.roundsegment.align]
    call      mlib.roundtoblock
    mov       [rbp + mx_write.roundsegment.newlength],	rax
    mov       rcx,	[rbp + mx_write.roundsegment.p]
    mov       rdx,	[rbp + mx_write.roundsegment.align]
    call      mc_genss.buffercheck
    mov       rax,	[rbp + mx_write.roundsegment.newlength]
    sub       rax,	[rbp + mx_write.roundsegment.length]
    mov       [rbp + mx_write.roundsegment.av_1],	rax
    mov       rax,	[rbp + mx_write.roundsegment.av_1]
    cmp       rax,	0
    jle       L4722
L4720:
    mov       rax,	[rbp + mx_write.roundsegment.p]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mx_write.roundsegment.value]
    mov       [r10],	al
L4721:
    dec       qword [rbp + mx_write.roundsegment.av_1]
    jnz       L4720
L4722:
L4719:
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc genbyte
mx_write.genbyte:
;>>
    %define mx_write.genbyte.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	1
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	[rbp + mx_write.genbyte.x]
    mov       [r10],	al
L4723:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genword32
mx_write.genword32:
;>>
    %define mx_write.genword32.x 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	4
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    add       qword [rax],	4
    mov       eax,	[rbp + mx_write.genword32.x]
    mov       [r10],	eax
L4724:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genstring
mx_write.genstring:
;>>
    %define mx_write.genstring.s 16
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
;---------------
    mov       rcx,	[rbp + mx_write.genstring.s]
    call      strlen
    add       rax,	1
    mov       rcx,	[rbp + mx_write.genstring.s]
    mov       rdx,	rax
    call      mx_write.genblock
L4725:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc genblock
mx_write.genblock:
;>>
    %define mx_write.genblock.p 16
    %define mx_write.genblock.length 24
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	[rbp + mx_write.genblock.length]
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    mov       r10,	[rax+8]
    mov       rcx,	r10
    mov       rdx,	[rbp + mx_write.genblock.p]
    mov       r8,	[rbp + mx_write.genblock.length]
    call      memcpy
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rbp + mx_write.genblock.length]
    add       [rax],	r10
L4726:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc start
msyslib.start:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      msys.start
L4727:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
;Proc start
pcl.start:
;>>
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
;---------------
    call      mc_genss.start
    call      mc_decls.start
    call      mc_stackmcl.start
    call      mc_writenasm.start
L4728:
;---------------
    add       rsp,	32
    pop       rbp
    ret       
;End 
    segment .data
$procaddr:
    dq  mc_auxmcl.do_addrmode
    dq  mc_genmcl.px_nop
    dq  mc_genmcl.px_dupl
    dq  mc_genmcl.px_double
    dq  mc_genmcl.px_opnd
    dq  mc_genmcl.px_type
    dq  mc_genmcl.px_comment
    dq  mc_genmcl.px_defproc
    dq  mc_genmcl.px_endproc
    dq  mc_genmcl.px_endprog
    dq  mc_genmcl.px_istatic
    dq  mc_genmcl.px_zstatic
    dq  mc_genmcl.px_data
    dq  mc_genmcl.px_label
    dq  mc_genmcl.px_load
    dq  mc_genmcl.px_store
    dq  mc_genmcl.px_add
    dq  mc_genmcl.px_sub
    dq  mc_genmcl.px_mul
    dq  mc_genmcl.px_div
    dq  mc_genmcl.px_eval
    dq  mc_genmcl.px_widen
    dq  mc_genmcl.px_jump
    dq  mc_genmcl.px_neg
    dq  mc_genmcl.px_abs
    dq  mc_genmcl.px_bitnot
    dq  mc_genmcl.px_not
    dq  mc_genmcl.px_toboolt
    dq  mc_genmcl.px_sqr
    dq  mc_genmcl.px_sqrt
    dq  mc_genmcl.px_jumpcc
    dq  mc_genmcl.px_jumpt
    dq  mc_genmcl.px_jumpf
    dq  mc_genmcl.px_bitand
    dq  mc_genmcl.px_bitor
    dq  mc_genmcl.px_bitxor
    dq  mc_genmcl.px_shl
    dq  mc_genmcl.px_shr
    dq  mc_genmcl.px_retproc
    dq  mc_genmcl.px_retfn
    dq  mc_genmcl.px_setcall
    dq  mc_genmcl.px_setarg
    dq  mc_genmcl.px_callp
    dq  mc_genmcl.px_jumpret
    dq  mc_genmcl.px_jumpretm
    dq  mc_genmcl.px_startmx
    dq  mc_genmcl.px_resetmx
    dq  mc_genmcl.px_stop
    dq  mc_genmcl.px_incrto
    dq  mc_genmcl.px_decrto
    dq  mc_genmcl.px_incrload
    dq  mc_genmcl.px_decrload
    dq  mc_genmcl.px_loadincr
    dq  mc_genmcl.px_loaddecr
    dq  mc_genmcl.px_forup
    dq  mc_genmcl.px_fordown
    dq  mc_genmcl.px_iload
    dq  mc_genmcl.px_iloadx
    dq  mc_genmcl.px_istore
    dq  mc_genmcl.px_istorex
    dq  mc_genmcl.px_addpx
    dq  mc_genmcl.px_subpx
    dq  mc_genmcl.px_to
    dq  mc_genmcl.px_iswap
    dq  mc_genmcl.px_swapstk
    dq  mc_genmcl.px_labeldef
    dq  mc_genmcl.px_addto
    dq  mc_genmcl.px_subto
    dq  mc_genmcl.px_multo
    dq  mc_genmcl.px_bitandto
    dq  mc_genmcl.px_bitorto
    dq  mc_genmcl.px_bitxorto
    dq  mc_genmcl.px_shlto
    dq  mc_genmcl.px_shrto
    dq  mc_genmcl.px_fix
    dq  mc_genmcl.px_float
    dq  mc_genmcl.px_idiv
    dq  mc_genmcl.px_irem
    dq  mc_genmcl.px_idivrem
    dq  mc_genmcl.px_clear
    dq  mc_genmcl.px_subp
    dq  mc_genmcl.px_switch
    dq  mc_genmcl.px_switchu
    dq  mc_genmcl.px_swlabel
    dq  mc_genmcl.px_endsw
    dq  mc_genmcl.px_fwiden
    dq  mc_genmcl.px_fnarrow
    dq  mc_genmcl.px_truncate
    dq  mc_genmcl.px_typepun
    dq  mc_genmcl.px_unload
    dq  mc_genmcl.px_loadbit
    dq  mc_genmcl.px_assem
    dq  mc_genmcl.px_sin
    dq  mc_genmcl.px_cos
    dq  mc_genmcl.px_tan
    dq  mc_genmcl.px_asin
    dq  mc_genmcl.px_acos
    dq  mc_genmcl.px_atan
    dq  mc_genmcl.px_log
    dq  mc_genmcl.px_log10
    dq  mc_genmcl.px_exp
    dq  mc_genmcl.px_round
    dq  mc_genmcl.px_floor
    dq  mc_genmcl.px_ceil
    dq  mc_genmcl.px_atan2
    dq  mc_genmcl.px_fmod
    dq  mc_genmcl.px_setcc
    dq  mc_genmcl.px_min
    dq  mc_genmcl.px_max
    dq  mc_genmcl.px_power
    dq  mc_genmcl.px_minto
    dq  mc_genmcl.px_maxto
    dq  mc_genmcl.px_negto
    dq  mc_genmcl.px_absto
    dq  mc_genmcl.px_addpxto
    dq  mc_genmcl.px_subpxto
    dq  mc_genmcl.px_divto
    dq  mc_genmcl.px_bitnotto
    dq  mc_genmcl.px_notto
    dq  mc_genmcl.px_toboolto
    dq  mc_genmcl.px_sign
    dq  mc_genmcl.px_loadbf
    dq  mc_genmcl.px_storebit
    dq  mc_genmcl.px_storebf
    dq  mc_genmcl.px_slicelen
    dq  mc_genmcl.px_sliceptr
    dq  mc_genmcl.px_loadall
    dq  mc_genmcl.px_setjmp
    dq  mc_genmcl.px_longjmp
$procname:
    dq  L6099
    dq  L6100
    dq  L6101
    dq  L6102
    dq  L6103
    dq  L6104
    dq  L6105
    dq  L6106
    dq  L6107
    dq  L6108
    dq  L6109
    dq  L6110
    dq  L6111
    dq  L6112
    dq  L6113
    dq  L6114
    dq  L6115
    dq  L6116
    dq  L6117
    dq  L6118
    dq  L6119
    dq  L6120
    dq  L6121
    dq  L6122
    dq  L6123
    dq  L6124
    dq  L6125
    dq  L6126
    dq  L6127
    dq  L6128
    dq  L6129
    dq  L6130
    dq  L6131
    dq  L6132
    dq  L6133
    dq  L6134
    dq  L6135
    dq  L6136
    dq  L6137
    dq  L6138
    dq  L6139
    dq  L6140
    dq  L6141
    dq  L6142
    dq  L6143
    dq  L6144
    dq  L6145
    dq  L6146
    dq  L6147
    dq  L6148
    dq  L6149
    dq  L6150
    dq  L6151
    dq  L6152
    dq  L6153
    dq  L6154
    dq  L6155
    dq  L6156
    dq  L6157
    dq  L6158
    dq  L6159
    dq  L6160
    dq  L6161
    dq  L6162
    dq  L6163
    dq  L6164
    dq  L6165
    dq  L6166
    dq  L6167
    dq  L6168
    dq  L6169
    dq  L6170
    dq  L6171
    dq  L6172
    dq  L6173
    dq  L6174
    dq  L6175
    dq  L6176
    dq  L6177
    dq  L6178
    dq  L6179
    dq  L6180
    dq  L6181
    dq  L6182
    dq  L6183
    dq  L6184
    dq  L6185
    dq  L6186
    dq  L6187
    dq  L6188
    dq  L6189
    dq  L6190
    dq  L6191
    dq  L6192
    dq  L6193
    dq  L6194
    dq  L6195
    dq  L6196
    dq  L6197
    dq  L6198
    dq  L6199
    dq  L6200
    dq  L6201
    dq  L6202
    dq  L6203
    dq  L6204
    dq  L6205
    dq  L6206
    dq  L6207
    dq  L6208
    dq  L6209
    dq  L6210
    dq  L6211
    dq  L6212
    dq  L6213
    dq  L6214
    dq  L6215
    dq  L6216
    dq  L6217
    dq  L6218
    dq  L6219
    dq  L6220
    dq  L6221
    dq  L6222
    dq  L6223
    dq  L6224
    dq  L6225
    dq  L6226
    dq  L6227
$nprocs:
    dq  0x81
;Real Table
    align     8
L5766:
    dq  0.00000000000000000000
L5689:
    dq  0x7FF0000000000000
L5687:
    dq  0x7FF0000000000000
L5558:
    dq  0x7FF0000000000000
L5491:
    dq  1.00000000000000000000
L5490:
    dq  9223372036854775800.00000000000000000000
L5468:
    dq  0.00000000000000000000
L5467:
    dq  1.00000000000000000000
L5466:
    dq  0.00000000000000000000
L5465:
    dq  -1.00000000000000000000
L5464:
    dq  0.00000000000000000000
L5463:
    dq  1.00000000000000000000
L5460:
    dq  0.00000000000000000000
L5458:
    dq  0.00000000000000000000
;Real32 Table
    align     16
;labneg64
L5646:
    dq  0x8000000000000000
    dq  0x8000000000000000
;mask63/offset64
L5649:
    dq  0x7FFFFFFFFFFFFFFF
L5650:
    dq  0x43E0000000000000
;String Table
    align     8
L6227:
    db        "px_longjmp"
    db        0
L6226:
    db        "px_setjmp"
    db        0
L6225:
    db        "px_loadall"
    db        0
L6224:
    db        "px_sliceptr"
    db        0
L6223:
    db        "px_slicelen"
    db        0
L6222:
    db        "px_storebf"
    db        0
L6221:
    db        "px_storebit"
    db        0
L6220:
    db        "px_loadbf"
    db        0
L6219:
    db        "px_sign"
    db        0
L6218:
    db        "px_toboolto"
    db        0
L6217:
    db        "px_notto"
    db        0
L6216:
    db        "px_bitnotto"
    db        0
L6215:
    db        "px_divto"
    db        0
L6214:
    db        "px_subpxto"
    db        0
L6213:
    db        "px_addpxto"
    db        0
L6212:
    db        "px_absto"
    db        0
L6211:
    db        "px_negto"
    db        0
L6210:
    db        "px_maxto"
    db        0
L6209:
    db        "px_minto"
    db        0
L6208:
    db        "px_power"
    db        0
L6207:
    db        "px_max"
    db        0
L6206:
    db        "px_min"
    db        0
L6205:
    db        "px_setcc"
    db        0
L6204:
    db        "px_fmod"
    db        0
L6203:
    db        "px_atan2"
    db        0
L6202:
    db        "px_ceil"
    db        0
L6201:
    db        "px_floor"
    db        0
L6200:
    db        "px_round"
    db        0
L6199:
    db        "px_exp"
    db        0
L6198:
    db        "px_log10"
    db        0
L6197:
    db        "px_log"
    db        0
L6196:
    db        "px_atan"
    db        0
L6195:
    db        "px_acos"
    db        0
L6194:
    db        "px_asin"
    db        0
L6193:
    db        "px_tan"
    db        0
L6192:
    db        "px_cos"
    db        0
L6191:
    db        "px_sin"
    db        0
L6190:
    db        "px_assem"
    db        0
L6189:
    db        "px_loadbit"
    db        0
L6188:
    db        "px_unload"
    db        0
L6187:
    db        "px_typepun"
    db        0
L6186:
    db        "px_truncate"
    db        0
L6185:
    db        "px_fnarrow"
    db        0
L6184:
    db        "px_fwiden"
    db        0
L6183:
    db        "px_endsw"
    db        0
L6182:
    db        "px_swlabel"
    db        0
L6181:
    db        "px_switchu"
    db        0
L6180:
    db        "px_switch"
    db        0
L6179:
    db        "px_subp"
    db        0
L6178:
    db        "px_clear"
    db        0
L6177:
    db        "px_idivrem"
    db        0
L6176:
    db        "px_irem"
    db        0
L6175:
    db        "px_idiv"
    db        0
L6174:
    db        "px_float"
    db        0
L6173:
    db        "px_fix"
    db        0
L6172:
    db        "px_shrto"
    db        0
L6171:
    db        "px_shlto"
    db        0
L6170:
    db        "px_bitxorto"
    db        0
L6169:
    db        "px_bitorto"
    db        0
L6168:
    db        "px_bitandto"
    db        0
L6167:
    db        "px_multo"
    db        0
L6166:
    db        "px_subto"
    db        0
L6165:
    db        "px_addto"
    db        0
L6164:
    db        "px_labeldef"
    db        0
L6163:
    db        "px_swapstk"
    db        0
L6162:
    db        "px_iswap"
    db        0
L6161:
    db        "px_to"
    db        0
L6160:
    db        "px_subpx"
    db        0
L6159:
    db        "px_addpx"
    db        0
L6158:
    db        "px_istorex"
    db        0
L6157:
    db        "px_istore"
    db        0
L6156:
    db        "px_iloadx"
    db        0
L6155:
    db        "px_iload"
    db        0
L6154:
    db        "px_fordown"
    db        0
L6153:
    db        "px_forup"
    db        0
L6152:
    db        "px_loaddecr"
    db        0
L6151:
    db        "px_loadincr"
    db        0
L6150:
    db        "px_decrload"
    db        0
L6149:
    db        "px_incrload"
    db        0
L6148:
    db        "px_decrto"
    db        0
L6147:
    db        "px_incrto"
    db        0
L6146:
    db        "px_stop"
    db        0
L6145:
    db        "px_resetmx"
    db        0
L6144:
    db        "px_startmx"
    db        0
L6143:
    db        "px_jumpretm"
    db        0
L6142:
    db        "px_jumpret"
    db        0
L6141:
    db        "px_callp"
    db        0
L6140:
    db        "px_setarg"
    db        0
L6139:
    db        "px_setcall"
    db        0
L6138:
    db        "px_retfn"
    db        0
L6137:
    db        "px_retproc"
    db        0
L6136:
    db        "px_shr"
    db        0
L6135:
    db        "px_shl"
    db        0
L6134:
    db        "px_bitxor"
    db        0
L6133:
    db        "px_bitor"
    db        0
L6132:
    db        "px_bitand"
    db        0
L6131:
    db        "px_jumpf"
    db        0
L6130:
    db        "px_jumpt"
    db        0
L6129:
    db        "px_jumpcc"
    db        0
L6128:
    db        "px_sqrt"
    db        0
L6127:
    db        "px_sqr"
    db        0
L6126:
    db        "px_toboolt"
    db        0
L6125:
    db        "px_not"
    db        0
L6124:
    db        "px_bitnot"
    db        0
L6123:
    db        "px_abs"
    db        0
L6122:
    db        "px_neg"
    db        0
L6121:
    db        "px_jump"
    db        0
L6120:
    db        "px_widen"
    db        0
L6119:
    db        "px_eval"
    db        0
L6118:
    db        "px_div"
    db        0
L6117:
    db        "px_mul"
    db        0
L6116:
    db        "px_sub"
    db        0
L6115:
    db        "px_add"
    db        0
L6114:
    db        "px_store"
    db        0
L6113:
    db        "px_load"
    db        0
L6112:
    db        "px_label"
    db        0
L6111:
    db        "px_data"
    db        0
L6110:
    db        "px_zstatic"
    db        0
L6109:
    db        "px_istatic"
    db        0
L6108:
    db        "px_endprog"
    db        0
L6107:
    db        "px_endproc"
    db        0
L6106:
    db        "px_defproc"
    db        0
L6105:
    db        "px_comment"
    db        0
L6104:
    db        "px_type"
    db        0
L6103:
    db        "px_opnd"
    db        0
L6102:
    db        "px_double"
    db        0
L6101:
    db        "px_dupl"
    db        0
L6100:
    db        "px_nop"
    db        0
L6099:
    db        "do_addrmode"
    db        0
L6098:
    db        "main"
    db        0
L6097:
    db        "reloc?"
    db        0
L6096:
    db        "rel32/rel not imported"
    db        0
L6095:
    db        "0.1234"
    db        0
L6094:
    db        0
L6093:
    db        "No entry point found"
    db        0
L6092:
    db        "$cmdskip"
    db        0
L6091:
    db        0
L6090:
    db        "Too many Imports"
    db        0
L6089:
    db        0
L6088:
    db        "Too many DLLs"
    db        0
L6087:
    db        "Dupl symbol:"
    db        0
L6086:
    db        "Can't find #"
    db        0
L6085:
    db        "ml"
    db        0
L6084:
    db        "Loading sublib"
    db        0
L6083:
    db        0
L6082:
    db        "imprel32?"
    db        0
L6081:
    db        "Undef"
    db        0
L6080:
    db        "Can't find DLL: #"
    db        0
L6079:
    db        0
L6078:
    db        "Too many libs"
    db        0
L6077:
    db        "Lib already exists:"
    db        0
L6076:
    db        "Aborting"
    db        0
L6075:
    db        0
L6074:
    db        "Can't alloc code memory"
    db        0
L6073:
    db        "Unknown directive:"
    db        0
L6072:
    db        "Bad sig - not MCX file"
    db        0
L6070:
    db        "main"
    db        0
L6069:
    db        "reloc?"
    db        0
L6068:
    db        "rel32/rel not imported"
    db        0
L6067:
    db        "0.1234"
    db        0
L6065:
    db        "."
    db        0
L6064:
    db        "main"
    db        0
L6063:
    db        "W:too many strings"
    db        0
L6062:
    db        ".text"
    db        0
L6061:
    db        ".data"
    db        0
L6060:
    db        ".bss"
    db        0
L6059:
    db        ".file"
    db        0
L6058:
    db        "as:Too many symbols"
    db        0
L6057:
    db        "OBJ/phighmem 1?"
    db        0
L6056:
    db        "wrelocs/bad seg"
    db        0
L6055:
    db        "Writing file:"
    db        0
L6054:
    db        ".text"
    db        0
L6053:
    db        ".data"
    db        0
L6052:
    db        "Too many relocs (exceeds 16-bit field)"
    db        0
L6051:
    db        ".bss"
    db        0
L6050:
    db        "GSN"
    db        0
L6049:
    db        "Too many blocks"
    db        0
L6047:
    db        "Too many exports - can't sort"
    db        0
L6046:
    db        "Entry point not found: main"
    db        0
L6045:
    db        "User entry point not found"
    db        0
L6043:
    db        "Can't do this rel type"
    db        0
L6042:
    db        "RELOCDATA/SEG?"
    db        0
L6041:
    db        "rel32/not imported"
    db        0
L6040:
    db        "gendll: Too many exports"
    db        0
L6039:
    db        "main"
    db        0
L6038:
    db        "genexe: Too many imports"
    db        0
L6037:
    db        "2:Too many libs"
    db        0
L6036:
    db        ".dll"
    db        0
L6035:
    db        "Can't find external function"
    db        0
L6034:
    db        "Too many libs"
    db        0
L6033:
    db        ".dll"
    db        0
L6032:
    db        ".idata"
    db        0
L6031:
    db        ".bss"
    db        0
L6030:
    db        ".data"
    db        0
L6029:
    db        "10s,jr"
    db        0
L6028:
    db        "Zdata size:"
    db        0
L6027:
    db        "10s,jr"
    db        0
L6026:
    db        "Code+Idata:"
    db        0
L6025:
    db        "10s,jr"
    db        0
L6024:
    db        "Idata size:"
    db        0
L6023:
    db        "bytes"
    db        0
L6022:
    db        "10s,jr"
    db        0
L6021:
    db        "Code size: "
    db        0
L6020:
    db        ".text"
    db        0
L6019:
    db        "Can't load search lib"
    db        0
L6018:
    db        "File:"
    db        0
L6017:
    db        "Error writing exe file (possibly still running)"
    db        0
L6016:
    db        "10s,jr"
    db        0
L6015:
    db        "EXE size:  "
    db        0
L6014:
    db        0
L6013:
    db        "qword "
    db        0
L6012:
    db        "dword "
    db        0
L6011:
    db        "word "
    db        0
L6010:
    db        "byte "
    db        0
L6009:
    db        0
L6008:
    db        "#.$T#"
    db        0
L6007:
    db        "T"
    db        0
L6006:
    db        "R"
    db        0
L6005:
    db        "#.#"
    db        0
L6004:
    db        "XMM"
    db        0
L6003:
    db        "-"
    db        0
L6002:
    db        "sp"
    db        0
L6001:
    db        "fp"
    db        0
L6000:
    db        "-"
    db        0
L5999:
    db        0
L5998:
    db        "Stropnd?"
    db        0
L5997:
    db        "L"
    db        0
L5996:
    db        34
    db        0
L5995:
    db        "M"
    db        0
L5994:
    db        "20.20"
    db        0
L5993:
    db        0
L5992:
    db        "+"
    db        0
L5991:
    db        0
L5990:
    db        "<BAD OPND>"
    db        0
L5989:
    db        "BAD OPND"
    db        0
L5988:
    db        "]"
    db        0
L5987:
    db        " + "
    db        0
L5986:
    db        "rel "
    db        0
L5985:
    db        "*"
    db        0
L5984:
    db        " + "
    db        0
L5983:
    db        0
L5982:
    db        "["
    db        0
L5981:
    db        "M#"
    db        0
L5980:
    db        "H"
    db        0
L5979:
    db        "0x"
    db        0
L5978:
    db        ","
    db        0
L5977:
    db        ","
    db        9
    db        0
L5976:
    db        " "
    db        0
L5975:
    db        "  "
    db        0
L5974:
    db        " "
    db        0
L5973:
    db        "alignb"
    db        0
L5972:
    db        "movsxd"
    db        0
L5971:
    db        "imul"
    db        0
L5970:
    db        "not"
    db        0
L5969:
    db        "xor"
    db        0
L5968:
    db        "or"
    db        0
L5967:
    db        "and"
    db        0
L5966:
    db        "cmov"
    db        0
L5965:
    db        "set"
    db        0
L5964:
    db        "j"
    db        0
L5963:
    db        "    segment .bss"
    db        0
L5962:
    db        "    segment .data"
    db        0
L5961:
    db        "    segment .text"
    db        0
L5960:
    db        " "
    db        0
L5959:
    db        "   %define "
    db        0
L5958:
    db        " "
    db        0
L5957:
    db        "    %define "
    db        0
L5956:
    db        "L#:"
    db        0
L5955:
    db        ":"
    db        0
L5954:
    db        10
    db        0
L5953:
    db        ":"
    db        0
L5952:
    db        0
L5951:
    db        "strmcl/lab"
    db        0
L5950:
    db        "; <deleted>"
    db        0
L5949:
    db        ";End "
    db        0
L5948:
    db        ";Proc "
    db        0
L5947:
    db        10
    db        0
L5946:
    db        "    global "
    db        0
L5945:
    db        10
    db        0
L5944:
    db        "    extern "
    db        0
L5943:
    db        10
    db        0
L5942:
    db        "    extern pow"
    db        10
    db        0
L5941:
    db        "    extern ceil"
    db        10
    db        0
L5940:
    db        "    extern floor"
    db        10
    db        0
L5939:
    db        "    extern exp"
    db        10
    db        0
L5938:
    db        "    extern log10"
    db        10
    db        0
L5937:
    db        "    extern log"
    db        10
    db        0
L5936:
    db        "    extern atan"
    db        10
    db        0
L5935:
    db        "    extern acos"
    db        10
    db        0
L5934:
    db        "    extern asin"
    db        10
    db        0
L5933:
    db        "    extern tan"
    db        10
    db        0
L5932:
    db        "    extern cos"
    db        10
    db        0
L5931:
    db        "    extern sin"
    db        10
    db        0
L5930:
    db        "    extern fmod"
    db        10
    db        0
L5929:
    db        "    default rel"
    db        10
    db        0
L5928:
    db        ";NASM VERSION"
    db        10
    db        0
L5927:
    db        "PHIGHMEM="
    db        0
L5926:
    db        0
L5925:
    db        "MSA"
    db        0
L5924:
    db        0
L5923:
    db        "makeopndind"
    db        0
L5922:
    db        0
L5921:
    db        "SOR1"
    db        0
L5918:
    db        0
L5917:
    db        "movereg/reg in use"
    db        0
L5916:
    db        0
L5915:
    db        "No more work xregs"
    db        0
L5914:
    db        0
L5913:
    db        "No more work regs"
    db        0
L5912:
    db        "DUPLOP"
    db        0
L5911:
    db        0
L5910:
    db        "poppcl/underflow"
    db        0
L5909:
    db        0
L5908:
    db        "PCL stack overflow"
    db        0
L5907:
    db        0
L5906:
    db        "PCL stack overflow"
    db        0
L5905:
    db        "getopnd"
    db        0
L5904:
    db        "$B#"
    db        0
L5903:
    db        0
L5902:
    db        "Too many block temps"
    db        0
L5901:
    db        "AASEQ:"
    db        0
L5900:
    db        "AX ERROR:"
    db        0
L5899:
    db        "MCL Opnd not supported: # (#) [#]"
    db        0
L5898:
    db        "MCL Error: # (#) on Line: # in #, PCL:#"
    db        0
L5897:
    db        "?"
    db        0
L5896:
    db        "FILENAME="
    db        0
L5895:
    db        "LINENO="
    db        0
L5894:
    db        0
L5893:
    db        "2:SIZE=0"
    db        0
L5892:
    db        0
L5891:
    db        "1:SIZE=0"
    db        0
L5890:
    db        0
L5889:
    db        "BAD SEG CODE"
    db        0
L5888:
    db        0
L5887:
    db        "CAN'T DO RODATA SEG"
    db        0
L5886:
    db        "MCLREC>64B"
    db        0
L5885:
    db        "dshift/size"
    db        0
L5884:
    db        "bswap reg>"
    db        0
L5883:
    db        "fixrip disp?"
    db        0
L5882:
    db        "DISPSIZE="
    db        0
L5881:
    db        "movdq opnds"
    db        0
L5880:
    db        "movdq mem,?"
    db        0
L5879:
    db        "5:movdq size"
    db        0
L5878:
    db        "movdq xreg,?"
    db        0
L5877:
    db        "31:movdq size"
    db        0
L5876:
    db        "3:movdq size"
    db        0
L5875:
    db        "movdq reg,?"
    db        0
L5874:
    db        "1:movdq size"
    db        0
L5873:
    db        "float opnds"
    db        0
L5872:
    db        "fix opnds"
    db        0
L5871:
    db        "convertfloat opnds"
    db        0
L5870:
    db        "logicxmm opnds"
    db        0
L5869:
    db        "arithxmm opnds"
    db        0
L5868:
    db        "Wrong size"
    db        0
L5867:
    db        "A.SIZE="
    db        0
L5866:
    db        "Need size"
    db        0
L5865:
    db        "setcc opnd/size"
    db        0
L5864:
    db        "test opnds"
    db        0
L5863:
    db        "shift opnds2?"
    db        0
L5862:
    db        "cl or b10 needed"
    db        0
L5861:
    db        "shift/label"
    db        0
L5860:
    db        "shift opnds1?"
    db        0
L5859:
    db        "imul2 opnds"
    db        0
L5858:
    db        "mul/label"
    db        0
L5857:
    db        "imul2 size"
    db        0
L5856:
    db        "imul2 byte"
    db        0
L5855:
    db        "imul2 opnds"
    db        0
L5854:
    db        "movsxd opnds"
    db        0
L5853:
    db        "movsxd size"
    db        0
L5852:
    db        "exch size"
    db        0
L5851:
    db        "exch opnds"
    db        0
L5850:
    db        "exch size"
    db        0
L5849:
    db        "movsx not reg/mem"
    db        0
L5848:
    db        "movsx size 8"
    db        0
L5847:
    db        "movsx need size prefix"
    db        0
L5846:
    db        "movsx 4=>8 bytes?"
    db        0
L5845:
    db        "movsx size error"
    db        0
L5844:
    db        "movsx not reg"
    db        0
L5843:
    db        "LEA size error"
    db        0
L5842:
    db        "LEA not reg/mem"
    db        0
L5841:
    db        "neg/div/etc opnd?"
    db        0
L5840:
    db        "inc/opnd?"
    db        0
L5839:
    db        "pop opnd?"
    db        0
L5838:
    db        "pop not 64-bit"
    db        0
L5837:
    db        "popreg not 64-bit"
    db        0
L5836:
    db        "push opnd?"
    db        0
L5835:
    db        "push not 64-bit"
    db        0
L5834:
    db        "push imm value too large"
    db        0
L5833:
    db        "pushreg not 64-bit"
    db        0
L5832:
    db        "MOV ?/.."
    db        0
L5831:
    db        "MOV MEM/?"
    db        0
L5830:
    db        "mov imm?"
    db        0
L5829:
    db        "3:Opnd size mismatch"
    db        0
L5828:
    db        "MOV REG/??"
    db        0
L5827:
    db        "1:exceeding word32 value"
    db        0
L5826:
    db        "exceeding word16 value"
    db        0
L5825:
    db        "exceeding byte value"
    db        0
L5824:
    db        "mov imm?"
    db        0
L5823:
    db        "2:Opnd size mismatch"
    db        0
L5822:
    db        "B.SIZE="
    db        0
L5821:
    db        "A.SIZE="
    db        0
L5820:
    db        "1:Can't add to this opnd"
    db        0
L5819:
    db        "CODE="
    db        0
L5818:
    db        "ADD mem,???"
    db        0
L5817:
    db        "ADD reg,???"
    db        0
L5816:
    db        "Exceeding i8/u8 range"
    db        0
L5815:
    db        "add imm/size"
    db        0
L5814:
    db        "Addr32 can't use RIP, line"
    db        0
L5813:
    db        "Can't scale rstack"
    db        0
L5812:
    db        "Scaled rstack?"
    db        0
L5811:
    db        "genrm not mem"
    db        0
L5810:
    db        "2:exceeding word32 value"
    db        0
L5809:
    db        "exceeding word16 value"
    db        0
L5808:
    db        "exceeding byte value"
    db        0
L5807:
    db        "dbuffer error"
    db        0
L5806:
    db        "l#"
    db        0
L5805:
    db        "bsf size"
    db        0
L5804:
    db        "genrel8"
    db        0
L5803:
    db        "fmem int size"
    db        0
L5802:
    db        "fst i64?"
    db        0
L5801:
    db        "fmem size"
    db        0
L5800:
    db        "SIZE="
    db        0
L5799:
    db        "r80 not allowed"
    db        0
L5798:
    db        "fmem/not mem"
    db        0
L5797:
    db        "cmov/byte"
    db        0
L5796:
    db        "1:Opnd size mismatch"
    db        0
L5795:
    db        "jmp[]size"
    db        0
L5794:
    db        "call[]size"
    db        0
L5793:
    db        "Can't do jcxz fwd jump"
    db        0
L5792:
    db        "jcxz jmp out of range"
    db        0
L5791:
    db        "Can't do loopxx fwd jump"
    db        0
L5790:
    db        "loop jmp out of range"
    db        0
L5789:
    db        "Operand size not set"
    db        0
L5788:
    db        "genamode size 2/8"
    db        0
L5787:
    db        "GENAMODE/MODE?"
    db        0
L5786:
    db        "genam/3"
    db        0
L5785:
    db        "DOFWDREFS/CAN'T DO RELTYPE"
    db        0
L5784:
    db        "Fwd ref in zdata"
    db        0
L5783:
    db        "Rel label across segments2"
    db        0
L5782:
    db        "getdef/no def"
    db        0
L5781:
    db        "Rel label across segments"
    db        0
L5780:
    db        "OPND/8/VALTYPE?"
    db        0
L5779:
    db        "OPND/4/VALTYPE?"
    db        0
L5778:
    db        "8/16-BIT RELOC"
    db        0
L5777:
    db        "GENSS/NAME OPND"
    db        0
L5776:
    db        "STOPPING"
    db        0
L5775:
    db        "M_HALT="
    db        0
L5774:
    db        "M.OPCODE="
    db        0
L5773:
    db        "line"
    db        0
L5772:
    db        "*** Can't do opcode"
    db        0
L5771:
    db        "align?"
    db        0
L5770:
    db        "align2"
    db        0
L5769:
    db        "resb?"
    db        0
L5768:
    db        "retn?"
    db        0
L5767:
    db        "Zdata contains code or data"
    db        0
L5765:
    db        0
L5764:
    db        "SUBTOREF/EXTRA"
    db        0
L5763:
    db        "pow*"
    db        0
L5762:
    db        0
L5761:
    db        "setcc/block"
    db        0
L5760:
    db        "fmod*"
    db        0
L5759:
    db        "atan2*"
    db        0
L5758:
    db        "ceil*"
    db        0
L5757:
    db        "floor*"
    db        0
L5756:
    db        "round*"
    db        0
L5755:
    db        "exp*"
    db        0
L5754:
    db        "log10*"
    db        0
L5753:
    db        "log*"
    db        0
L5752:
    db        "atan*"
    db        0
L5751:
    db        "acos*"
    db        0
L5750:
    db        "asin*"
    db        0
L5749:
    db        "tan*"
    db        0
L5748:
    db        "cos*"
    db        0
L5747:
    db        "sin*"
    db        0
L5746:
    db        0
L5745:
    db        "No Assem handler"
    db        0
L5744:
    db        0
L5743:
    db        "SUB/REF NOT POWER OF xx"
    db        0
L5742:
    db        0
L5741:
    db        "float/short"
    db        0
L5740:
    db        0
L5739:
    db        "multo/byte"
    db        0
L5738:
    db        ":"
    db        0
L5737:
    db        0
L5736:
    db        "swap/block"
    db        0
L5735:
    db        0
L5734:
    db        "SUBREF/EXTRA"
    db        0
L5733:
    db        "EXTRA="
    db        0
L5731:
    db        "exit"
    db        0
L5729:
    db        0
L5728:
    db        "Too many nested calls"
    db        0
L5727:
    db        0
L5726:
    db        "JUMPCC/BLOCK"
    db        0
L5725:
    db        0
L5724:
    db        "DATA/not 1248"
    db        0
L5723:
    db        "STRPMODE(P.MODE)="
    db        0
L5722:
    db        "P.SIZE="
    db        0
L5721:
    db        "db/dq optype? #"
    db        0
L5720:
    db        "PCL STACK NOT EMPTY"
    db        0
L5719:
    db        "main"
    db        0
L5718:
    db        ">>"
    db        0
L5717:
    db        "Unimpl: # (#)"
    db        0
L5716:
    db        "                       "
    db        0
L5715:
    db        "Invalid handler name:"
    db        0
L5714:
    db        "px_"
    db        0
L5713:
    db        "********* ASM HAS PCL INFO *********"
    db        0
L5712:
    db        "__getmainargs*"
    db        0
L5711:
    db        "$info"
    db        0
L5710:
    db        "$env"
    db        0
L5709:
    db        "PCMDSKIP="
    db        0
L5708:
    db        "FIXMAIN"
    db        0
L5707:
    db        "()"
    db        0
L5706:
    db        "High block arg not copied in"
    db        0
L5705:
    db        "No host fn:"
    db        0
L5704:
    db        0
L5703:
    db        "gethostfn?"
    db        0
L5702:
    db        0
L5701:
    db        "storebf not imm"
    db        0
L5700:
    db        0
L5699:
    db        "STOREBIT/VAR"
    db        0
L5698:
    db        0
L5697:
    db        "LOADBF_VAR"
    db        0
L5695:
    db        "mask63/offset64"
    db        0
L5694:
    db        "labzero"
    db        0
L5693:
    db        "labneg64"
    db        0
L5692:
    db        "labneg32"
    db        0
L5691:
    db        "lababs64"
    db        0
L5690:
    db        "lababs32"
    db        0
L5688:
    db        "Real32 Table"
    db        0
L5686:
    db        "Real Table"
    db        0
L5685:
    db        "String Table"
    db        0
L5684:
    db        "ENDDATA"
    db        0
L5683:
    db        0
L5682:
    db        "div/u8"
    db        0
L5681:
    db        0
L5680:
    db        "Divide by zero"
    db        0
L5678:
    db        "---------------"
    db        0
L5677:
    db        0
L5676:
    db        "Threaded proc has spill regs"
    db        0
L5675:
    db        0
L5674:
    db        "Threaded proc has temps"
    db        0
L5673:
    db        0
L5672:
    db        "Threaded proc has locals/params"
    db        0
L5671:
    db        "$1x"
    db        0
L5670:
    db        "$cmdskip"
    db        0
L5669:
    db        "Can't load lib:"
    db        0
L5668:
    db        "Can't find DLL func:"
    db        0
L5667:
    db        "in"
    db        0
L5666:
    db        "Unsupported operand:"
    db        0
L5665:
    db        "seq:"
    db        0
L5664:
    db        "PC Exec error:"
    db        0
L5663:
    db        0
L5662:
    db        "Not mem"
    db        0
L5661:
    db        "Stopped"
    db        0
L5660:
    db        "Run PCL:"
    db        0
L5659:
    db        0
L5658:
    db        "No 'main' entry point"
    db        0
L5657:
    db        0
L5656:
    db        "data &mem = nil"
    db        0
L5655:
    db        0
L5654:
    db        "data &mem"
    db        0
L5653:
    db        0
L5652:
    db        "FIX/DATA/MEM"
    db        0
L5651:
    db        "Unimpl: # at seq: #"
    db        0
L5645:
    db        0
L5644:
    db        "swap/block"
    db        0
L5643:
    db        0
L5642:
    db        "setcc/r32"
    db        0
L5641:
    db        0
L5640:
    db        "setcc/r64"
    db        0
L5639:
    db        0
L5638:
    db        "ICALLF NIL PTR"
    db        0
L5637:
    db        0
L5636:
    db        "ICALLP NIL PTR"
    db        0
L5635:
    db        0
L5634:
    db        "RETF/SP mismatch: old=# curr=# "
    db        0
L5633:
    db        0
L5632:
    db        "ref/call underflow"
    db        0
L5631:
    db        0
L5630:
    db        "RETP/SP mismatch: old=# curr=# "
    db        0
L5629:
    db        0
L5628:
    db        "retp/call underflow"
    db        0
L5627:
    db        "Proc not defined:"
    db        0
L5626:
    db        "FP="
    db        0
L5625:
    db        "SP="
    db        0
L5624:
    db        "9JL"
    db        0
L5623:
    db        "z4"
    db        0
L5622:
    db        0
L5621:
    db        "Call Stack overflow"
    db        0
L5620:
    db        0
L5619:
    db        "Stack overflow"
    db        0
L5618:
    db        "LOW PC BITS NOT ZERO"
    db        0
L5617:
    db        " ncalldepth:"
    db        0
L5616:
    db        " noperands:"
    db        0
L5615:
    db        ") hwstack:"
    db        0
L5614:
    db        "0 "
    db        0
L5613:
    db        "1 "
    db        0
L5612:
    db        "XR:("
    db        0
L5611:
    db        ") "
    db        0
L5610:
    db        "0 "
    db        0
L5609:
    db        "1 "
    db        0
L5608:
    db        "R:("
    db        0
L5607:
    db        " "
    db        0
L5606:
    db        ") "
    db        0
L5605:
    db        ", "
    db        0
L5604:
    db        ">"
    db        0
L5603:
    db        "<"
    db        0
L5602:
    db        "+"
    db        0
L5601:
    db        ")"
    db        0
L5600:
    db        "("
    db        0
L5599:
    db        "T"
    db        0
L5598:
    db        0
L5597:
    db        "W:"
    db        0
L5596:
    db        "X:"
    db        0
L5595:
    db        "Y:"
    db        0
L5594:
    db        "Z:"
    db        0
L5593:
    db        "#:("
    db        0
L5592:
    db        "========================================#:("
    db        0
L5591:
    db        " Seg:"
    db        0
L5590:
    db        " TC"
    db        0
L5589:
    db        " Imp"
    db        0
L5588:
    db        " Exp"
    db        0
L5587:
    db        " Pm:# Loc:#"
    db        0
L5586:
    db        "25jl"
    db        0
L5585:
    db        " "
    db        0
L5584:
    db        ":"
    db        0
L5583:
    db        "4"
    db        0
L5582:
    db        "PROC PC Symbol table"
    db        0
L5581:
    db        "wb"
    db        0
L5580:
    db        "PSYMTAB"
    db        0
L5579:
    db        "."
    db        0
L5578:
    db        "z2h"
    db        0
L5577:
    db        " "
    db        0
L5576:
    db        "  "
    db        0
L5575:
    db        "    data mem:"
    db        0
L5574:
    db        " "
    db        0
L5573:
    db        ":"
    db        0
L5572:
    db        "L"
    db        0
L5571:
    db        " "
    db        0
L5570:
    db        "<PCLOPND?>"
    db        0
L5569:
    db        "<Data * # (#)>"
    db        0
L5568:
    db        0
L5567:
    db        "L# "
    db        0
L5566:
    db        "&"
    db        0
L5565:
    db        ":"
    db        0
L5564:
    db        "<LONGSTR>"
    db        0
L5563:
    db        34
    db        0
L5562:
    db        "IMM"
    db        0
L5561:
    db        "e16.16"
    db        0
L5560:
    db        "h"
    db        0
L5559:
    db        "0x#"
    db        0
L5557:
    db        0
L5556:
    db        10
    db        0
L5555:
    db        ")"
    db        0
L5554:
    db        " "
    db        0
L5553:
    db        " ("
    db        0
L5552:
    db        "---"
    db        0
L5551:
    db        "/"
    db        0
L5550:
    db        " "
    db        0
L5549:
    db        "set"
    db        0
L5548:
    db        "/1"
    db        0
L5547:
    db        "jump"
    db        0
L5546:
    db        "    "
    db        0
L5545:
    db        "endprog"
    db        0
L5544:
    db        "endproc"
    db        0
L5543:
    db        " "
    db        0
L5542:
    db        "    "
    db        0
L5541:
    db        "       "
    db        0
L5540:
    db        ":"
    db        0
L5539:
    db        "::"
    db        0
L5538:
    db        ")"
    db        0
L5537:
    db        ", "
    db        0
L5536:
    db        " "
    db        0
L5535:
    db        "("
    db        0
L5534:
    db        " "
    db        0
L5533:
    db        "proc"
    db        0
L5532:
    db        "tcproc"
    db        0
L5531:
    db        "!"
    db        0
L5530:
    db        ":"
    db        0
L5529:
    db        "! "
    db        0
L5528:
    db        "  "
    db        0
L5527:
    db        "z5"
    db        0
L5526:
    db        "No proc"
    db        0
L5525:
    db        "main"
    db        0
L5524:
    db        "Dupl proc:"
    db        0
L5523:
    db        "Nested proc"
    db        0
L5522:
    db        "Too many libs"
    db        0
L5521:
    db        "w"
    db        0
L5520:
    db        "$error.tmp"
    db        0
L5519:
    db        "."
    db        0
L5518:
    db        "`"
    db        0
L5517:
    db        "*"
    db        0
L5516:
    db        "`"
    db        0
L5515:
    db        "PCL Error:"
    db        0
L5514:
    db        ":"
    db        0
L5513:
    db        "PCL error:"
    db        0
L5512:
    db        "---"
    db        0
L5511:
    db        "blk:"
    db        0
L5510:
    db        0
L5509:
    db        "dummy"
    db        0
L5508:
    db        "w"
    db        0
L5507:
    db        "Writing"
    db        0
L5506:
    db        0
L5505:
    db        "Writing PCL"
    db        0
L5504:
    db        "PCL start?"
    db        0
L5503:
    db        "C:"
    db        92
    db        "m"
    db        92
    db        0
L5502:
    db        "wb"
    db        0
L5501:
    db        "con"
    db        0
L5500:
    db        "rb"
    db        0
L5499:
    db        "con"
    db        0
L5498:
    db        "W64"
    db        0
L5497:
    db        "Regclass error: %lld %lld"
    db        10
    db        0
L5495:
    db        "pcc001"
    db        0
L5493:
    db        "Winexec error: %lld"
    db        10
    db        0
L5489:
    db        "@file item too long"
    db        0
L5488:
    db        "Unexpected EOF in @file"
    db        0
L5487:
    db        "mcx"
    db        0
L5486:
    db        "dll"
    db        0
L5485:
    db        "Can't open"
    db        0
L5484:
    db        13
    db        0
L5483:
    db        13
    db        10
    db        0
L5482:
    db        " "
    db        0
L5481:
    db        0
L5480:
    db        "."
    db        0
L5479:
    db        0
L5478:
    db        "."
    db        0
L5477:
    db        "line too long"
    db        0
L5476:
    db        "rb"
    db        0
L5475:
    db        "wb"
    db        0
L5474:
    db        "rb"
    db        0
L5473:
    db        "ABORTING: Press key..."
    db        0
L5472:
    db        "Realloc mem failure"
    db        0
L5471:
    db        "Alloc mem failure"
    db        0
L5470:
    db        "Can't alloc pc heap"
    db        0
L5469:
    db        "pcm_alloc failure"
    db        0
L5462:
    db        "%.*s"
    db        0
L5461:
    db        "MCL-UNIMPL: %s"
    db        10
    db        0
L5459:
    db        "%lf%n"
    db        0
L5457:
    db        "READ CMDLINE"
    db        0
L5455:
    db        "<mindint>"
    db        0
L5454:
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        0
L5453:
    db        "8000000000000000"
    db        0
L5452:
    db        "9223372036854775808"
    db        0
L5451:
    db        "|"
    db        0
L5450:
    db        "%.*s"
    db        0
L5449:
    db        " "
    db        0
L5448:
    db        13
    db        10
    db        0
L5447:
    db        "FORMATED PRINT SLICE NOT READY"
    db        0
L5446:
    db        "<null>"
    db        0
L5445:
    db        "%f"
    db        0
L5444:
    db        "%llu"
    db        0
L5443:
    db        "False"
    db        0
L5442:
    db        "True"
    db        0
L5441:
    db        "z8H"
    db        0
L5440:
    db        "Too many io levels"
    db        10
    db        0
L5439:
    db        "Too many params"
    db        10
    db        0
L5438:
    db        "impdata_rseg"
    db        0
L5437:
    db        "rodata_rseg"
    db        0
L5436:
    db        "zdata_rseg"
    db        0
L5435:
    db        "idata_rseg"
    db        0
L5434:
    db        "code_rseg"
    db        0
L5433:
    db        "no_seg"
    db        0
L5432:
    db        "imprel32"
    db        0
L5431:
    db        "impabs64"
    db        0
L5430:
    db        "impabs32"
    db        0
L5429:
    db        "locabs64"
    db        0
L5428:
    db        "locabs32"
    db        0
L5427:
    db        "no_rel"
    db        0
L5426:
    db        "end_dir"
    db        0
L5425:
    db        "entry_dir"
    db        0
L5424:
    db        "exportoffsets_dir"
    db        0
L5423:
    db        "exportsegs_dir"
    db        0
L5422:
    db        "exportsymbols_dir"
    db        0
L5421:
    db        "importsymbols_dir"
    db        0
L5420:
    db        "libs_dir"
    db        0
L5419:
    db        "dlls_dir"
    db        0
L5418:
    db        "reloc_dir"
    db        0
L5417:
    db        "zdata_dir"
    db        0
L5416:
    db        "idata_dir"
    db        0
L5415:
    db        "code_dir"
    db        0
L5414:
    db        "version_dir"
    db        0
L5413:
    db        "pad_dir"
    db        0
L5412:
    db        "N"
    db        0
L5411:
    db        "Q"
    db        0
L5410:
    db        0
L5409:
    db        "D"
    db        0
L5408:
    db        0
L5407:
    db        "A"
    db        0
L5406:
    db        0
L5405:
    db        "W"
    db        0
L5404:
    db        "B"
    db        0
L5403:
    db        "rel8_rel"
    db        0
L5402:
    db        "rel321_rel"
    db        0
L5401:
    db        "rel32_rel"
    db        0
L5400:
    db        "addr32nb_rel"
    db        0
L5399:
    db        "addr32_rel"
    db        0
L5398:
    db        "addr64_rel"
    db        0
L5397:
    db        "abs_rel"
    db        0
L5396:
    db        "xr15"
    db        0
L5395:
    db        "xr14"
    db        0
L5394:
    db        "xr13"
    db        0
L5393:
    db        "xr12"
    db        0
L5392:
    db        "xr11"
    db        0
L5391:
    db        "xr10"
    db        0
L5390:
    db        "xr9"
    db        0
L5389:
    db        "xr8"
    db        0
L5388:
    db        "xr7"
    db        0
L5387:
    db        "xr6"
    db        0
L5386:
    db        "xr5"
    db        0
L5385:
    db        "xr4"
    db        0
L5384:
    db        "xr3"
    db        0
L5383:
    db        "xr2"
    db        0
L5382:
    db        "xr1"
    db        0
L5381:
    db        "xr0"
    db        0
L5380:
    db        "xnone"
    db        0
L5379:
    db        "temp"
    db        0
L5378:
    db        "reg"
    db        0
L5377:
    db        "pend"
    db        0
L5376:
    db        "regmem_cat"
    db        0
L5375:
    db        "mem_cat"
    db        0
L5374:
    db        "ireg_cat"
    db        0
L5373:
    db        "reg_cat"
    db        0
L5372:
    db        "imm_cat"
    db        0
L5371:
    db        "no_cat"
    db        0
L5370:
    db        "a_xreg"
    db        0
L5369:
    db        "a_cond"
    db        0
L5368:
    db        "a_mem"
    db        0
L5367:
    db        "a_imm"
    db        0
L5366:
    db        "a_reg"
    db        0
L5365:
    db        "a_none"
    db        0
L5364:
    db        "back_ref"
    db        0
L5363:
    db        "fwd_ref"
    db        0
L5362:
    db        "extern_ref"
    db        0
L5361:
    db        "impdata_seg"
    db        0
L5360:
    db        "rodata_seg"
    db        0
L5359:
    db        "zdata_seg"
    db        0
L5358:
    db        "idata_seg"
    db        0
L5357:
    db        "code_seg"
    db        0
L5356:
    db        "no_seg"
    db        0
L5355:
    db        "cmovg"
    db        0
L5354:
    db        "cmovle"
    db        0
L5353:
    db        "cmovge"
    db        0
L5352:
    db        "cmovl"
    db        0
L5351:
    db        "cmovnp"
    db        0
L5350:
    db        "cmovp"
    db        0
L5349:
    db        "cmovns"
    db        0
L5348:
    db        "cmovs"
    db        0
L5347:
    db        "cmova"
    db        0
L5346:
    db        "cmovbe"
    db        0
L5345:
    db        "cmovnz"
    db        0
L5344:
    db        "cmovz"
    db        0
L5343:
    db        "cmovae"
    db        0
L5342:
    db        "cmovb"
    db        0
L5341:
    db        "cmovno"
    db        0
L5340:
    db        "cmovo"
    db        0
L5339:
    db        "setg"
    db        0
L5338:
    db        "setle"
    db        0
L5337:
    db        "setge"
    db        0
L5336:
    db        "setl"
    db        0
L5335:
    db        "setnp"
    db        0
L5334:
    db        "setp"
    db        0
L5333:
    db        "setns"
    db        0
L5332:
    db        "sets"
    db        0
L5331:
    db        "seta"
    db        0
L5330:
    db        "setbe"
    db        0
L5329:
    db        "setnz"
    db        0
L5328:
    db        "setz"
    db        0
L5327:
    db        "setae"
    db        0
L5326:
    db        "setb"
    db        0
L5325:
    db        "setno"
    db        0
L5324:
    db        "seto"
    db        0
L5323:
    db        "jnc"
    db        0
L5322:
    db        "jc"
    db        0
L5321:
    db        "jg"
    db        0
L5320:
    db        "jle"
    db        0
L5319:
    db        "jge"
    db        0
L5318:
    db        "jl"
    db        0
L5317:
    db        "jnp"
    db        0
L5316:
    db        "jp"
    db        0
L5315:
    db        "jns"
    db        0
L5314:
    db        "js"
    db        0
L5313:
    db        "ja"
    db        0
L5312:
    db        "jbe"
    db        0
L5311:
    db        "jnz"
    db        0
L5310:
    db        "jz"
    db        0
L5309:
    db        "jae"
    db        0
L5308:
    db        "jb"
    db        0
L5307:
    db        "jno"
    db        0
L5306:
    db        "jo"
    db        0
L5305:
    db        "mmx7"
    db        0
L5304:
    db        "mmx6"
    db        0
L5303:
    db        "mmx5"
    db        0
L5302:
    db        "mmx4"
    db        0
L5301:
    db        "mmx3"
    db        0
L5300:
    db        "mmx2"
    db        0
L5299:
    db        "mmx1"
    db        0
L5298:
    db        "mmx0"
    db        0
L5297:
    db        "st7"
    db        0
L5296:
    db        "st6"
    db        0
L5295:
    db        "st5"
    db        0
L5294:
    db        "st4"
    db        0
L5293:
    db        "st3"
    db        0
L5292:
    db        "st2"
    db        0
L5291:
    db        "st1"
    db        0
L5290:
    db        "st0"
    db        0
L5289:
    db        "xmm15"
    db        0
L5288:
    db        "xmm14"
    db        0
L5287:
    db        "xmm13"
    db        0
L5286:
    db        "xmm12"
    db        0
L5285:
    db        "xmm11"
    db        0
L5284:
    db        "xmm10"
    db        0
L5283:
    db        "xmm9"
    db        0
L5282:
    db        "xmm8"
    db        0
L5281:
    db        "xmm7"
    db        0
L5280:
    db        "xmm6"
    db        0
L5279:
    db        "xmm5"
    db        0
L5278:
    db        "xmm4"
    db        0
L5277:
    db        "xmm3"
    db        0
L5276:
    db        "xmm2"
    db        0
L5275:
    db        "xmm1"
    db        0
L5274:
    db        "xmm0"
    db        0
L5273:
    db        "r15b"
    db        0
L5272:
    db        "r14b"
    db        0
L5271:
    db        "r13b"
    db        0
L5270:
    db        "r12b"
    db        0
L5269:
    db        "r11b"
    db        0
L5268:
    db        "r10b"
    db        0
L5267:
    db        "r9b"
    db        0
L5266:
    db        "r8b"
    db        0
L5265:
    db        "spl"
    db        0
L5264:
    db        "bpl"
    db        0
L5263:
    db        "dil"
    db        0
L5262:
    db        "sil"
    db        0
L5261:
    db        "dh"
    db        0
L5260:
    db        "ch"
    db        0
L5259:
    db        "bh"
    db        0
L5258:
    db        "ah"
    db        0
L5257:
    db        "dl"
    db        0
L5256:
    db        "cl"
    db        0
L5255:
    db        "bl"
    db        0
L5254:
    db        "al"
    db        0
L5253:
    db        "r15w"
    db        0
L5252:
    db        "r14w"
    db        0
L5251:
    db        "r13w"
    db        0
L5250:
    db        "r12w"
    db        0
L5249:
    db        "r11w"
    db        0
L5248:
    db        "r10w"
    db        0
L5247:
    db        "r9w"
    db        0
L5246:
    db        "r8w"
    db        0
L5245:
    db        "sp"
    db        0
L5244:
    db        "bp"
    db        0
L5243:
    db        "di"
    db        0
L5242:
    db        "si"
    db        0
L5241:
    db        "dx"
    db        0
L5240:
    db        "cx"
    db        0
L5239:
    db        "bx"
    db        0
L5238:
    db        "ax"
    db        0
L5237:
    db        "r15d"
    db        0
L5236:
    db        "r14d"
    db        0
L5235:
    db        "r13d"
    db        0
L5234:
    db        "r12d"
    db        0
L5233:
    db        "r11d"
    db        0
L5232:
    db        "r10d"
    db        0
L5231:
    db        "r9d"
    db        0
L5230:
    db        "r8d"
    db        0
L5229:
    db        "esp"
    db        0
L5228:
    db        "ebp"
    db        0
L5227:
    db        "edi"
    db        0
L5226:
    db        "esi"
    db        0
L5225:
    db        "edx"
    db        0
L5224:
    db        "ecx"
    db        0
L5223:
    db        "ebx"
    db        0
L5222:
    db        "eax"
    db        0
L5221:
    db        "r15"
    db        0
L5220:
    db        "r14"
    db        0
L5219:
    db        "r13"
    db        0
L5218:
    db        "r12"
    db        0
L5217:
    db        "r11"
    db        0
L5216:
    db        "r10"
    db        0
L5215:
    db        "r9"
    db        0
L5214:
    db        "r8"
    db        0
L5213:
    db        "rsp"
    db        0
L5212:
    db        "rbp"
    db        0
L5211:
    db        "rdi"
    db        0
L5210:
    db        "rsi"
    db        0
L5209:
    db        "rdx"
    db        0
L5208:
    db        "rcx"
    db        0
L5207:
    db        "rbx"
    db        0
L5206:
    db        "rax"
    db        0
L5205:
    db        "_b20"
    db        0
L5204:
    db        "b19"
    db        0
L5203:
    db        "b18"
    db        0
L5202:
    db        "b17"
    db        0
L5201:
    db        "b16"
    db        0
L5200:
    db        "b15"
    db        0
L5199:
    db        "b14"
    db        0
L5198:
    db        "b13"
    db        0
L5197:
    db        "b12"
    db        0
L5196:
    db        "b11"
    db        0
L5195:
    db        "b10"
    db        0
L5194:
    db        "b9"
    db        0
L5193:
    db        "b8"
    db        0
L5192:
    db        "b7"
    db        0
L5191:
    db        "b6"
    db        0
L5190:
    db        "b5"
    db        0
L5189:
    db        "b4"
    db        0
L5188:
    db        "b3"
    db        0
L5187:
    db        "b2"
    db        0
L5186:
    db        "b1"
    db        0
L5185:
    db        "b0"
    db        0
L5184:
    db        "w15"
    db        0
L5183:
    db        "w14"
    db        0
L5182:
    db        "w13"
    db        0
L5181:
    db        "w12"
    db        0
L5180:
    db        "w11"
    db        0
L5179:
    db        "w10"
    db        0
L5178:
    db        "w9"
    db        0
L5177:
    db        "w8"
    db        0
L5176:
    db        "w7"
    db        0
L5175:
    db        "w6"
    db        0
L5174:
    db        "w5"
    db        0
L5173:
    db        "w4"
    db        0
L5172:
    db        "w3"
    db        0
L5171:
    db        "w2"
    db        0
L5170:
    db        "w1"
    db        0
L5169:
    db        "w0"
    db        0
L5168:
    db        "a15"
    db        0
L5167:
    db        "a14"
    db        0
L5166:
    db        "a13"
    db        0
L5165:
    db        "a12"
    db        0
L5164:
    db        "a11"
    db        0
L5163:
    db        "a10"
    db        0
L5162:
    db        "a9"
    db        0
L5161:
    db        "a8"
    db        0
L5160:
    db        "a7"
    db        0
L5159:
    db        "a6"
    db        0
L5158:
    db        "a5"
    db        0
L5157:
    db        "a4"
    db        0
L5156:
    db        "a3"
    db        0
L5155:
    db        "a2"
    db        0
L5154:
    db        "a1"
    db        0
L5153:
    db        "a0"
    db        0
L5152:
    db        "d15"
    db        0
L5151:
    db        "d14"
    db        0
L5150:
    db        "d13"
    db        0
L5149:
    db        "d12"
    db        0
L5148:
    db        "d11"
    db        0
L5147:
    db        "d10"
    db        0
L5146:
    db        "d9"
    db        0
L5145:
    db        "d8"
    db        0
L5144:
    db        "d7"
    db        0
L5143:
    db        "d6"
    db        0
L5142:
    db        "d5"
    db        0
L5141:
    db        "d4"
    db        0
L5140:
    db        "d3"
    db        0
L5139:
    db        "d2"
    db        0
L5138:
    db        "d1"
    db        0
L5137:
    db        "d0"
    db        0
L5136:
    db        "a"
    db        0
L5135:
    db        "be"
    db        0
L5134:
    db        "ae"
    db        0
L5133:
    db        "b"
    db        0
L5132:
    db        "g"
    db        0
L5131:
    db        "le"
    db        0
L5130:
    db        "ge"
    db        0
L5129:
    db        "l"
    db        0
L5128:
    db        "np"
    db        0
L5127:
    db        "p"
    db        0
L5126:
    db        "ns"
    db        0
L5125:
    db        "s"
    db        0
L5124:
    db        "a"
    db        0
L5123:
    db        "be"
    db        0
L5122:
    db        "nz"
    db        0
L5121:
    db        "z"
    db        0
L5120:
    db        "ae"
    db        0
L5119:
    db        "b"
    db        0
L5118:
    db        "no"
    db        0
L5117:
    db        "o"
    db        0
L5116:
    db        "fgt"
    db        0
L5115:
    db        "fle"
    db        0
L5114:
    db        "fge"
    db        0
L5113:
    db        "flt"
    db        0
L5112:
    db        "gt"
    db        0
L5111:
    db        "le"
    db        0
L5110:
    db        "ge"
    db        0
L5109:
    db        "lt"
    db        0
L5108:
    db        "np"
    db        0
L5107:
    db        "p"
    db        0
L5106:
    db        "ns"
    db        0
L5105:
    db        "s"
    db        0
L5104:
    db        "gtu"
    db        0
L5103:
    db        "leu"
    db        0
L5102:
    db        "ne"
    db        0
L5101:
    db        "eq"
    db        0
L5100:
    db        "geu"
    db        0
L5099:
    db        "ltu"
    db        0
L5098:
    db        "nov"
    db        0
L5097:
    db        "ov"
    db        0
L5096:
    db        "r19"
    db        0
L5095:
    db        "r18"
    db        0
L5094:
    db        "r17"
    db        0
L5093:
    db        "r16"
    db        0
L5092:
    db        "r15"
    db        0
L5091:
    db        "r14"
    db        0
L5090:
    db        "r13"
    db        0
L5089:
    db        "r12"
    db        0
L5088:
    db        "r11"
    db        0
L5087:
    db        "r10"
    db        0
L5086:
    db        "r9"
    db        0
L5085:
    db        "r8"
    db        0
L5084:
    db        "r7"
    db        0
L5083:
    db        "r6"
    db        0
L5082:
    db        "r5"
    db        0
L5081:
    db        "r4"
    db        0
L5080:
    db        "r3"
    db        0
L5079:
    db        "r2"
    db        0
L5078:
    db        "r1"
    db        0
L5077:
    db        "r0"
    db        0
L5076:
    db        "rnone"
    db        0
L5075:
    db        "m_halt"
    db        0
L5074:
    db        "m_cpuid"
    db        0
L5073:
    db        "m_fldln2"
    db        0
L5072:
    db        "m_fldlg2"
    db        0
L5071:
    db        "m_fld2e"
    db        0
L5070:
    db        "m_fld2t"
    db        0
L5069:
    db        "m_fldpi"
    db        0
L5068:
    db        "m_fld1"
    db        0
L5067:
    db        "m_fldz"
    db        0
L5066:
    db        "m_finit"
    db        0
L5065:
    db        "m_bswap"
    db        0
L5064:
    db        "m_popcnt"
    db        0
L5063:
    db        "m_rdtsc"
    db        0
L5062:
    db        "m_cmpsq"
    db        0
L5061:
    db        "m_cmpsd"
    db        0
L5060:
    db        "m_cmpsw"
    db        0
L5059:
    db        "m_cmpsb"
    db        0
L5058:
    db        "m_jrcxz"
    db        0
L5057:
    db        "m_jecxz"
    db        0
L5056:
    db        "m_loopcx"
    db        0
L5055:
    db        "m_loopz"
    db        0
L5054:
    db        "m_loopnz"
    db        0
L5053:
    db        "m_xlat"
    db        0
L5052:
    db        "m_resq"
    db        0
L5051:
    db        "m_resd"
    db        0
L5050:
    db        "m_resw"
    db        0
L5049:
    db        "m_resb"
    db        0
L5048:
    db        "m_align"
    db        0
L5047:
    db        "m_csegment"
    db        0
L5046:
    db        "m_zsegment"
    db        0
L5045:
    db        "m_isegment"
    db        0
L5044:
    db        "m_dq"
    db        0
L5043:
    db        "m_dd"
    db        0
L5042:
    db        "m_dw"
    db        0
L5041:
    db        "m_db"
    db        0
L5040:
    db        "m_maxsd"
    db        0
L5039:
    db        "m_minsd"
    db        0
L5038:
    db        "m_maxss"
    db        0
L5037:
    db        "m_minss"
    db        0
L5036:
    db        "m_fchs"
    db        0
L5035:
    db        "m_fabs"
    db        0
L5034:
    db        "m_fpatan"
    db        0
L5033:
    db        "m_fptan"
    db        0
L5032:
    db        "m_fsincos"
    db        0
L5031:
    db        "m_fcos"
    db        0
L5030:
    db        "m_fsin"
    db        0
L5029:
    db        "m_fsqrt"
    db        0
L5028:
    db        "m_fdiv"
    db        0
L5027:
    db        "m_fmul"
    db        0
L5026:
    db        "m_fsub"
    db        0
L5025:
    db        "m_fadd"
    db        0
L5024:
    db        "m_fistp"
    db        0
L5023:
    db        "m_fist"
    db        0
L5022:
    db        "m_fild"
    db        0
L5021:
    db        "m_fstp"
    db        0
L5020:
    db        "m_fst"
    db        0
L5019:
    db        "m_fld"
    db        0
L5018:
    db        "m_pcmpistrm"
    db        0
L5017:
    db        "m_pcmpistri"
    db        0
L5016:
    db        "m_movdqu"
    db        0
L5015:
    db        "m_movdqa"
    db        0
L5014:
    db        "m_cvtss2sd"
    db        0
L5013:
    db        "m_cvtsd2ss"
    db        0
L5012:
    db        "m_cvtsi2sd"
    db        0
L5011:
    db        "m_cvtsi2ss"
    db        0
L5010:
    db        "m_cvttsd2si"
    db        0
L5009:
    db        "m_cvttss2si"
    db        0
L5008:
    db        "m_cvtsd2si"
    db        0
L5007:
    db        "m_cvtss2si"
    db        0
L5006:
    db        "m_pand"
    db        0
L5005:
    db        "m_pxor"
    db        0
L5004:
    db        "m_andpd"
    db        0
L5003:
    db        "m_andps"
    db        0
L5002:
    db        "m_xorpd"
    db        0
L5001:
    db        "m_xorps"
    db        0
L5000:
    db        "m_comisd"
    db        0
L4999:
    db        "m_comiss"
    db        0
L4998:
    db        "m_divsd"
    db        0
L4997:
    db        "m_divss"
    db        0
L4996:
    db        "m_mulsd"
    db        0
L4995:
    db        "m_mulss"
    db        0
L4994:
    db        "m_subsd"
    db        0
L4993:
    db        "m_subss"
    db        0
L4992:
    db        "m_addsd"
    db        0
L4991:
    db        "m_addss"
    db        0
L4990:
    db        "m_sqrtsd"
    db        0
L4989:
    db        "m_sqrtss"
    db        0
L4988:
    db        "m_shrd"
    db        0
L4987:
    db        "m_shld"
    db        0
L4986:
    db        "m_bsr"
    db        0
L4985:
    db        "m_bsf"
    db        0
L4984:
    db        "m_setcc"
    db        0
L4983:
    db        "m_cqo"
    db        0
L4982:
    db        "m_cdq"
    db        0
L4981:
    db        "m_cwd"
    db        0
L4980:
    db        "m_cbw"
    db        0
L4979:
    db        "m_dec"
    db        0
L4978:
    db        "m_inc"
    db        0
L4977:
    db        "m_notx"
    db        0
L4976:
    db        "m_neg"
    db        0
L4975:
    db        "m_rcr"
    db        0
L4974:
    db        "m_rcl"
    db        0
L4973:
    db        "m_ror"
    db        0
L4972:
    db        "m_rol"
    db        0
L4971:
    db        "m_shr"
    db        0
L4970:
    db        "m_sar"
    db        0
L4969:
    db        "m_shl"
    db        0
L4968:
    db        "m_cmp"
    db        0
L4967:
    db        "m_test"
    db        0
L4966:
    db        "m_xorx"
    db        0
L4965:
    db        "m_orx"
    db        0
L4964:
    db        "m_andx"
    db        0
L4963:
    db        "m_div"
    db        0
L4962:
    db        "m_idiv"
    db        0
L4961:
    db        "m_imul3"
    db        0
L4960:
    db        "m_imul2"
    db        0
L4959:
    db        "m_mul"
    db        0
L4958:
    db        "m_imul"
    db        0
L4957:
    db        "m_sbb"
    db        0
L4956:
    db        "m_adc"
    db        0
L4955:
    db        "m_sub"
    db        0
L4954:
    db        "m_add"
    db        0
L4953:
    db        "m_xchg"
    db        0
L4952:
    db        "m_jmpcc"
    db        0
L4951:
    db        "m_jmp"
    db        0
L4950:
    db        "m_retn"
    db        0
L4949:
    db        "m_leave"
    db        0
L4948:
    db        "m_ret"
    db        0
L4947:
    db        "m_call"
    db        0
L4946:
    db        "m_movsxd"
    db        0
L4945:
    db        "m_movzx"
    db        0
L4944:
    db        "m_movsx"
    db        0
L4943:
    db        "m_movq"
    db        0
L4942:
    db        "m_movd"
    db        0
L4941:
    db        "m_cmovcc"
    db        0
L4940:
    db        "m_lea"
    db        0
L4939:
    db        "m_pop"
    db        0
L4938:
    db        "m_push"
    db        0
L4937:
    db        "m_mov"
    db        0
L4936:
    db        "m_param"
    db        0
L4935:
    db        "m_nop"
    db        0
L4934:
    db        "m_labelx"
    db        0
L4933:
    db        "m_definereg"
    db        0
L4932:
    db        "m_define"
    db        0
L4931:
    db        "m_labelname"
    db        0
L4930:
    db        "m_deleted"
    db        0
L4929:
    db        "m_blank"
    db        0
L4928:
    db        "m_comment"
    db        0
L4927:
    db        "m_procend"
    db        0
L4926:
    db        "m_procstart"
    db        0
L4925:
    db        "temp_val"
    db        0
L4924:
    db        "name_val"
    db        0
L4923:
    db        "label_val"
    db        0
L4922:
    db        "def_val"
    db        0
L4921:
    db        "stringimm_val"
    db        0
L4920:
    db        "realmem_val"
    db        0
L4919:
    db        "realimm_val"
    db        0
L4918:
    db        "intimm_val"
    db        0
L4917:
    db        "no_val"
    db        0
L4916:
    db        "Export"
    db        0
L4915:
    db        "Label"
    db        0
L4914:
    db        "Param"
    db        0
L4913:
    db        "Local"
    db        0
L4912:
    db        "Static"
    db        0
L4911:
    db        "Proc"
    db        0
L4910:
    db        "Import"
    db        0
L4909:
    db        "--"
    db        0
L4908:
    db        "gt"
    db        0
L4907:
    db        "ge"
    db        0
L4906:
    db        "le"
    db        0
L4905:
    db        "lt"
    db        0
L4904:
    db        "ne"
    db        0
L4903:
    db        "eq"
    db        0
L4902:
    db        "xx"
    db        0
L4901:
    db        "sliceptr"
    db        0
L4900:
    db        "slicelen"
    db        0
L4899:
    db        "sliceupb"
    db        0
L4898:
    db        "storesld"
    db        0
L4897:
    db        "storesl"
    db        0
L4896:
    db        "endprog"
    db        0
L4895:
    db        "comment"
    db        0
L4894:
    db        "eval"
    db        0
L4893:
    db        "loadall"
    db        0
L4892:
    db        "setarg"
    db        0
L4891:
    db        "setcall"
    db        0
L4890:
    db        "longjmp"
    db        0
L4889:
    db        "setjmp"
    db        0
L4888:
    db        "labeldef"
    db        0
L4887:
    db        "label"
    db        0
L4886:
    db        "data"
    db        0
L4885:
    db        "zstatic"
    db        0
L4884:
    db        "istatic"
    db        0
L4883:
    db        "endproc"
    db        0
L4882:
    db        "tcproc"
    db        0
L4881:
    db        "defproc"
    db        0
L4880:
    db        "endmx"
    db        0
L4879:
    db        "resetmx"
    db        0
L4878:
    db        "startmx"
    db        0
L4877:
    db        "fnarrow"
    db        0
L4876:
    db        "fwiden"
    db        0
L4875:
    db        "widen"
    db        0
L4874:
    db        "truncate"
    db        0
L4873:
    db        "fix"
    db        0
L4872:
    db        "float"
    db        0
L4871:
    db        "typepun"
    db        0
L4870:
    db        "toboolto"
    db        0
L4869:
    db        "notto"
    db        0
L4868:
    db        "bitnotto"
    db        0
L4867:
    db        "absto"
    db        0
L4866:
    db        "negto"
    db        0
L4865:
    db        "subpxto"
    db        0
L4864:
    db        "addpxto"
    db        0
L4863:
    db        "maxto"
    db        0
L4862:
    db        "minto"
    db        0
L4861:
    db        "shrto"
    db        0
L4860:
    db        "shlto"
    db        0
L4859:
    db        "bitxorto"
    db        0
L4858:
    db        "bitorto"
    db        0
L4857:
    db        "bitandto"
    db        0
L4856:
    db        "iremto"
    db        0
L4855:
    db        "idivto"
    db        0
L4854:
    db        "divto"
    db        0
L4853:
    db        "multo"
    db        0
L4852:
    db        "subto"
    db        0
L4851:
    db        "addto"
    db        0
L4850:
    db        "loaddecr"
    db        0
L4849:
    db        "loadincr"
    db        0
L4848:
    db        "decrload"
    db        0
L4847:
    db        "incrload"
    db        0
L4846:
    db        "decrto"
    db        0
L4845:
    db        "incrto"
    db        0
L4844:
    db        "fmod"
    db        0
L4843:
    db        "power"
    db        0
L4842:
    db        "atan2"
    db        0
L4841:
    db        "sign"
    db        0
L4840:
    db        "ceil"
    db        0
L4839:
    db        "floor"
    db        0
L4838:
    db        "round"
    db        0
L4837:
    db        "exp"
    db        0
L4836:
    db        "log10"
    db        0
L4835:
    db        "log"
    db        0
L4834:
    db        "atan"
    db        0
L4833:
    db        "acos"
    db        0
L4832:
    db        "asin"
    db        0
L4831:
    db        "tan"
    db        0
L4830:
    db        "cos"
    db        0
L4829:
    db        "sin"
    db        0
L4828:
    db        "sqrt"
    db        0
L4827:
    db        "sqr"
    db        0
L4826:
    db        "toboolf"
    db        0
L4825:
    db        "toboolt"
    db        0
L4824:
    db        "not"
    db        0
L4823:
    db        "bitnot"
    db        0
L4822:
    db        "abs"
    db        0
L4821:
    db        "neg"
    db        0
L4820:
    db        "subp"
    db        0
L4819:
    db        "subpx"
    db        0
L4818:
    db        "addpx"
    db        0
L4817:
    db        "max"
    db        0
L4816:
    db        "min"
    db        0
L4815:
    db        "shr"
    db        0
L4814:
    db        "shl"
    db        0
L4813:
    db        "bitxor"
    db        0
L4812:
    db        "bitor"
    db        0
L4811:
    db        "bitand"
    db        0
L4810:
    db        "idivrem"
    db        0
L4809:
    db        "irem"
    db        0
L4808:
    db        "idiv"
    db        0
L4807:
    db        "div"
    db        0
L4806:
    db        "mul"
    db        0
L4805:
    db        "sub"
    db        0
L4804:
    db        "add"
    db        0
L4803:
    db        "assem"
    db        0
L4802:
    db        "clear"
    db        0
L4801:
    db        "endsw"
    db        0
L4800:
    db        "swlabel"
    db        0
L4799:
    db        "switchu"
    db        0
L4798:
    db        "switch"
    db        0
L4797:
    db        "iswap"
    db        0
L4796:
    db        "fordown"
    db        0
L4795:
    db        "forup"
    db        0
L4794:
    db        "to"
    db        0
L4793:
    db        "stop"
    db        0
L4792:
    db        "setcc"
    db        0
L4791:
    db        "jumpretm"
    db        0
L4790:
    db        "jumpret"
    db        0
L4789:
    db        "jumpf"
    db        0
L4788:
    db        "jumpt"
    db        0
L4787:
    db        "jumpcc"
    db        0
L4786:
    db        "ijump"
    db        0
L4785:
    db        "jump"
    db        0
L4784:
    db        "retfn"
    db        0
L4783:
    db        "icallf"
    db        0
L4782:
    db        "callf"
    db        0
L4781:
    db        "retproc"
    db        0
L4780:
    db        "icallp"
    db        0
L4779:
    db        "callp"
    db        0
L4778:
    db        "storebf"
    db        0
L4777:
    db        "storebit"
    db        0
L4776:
    db        "loadbf"
    db        0
L4775:
    db        "loadbit"
    db        0
L4774:
    db        "type"
    db        0
L4773:
    db        "opnd"
    db        0
L4772:
    db        "unload"
    db        0
L4771:
    db        "swapstk"
    db        0
L4770:
    db        "double"
    db        0
L4769:
    db        "dupl"
    db        0
L4768:
    db        "istorex"
    db        0
L4767:
    db        "istore"
    db        0
L4766:
    db        "store"
    db        0
L4765:
    db        "iloadx"
    db        0
L4764:
    db        "iload"
    db        0
L4763:
    db        "load"
    db        0
L4762:
    db        "nop"
    db        0
L4761:
    db        "data_opnd"
    db        0
L4760:
    db        "realimm32_opnd"
    db        0
L4759:
    db        "realimm_opnd"
    db        0
L4758:
    db        "assem_opnd"
    db        0
L4757:
    db        "strimm_opnd"
    db        0
L4756:
    db        "string_opnd"
    db        0
L4755:
    db        "real32_opnd"
    db        0
L4754:
    db        "real_opnd"
    db        0
L4753:
    db        "int_opnd"
    db        0
L4752:
    db        "label_opnd"
    db        0
L4751:
    db        "memaddr_opnd"
    db        0
L4750:
    db        "mem_opnd"
    db        0
L4749:
    db        "no_opnd"
    db        0
L4748:
    db        "$last"
    db        0
L4747:
    db        "vector"
    db        0
L4746:
    db        "block"
    db        0
L4745:
    db        "i64"
    db        0
L4744:
    db        "i32"
    db        0
L4743:
    db        "i16"
    db        0
L4742:
    db        "i8"
    db        0
L4741:
    db        "u64"
    db        0
L4740:
    db        "u32"
    db        0
L4739:
    db        "u16"
    db        0
L4738:
    db        "u8"
    db        0
L4737:
    db        "r64"
    db        0
L4736:
    db        "r32"
    db        0
L4735:
    db        "void"
    db        0
L4734:
    db        "pm_extra"
    db        0
L4733:
    db        "pm_colon"
    db        0
L4732:
    db        "pm_libfile"
    db        0
L4731:
    db        "pm_sourcefile"
    db        0
L4730:
    db        "pm_option"
    db        0
L4729:
    db        "pm_end"
    db        0

