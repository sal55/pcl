## PCL Intermediate Language

* An IL that is suited as the target of lower level languages such as C and my own 'M' systems language
* Provides a stack-based VM
* Uses the usual machine types `u8-u64 i8-i64 r32-r64`, with all aggregate types represented by a single 'block' type of so many bytes
* Although only little higher level then assembly, PCL is a portable code that hides details of registers, ABIs and calling conventions

There is no textual form of PCL; code is generated via an API. There is no binary file format either. It is expected that PCL code is generated by the front-end (the 'Host') and then immediately processed into its final target.

I decided that a text format, while appearing to be simpler to get going with, was not that practical. In a real project, you'd probably end up creating an API to generate PCL source code anyway.

There are some use-cases for textual IL (for example when the host runs on one machine and the PCL is consumed on other). But that can be added on as another front-end language.

PCL is not a new product, but previous versions were closely integrated into a compiler, and tended to be 64-bit oriented with most narrow integer values promototed to. This new version is more general and exactly the same library can be used for different languages and compilers.

### Availability

This is an experimental project for my own compilers and for a limited range of targets. I'm not really looking at making a tool for general use, for several reasons:

* It's not mature enough
* It doesn't support enough targets (eg. only Win64 right now)
* The native code backends don't generate optimised code
* Everything is buggy
* While the PCL design is reasonably stable, the API is not yet fixed
* There are a number of problems still to sort out, which currently only have workarounds
* It is also aimed at whole-program front-ends (it can be used for independently compiled modules, but then the outputs are limited to ASM/OBJ)

But mainly I'm not interested in that and don't want to get involved in support.

It was just an interesting challenge, plus there was some satisfaction in producing a tiny self-contained library that basically does what LLVM does but of a size and complexity several magnitudes smaller, and up to a couple of magnitudes faster.

It is showing what is possible even working at this scale.

### Structure

````
Front-ends             IR/IL             Back-ends             

M7 Compiler ──>──┐                ┌────> PCL  ────────────> Text Dump
C Compiler  ──>──┼────> PCL ──>───┼────> RUNP ────────────> Interpret PCL
Q Demo ───────>──┤                ├────> Windows-x64 ─────> EXE/DLL/OBJ/MX/ASM/NASM/RUN
C Demo ───────>──┤                ├────> (Linux-x64 ──────> NASM/MX/RUN)
(PCL text) ───>──┤                ├────> (Linux-ARM64 ────> AT&T-ASM)
(Other) ──────>──┘                ├────> (Z80 8-bit ──────> ZASM)
                                  ├────> (32-bit targets)
                                  └────> (Linear C)
Key:
 PCL Text     This displays generated PCL in source form for diagnostics. The syntax is not suitable for machine reading to re-generate PCL
 RUNP         This immediately interpret the PCL code. It is platform-independent
 EXE/DLL/OBJ  Windows' PE-format binaries
 RUN          Runs the generated native code in-memory
 MX           My private, portable binary format, requiring a small stub program to launch
 ASM          x64 assembly in the syntax used by my AA assembler/linker
 NASM         x64 assembly in NASM syntax (NASM runs under Linux too)
 ZASM         My Z80 assembly syntax
````

Elements in parentheses are either experimental or don't exist. However they helped keep the design flexible.

Everything works to some degree. (The M7-EXE compiler is almost production ready and can self-host. C-EXE has some issues. M7/C-RUNPCL is still buggy. There are other minor issues with other combinations. There is a lot to test and lots of configurations.

I'm not yet at the point where I can chain several products together, however some combinations like this one:
````
c:\cxp>\bx\mm -run cc -runp lua fib.lua
````
(`bx\mm` is the M7 compiler. This translates the C compiler `cc` to PCL then to x64 code which is immediately run. `cc` in turn translates the one-file Lua interpreter `lua.c` to PCL, and immediately executes that by interpreting the PCL. In turn, the Lua interpreter loads and runs `fib.lua`.

The tricky bit is managing all those commandline parameters, as each of these three programs should only see the ones relevant to it.)


(`bx\mm` is M7 compiler, which compiles runs `cc` which is the C compiler, whih compiles the one-file Lua interpreter lua.c into PCL

M7 runs the C compiler via -RUNPCL which then runs say Lua via RUNPCL too.)

### Deployment

Each back-end in the chart is intended to be a self-contained library. It is used as follows:

* M7 and C compilers - the build process makes it part the main compiler (via `import pcl` which adds the two dozen modules needed)
* Q Demo - the PCL library is formed into a separate DLL library
* C Demo - it can either be statically linked (via an OBJ file), or can also use a DLL

Currently the Win64 product includes also the PCL dump routine and the PCL interpreter.

As a DLL, it is single binary of under 200KB, and supports PCL/RUNPCL/EXE/DLL/OBJ/MX/ASM/RUN. (8 different outputs. NASM would be a 9th output, but there can only be one ASM option in a particular build.)

A DLL supporting only RUNPCL (minimal needed to execute PCL code) is about 64KB. Probably this could be reduced as 30KB is the M language's standard library.

### Source Code

Everything is written in my M systems language. Tests are built with the M6 production compiler and run on Windows. M7 is the new compiler.

For use from Q and C languages, suitable interface files are provided (`pcl.q` and `pcl.h`).

The C demo (`cdemo.c`) needs a binary, either `pcl.obj` or `pcl.dll`, but because these are troublesome to distribute, an ASM version `pcl.asm` is provided, in NASM syntax, which can be assembled locally.

### The PCL API

This is not docoumented yet. The API consists of about 50 functions and a bunch of enumerations; see `pcl.q` or `pcl.h` for a summary. (The M7/C compiler projects don't need any such interface; written in my language, they just do `import pcl` and all exported entities of the library become available, including extras to deal with inline assembly for example.)

The true interface also exports some global variables; these are not needed for the demos, so are not part of those interface files. The API needs to be tidied up so that it only uses functions to control the process.

The library uses global state. There is no context handle returned by `pcl_start` for example. Only one program at a time can be processed, and as written, at most one program can be translated. For use via a DLL, it needs to be capable of translating successive programs, but this is not ready.

### Generating PCL Code

This is done primarily with an API (see for example pcl.q or pcl.h), which provides about 50 functions and a bunch of enumerations for types, opcodes and so on.

That uses the PCL library which as mentioned is either compiled into the front-end, or used as a shared library.

### PCL Types and Opcodes

These are listed and documented here.

### Adding PCL to the C Compiler

C needs to do independent compilation which would limit what this PCL backend could provide. I decided to make a new, more streamlined C compiler which would work only on a single module. This means it can work like a whole-program compiler and can directly generate EXE or DLL files, or run or intepret the programs. (It also makes compilation twice as fast compared with going through intermediate ASM.)

Multi-module C programs can still be built, but via a driver program (a 200-line script), which invokes PCL per-module and with an ASM target (it then invokes my AA assemble-linker on the results).

Some things were challenging. For example the `argn, argv` arguments of `main`, which don't exist under Windows and needs to be emulated. But does happen before PCL or after? I moved that mechanism to after PCL; it takes away that headache from the host.

Another thing was supporting var-args, which in my main implementation, assumes the stack grows downwards. In the PCL interpreter however, it grows upwards!

### Interpreting PCL

This wasn't considered seriously first. Why interpret? PCL as it is is quite unsuitable for interpretation: there too many combinations of operands and types, which need to be sorted at runtime. However I decided to try it anyway. And yes, it was very slow.

But there are some benefits in having a reference implementation that is independent of platform. Debugging becomes easier. Various kinds of survey can be done. If the interpreter at least was ported to another language, that provides one way of getting my M code to run across machines.

There are difficulties however:
* Running interpreted code that calls into external native code requires solving the 'LIBFFI' problem. That has an ugly, awkward solution in that C library. In my language I can solve it trivially, but then porting the code to another language is harder.
* It is not possible to deal with callback functions, where an external function is passed a pointer to a function in your program. Native code can't call a pointer to bytecode!

It does allow very quick development cycles, but that are quick anyway; see below.

Anyway, it's cool.

### Run from Source and JIT

This is possible in two ways:

* Compile to PCL then interpret that (but it is slow, and with the limitations mentioned)
* Compile to PCL then translate to native code then the resulting code in-memory

The latter takes a tiny bit longer, but with typical programs, that is tens of milliseconds. (Eg. sqlite3.c, some 250Kloc, takes 150ms to turn into PCL, but still only 300ms to turn into x64 code. Most projects of mine are smaller.)

So JIT is the usual sense isn't necessary, as whole-program translation from source to native code is more or less instant anyway (depending on the scale of the program of course).

### Targeting Linux x64, and MX Files

This is probably the next challenge. On the face of it it sounds a minor change to the x64 code generator: a different ABI, but a complicated one. (There may also be problems with passing structs by value: the SYS V ABI may need to now the their internal layout, but PCL flattens them into an untyped sequence of bytes.)

Because I do not support Linux binary file formats, I need to generate NASM-format ASM, and use NASM on Linux to produce object files, then use other Linux tools to create an executable.

There are other options, such as the MX file format. That was a binary format I developed for other reasons, which I no longer need, but it is a simple binary executable format, and it's portable. So I could generate that instead. This format needs a small stub program to load and fix up the MX files before calling their entry point. That program is a 900-line C programs, which just needs tweaking to work with `dlopen/dlsym`.

### Generating 'Linear  C'

This is something that was once considered and was experimented with. Each IL instruction translates to a C statement, with the VM stack represented by a set of C local variables.

The trouble is that the C generated is terrible with lots of redundant assignments, so that it *needs* an optimising compiler to clean up the mess.

It is unlikely to be done as one of the reasons for creating PCL was to avoid having to use intermediate C. Probably it is easier to generate structured C from an AST than linear C from an IL.

### The PCL Runtime

The job of a PCL backend is to turn each instruction into inline native code. But sometimes the task is too complex to do inline.

Some ops result in a call to an external library (eg. to do `power r64`), but sometimes a local function is needed (eg. for `power i64`).

I don't have a general solution for this right now. A workaround used in the M7 compiler is for the backend to request the front end for a reference to a suitable function (eg. `m$power_i64` is part of the M7 compiler's standard library).

Synthesising such code through function calls is not practical (`m$power_i64` is 50 PCL instructions for example). So I might introduce a limited form of textual PCL; those 50 lines are represented by a table of 50 strings, or possibly it will embed a small text file, and a mini parser turns that into internal PCL using the same API the front-end uses.


### Backend Optimisations

The M6 compiler for x64 does two kinds of enhancements to generate code:

* Some locals and parameters can sometimes be kept in registers
* There is a small peephole optimiser that works on generated x64 code

Neither really make applications much faster. Using locals in register can sometimes give impressive results with benchmarks, or where an M-language routine is called from my scripting language. Mainly they just make the code smaller. As it is, the very impressive throughputs of all my language tools are achieved with pretty much unoptimised code.

PCL's x64 backend doesn't yet have even the above enhancements. So neither M7 nor the new C compiler have them (so code generated by them is a little bit larger too).

They will be added in due course. Generated PCL code can be tided up too. Some is up to the host compiler. There are some reductions that can be done by the PCL API functions (for example combining sequences involving address calculations). But at the moment all that is low priority. I can live without a 10% improvement in speed or size!

### Inline Assembly

This is not directly supported by PCL. With a version involving discrete IL files, it wouldn't be possible at all.

Yet the M7 compiler supports inline assembly. It generates `assem` PCL opcodes, which have a opaque reference to an AST structure in the host which contains more details.

When an `assem` instruction needs to be translated to x64 code, it calls back into the host to deal with it. So there is an untidy leakage of symbols between the host on one side of PCL, and the backend on the other. But it works. The native backend will anyway contain the several hundred reserved words (instructions, registers etc) which the front end needs to be able to parse assembly.

(The PCL interpreter doesn't suport `assem`, so that is another limitation. But neither would a C transpiler.)

### PCL as a DLL

This is needed for the Q demo below, but the DLL format for this library needs a lot more work. For a start, the library currently does a one-off translation then terminates. A host will expect to call a DLL for multiple programs. Also, the API needs to be refined further. Some variables are exported from the library; I want to use only functions.

### Q Demo

I wanted to try out using PCL from a dynamic language, and via a DLL. The program below synthesises a hello-world program, then selects one of several output options.
````
module pcl

proc main =
    pcl_start("demo")

        dmain:=pc_makesymbol("main", export_id)
        dputs:=pc_makesymbol("puts", import_id)

        pc_defproc(dmain)
            pc_gen(kload, genstring("Hello, World!"))
            pc_setmode(tpu64)

            pc_genxy(kcallp, 1,0, genmemaddr(dputs))

            pc_gen(kload, genint(0))
            pc_setmode(tpi64)

            pc_gen(kstop)
            pc_gen(kretproc)

        pc_endproc()

        pc_addplib("msvcrt")            ! Needed by most targets

    pcl_end()
````
At this point, the generated PCL program exists as global state within the library. Now any one of the following calls can be made. For this test, all but one is commented out:
````
    pcl_writepcl("hello.pcl")           ! Dump as PCL text

    pcl_runpcl()                        ! Run PCL via interpreter

    pcl_writeasm("hello.asm")           ! Generate ASM for my AA assemble
    pcl_writeasm("hello.asm", 'NASM')   ! Generate ASM for NASM (only one of these two will be available)

    pcl_writeexe("hello.exe")           ! Write Windows PE executable

    pcl_setflags(highmem:2)             ! needed if to be linked via gcc or ld
    pcl_writeobj("hello.obj")           ! Write Windows COFF object file

    pcl_writemx("hello.mx")             ! Write my private executable format
 
    pcl_exec(0)                         ! Run native code in-memory
end
````
That `pcl` module is the file `pcl.q`. This manually written. (The M7 compiler is supposed to write such interface files automatically when creating DLLs, but that needs a lot more work. Besides there was a lot more backend stuff exported that is not needed here.)

### C Demo

The demo was repeated in C; see `cdemo.c`. The matching interface file is `pcl.h`. If someone wants to try this on Windows, they will need the PCL library. I've supplied this an ASM file in NASM format: `pcl.asm`. It needs the NASM assembler to turn it into a `.obj` file. Build instructions are at the top of the `cdemo.c` file.

Not all outputs work. For example, `pcl_exec()` doesn't work if compiled with gcc; that needs investigating (probably I'm writing memory that gcc puts into a read-only section).

The C API suffers a little because the language doesn't support default argument values.

### The PCL M Library

The library is written in my language as a collection of two dozen modules (for the Win64 version with all outputs bundled). It forms a 'sub-program' which can be included in any M project by writing 'import pcl'.

Here the module scheme works effectively, provided I do want all 24 modules. Configuring a different arrangement involves using a different lead module with a different selection of modules. But currently the internal structure doesn't allow them to be split up so easily. So this is an interesting challenge of the module scheme.

I think however it can cope. The expectation is that with two main targets for example, an M compiler for Windows will include:
````
import pcl_win64
````
and one for Linux will have:
````
import pcl_lin64
````
in their lead modules. (Such modules usually only list the modules/libraries that comprise the project.)



