## PCL Intermediate Language

* An IL that is suited as the target of lower level languages such as C and my own 'M' systems language
* Provides a stack-based VM
* Uses the usual machine types `u8-u64 i8-i64 r32-r64`, with all aggregate types represented by a single 'block' type of so many bytes
* Although only little higher level then assembly, PCL is a portable code that hides details of registers, ABIs and calling conventions

There is no textual form of PCL; code is generated via an API. There is no binary file format either. It is expected that PCL code is generated by the front-end (the 'Host') and then immediately processed into its final target.

I decided that for text format, while appearing to be simpler to get going with, was not that practical. In a real project, you'd probably end up creating an API to generate PCL source code anyway.

There are some use-cases for textual IL (for example when the host runs on one machine and the PCL is consumed on other). But that can be added on as another front-end language.

### Availability

This is an experimental project for my own compilers and for a limited range of targets.

I'm not really looking at making these a tool for general use, for several reasons:

* It's not mature enough
* It doesn't support enough targets (eg. only Win64 right now)
* The native code targets don't generate optimised code
* Everything is undoubtable very buggy
* While the PCL design is reasonably stable, the API is not yet fixed
* There are quite a few problems still to sort out, which currently only have workarounds, some of which are detailed below

But mainly I'm not interested in that and don't want to get involved in support. For me it was an interesting intellectual exercise, plus some satisfaction in producing a self-contained 150KB library (depending on configuration...) that basically does what LLVM does but of a size and complexity several magnitudes smaller.

So, this is just showing what is possible even working at this scale.

### Structure

This shows how PCL is intended to work:

````
Front-ends             IR/IL             Back-ends             

M7 Compiler ──>──┐                ┌────> PCL  - Text Dump
C Compiler  ──>──┼────> PCL ──>───┼────> RUNP - Interpret PCL
Q Demo ───────>──┤                ├────> Windows-x64 ────> EXE/DLL/OBJ/MX/ASM/NASM/RUN
C Demo ───────>──┤                ├────> (Linux-x64 ──────> NASM/MX/RUN)
(PCL text) ───>──┤                ├────> (Linux-ARM64 ────> AT&T-ASM)
(Other) ──────>──┘                ├────> (Z80 8-bit ──────> ZASM)
                                  ├────> (32-bit targets)
                                  └────> (Linear C)
Key:
 PCL          This displays generated PCL in source form for diagnostics. The syntax is not suitable for reading to re-generate PCL
 RUNP         This will executable the program by directly interpreting the PCL code, independently of any target
 EXE/DLL/OBJ  Windows' PE-format binaries
 RUN          Runs the generated native code in-memory without writing any binaries
 MX           My private, portable (and simple) binary format, require a small stub program to launch
 ASM          x64 assembly in the syntax used by my AA assembler/linker
 NASM         x64 assembly in NASM syntax (NASM runs under Linux too)
 ZASM         My Z80 assembly syntax
 Linear C     Crude, unstructured C source code
````

Elements in parentheses are either experimental or don't exist. However their possibility in mind has helped keep the design flexible.

Everything else either works or mostly works. (The M7-EXE compiler is almost production ready and can self-host. C-EXE has some issues. M7/C-RUNPCL is still buggy. There are other minor issues with other combinations. There is a lot to test and lots of configurations. I'm not yet at the point where I can chain products together: M7 runs the C compiler via -RUNPCL which then runs say Lua via RUNPCL too.)

### Deployment

Each back-end in the chart is intended to be a self-contained library. It is used as follows:

* M7 and C compilers - the build process makes it part the main compiler (via `import pcl` which adds the two dozen modules needed)
* Q Demo - the PCL library is formed into a separate DLL library
* C Demo - it can either be statically linked (via an OBJ file), or can also use a DLL

Currently the Win64 product includes also the PCL dump routine and the PCL interpreter.

As a DLL, it is single binary of under 200KB, and supports PCL/RUNPCL/EXE/DLL/OBJ/MX/ASM/RUN. (8 different outputs. NASM would be a 9th output, but there can only be one ASM option in a particular build.)

A DLL supporting only RUNPCL (minimal needed to execute PCL code) is about 64KB. Probably this could be reduced as 30KB is the M language's standard library.

### Source Code

Everything is written in my M systems language. Tests are built with the M6 production compiler and run on Windows. M7 is the new compiler.

For use from Q and C languages, suitable interface files are provided (`pcl.q` and `pcl.h`).

The C demo (`cdemo.c`) needs a binary, either `pcl.obj` or `pcl.dll`, but because these are troublesome to distribute, an ASM version `pcl.asm` is provided, in NASM syntax, which can be assembled locally.


### Generating PCL Code

This is done primarily with an API (see for example pcl.q or pcl.h), which provides about 50 functions and a bunch of enumerations for types, opcodes and so on.

That uses the PCL library which as mentioned is either compiled into the front-end, or used as a shared library.

### PCL Types and Opcodes

These are listed and documented here.

### Adding PCL to the C Compiler

### Interpreting PCL

### Run from Source

### Targetting Linux x64

### Generating 'Linear  C'

### The PCL Runtime

### Backend Optimisations





