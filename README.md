## PCL Intermediate Language

* An IL that is suited as the target of lower level languages such as C and my own 'M' systems language
* Provides a stack-based VM
* Uses the usual machine types `u8-u64 i8-i64 r32-r64`, with all aggregate types represented by a single 'block' type of so many bytes
* Although only little higher level then assembly, PCL is a portable code that hides details of registers, ABIs and calling conventions

There is no textual form of PCL; code is generated via an API. There is no binary file format either. It is expected that PCL code is generated by the front-end (the 'Host') and then immediately processed into its final target.

I decided that a text format, while appearing to be simpler to get going with, was not that practical. In a real project, you'd probably end up creating an API to generate PCL source code anyway.

There are some use-cases for textual IL (for example when the host runs on one machine and the PCL is consumed on other). But that can be added on as another front-end language.

PCL is not a product, but previous ones were 64-bit oriented and most integer types were auto-widened to 64 bits. This new version has ops of any width (C mainly works with 32 bits for example), and there is never any automatic widening.

### Availability

This is an experimental project for my own compilers and for a limited range of targets. I'm not really looking at making a tool for general use, for several reasons:

* It's not mature enough
* It doesn't support enough targets (eg. only Win64 right now)
* The native code targets don't generate optimised code
* Everything is undoubtably very buggy
* While the PCL design is reasonably stable, the API is not yet fixed
* There are a number of problems still to sort out, which currently only have workarounds, some of which are detailed below
* It is also aimed at whole-program front-ends (it can be used for independently compiled modules, but then the outputs are limited (to ASM/OBJ)

But mainly I'm not interested in that and don't want to get involved in support.

For me it was an interesting intellectual exercise, plus there was some satisfaction in producing a self-contained 100-200KB library (depends on configuration) that basically does what LLVM does but of a size and complexity several magnitudes smaller.

It is showing what is possible even working at this scale.

### Structure

This shows how PCL is intended to work:

````
Front-ends             IR/IL             Back-ends             

M7 Compiler ──>──┐                ┌────> PCL  ────────────> Text Dump
C Compiler  ──>──┼────> PCL ──>───┼────> RUNP ────────────> Interpret PCL
Q Demo ───────>──┤                ├────> Windows-x64 ─────> EXE/DLL/OBJ/MX/ASM/NASM/RUN
C Demo ───────>──┤                ├────> (Linux-x64 ──────> NASM/MX/RUN)
(PCL text) ───>──┤                ├────> (Linux-ARM64 ────> AT&T-ASM)
(Other) ──────>──┘                ├────> (Z80 8-bit ──────> ZASM)
                                  ├────> (32-bit targets)
                                  └────> (Linear C)
Key:
 PCL          This displays generated PCL in source form for diagnostics. The syntax is not suitable for machine reading to re-generate PCL
 RUNP         This will executable the program by directly interpreting the PCL code, independently of any target
 EXE/DLL/OBJ  Windows' PE-format binaries
 RUN          Runs the generated native code in-memory without writing any binaries
 MX           My private, portable (and simple) binary format, requiring a small stub program to launch
 ASM          x64 assembly in the syntax used by my AA assembler/linker
 NASM         x64 assembly in NASM syntax (NASM runs under Linux too)
 ZASM         My Z80 assembly syntax
 Linear C     Crude, unstructured C source code
````

Elements in parentheses are either experimental or don't exist. However they helped keep the design flexible.

Everything works to some degree. (The M7-EXE compiler is almost production ready and can self-host. C-EXE has some issues. M7/C-RUNPCL is still buggy. There are other minor issues with other combinations. There is a lot to test and lots of configurations.

I'm not yet at the point where I can chain several products together, however some combinations like this one:
````
c:\cxp>\bx\mm -run cc -runp lua fib.lua
````
(`bx\mm` is the M7 compiler. This translates the C compiler `cc` to PCL then to x64 code which is immediately run. `cc` in turn translates the one-file Lua interpreter `lua.c` to PCL, and immediately executes that by interpreting the PCL. In turn, the Lua interpreter loads and runs `fib.lua`.

The tricky bit is managing all those commandline parameters, as each of these three programs should only see the ones relevant to it.)


(`bx\mm` is M7 compiler, which compiles runs `cc` which is the C compiler, whih compiles the one-file Lua interpreter lua.c into PCL

M7 runs the C compiler via -RUNPCL which then runs say Lua via RUNPCL too.)

### Deployment

Each back-end in the chart is intended to be a self-contained library. It is used as follows:

* M7 and C compilers - the build process makes it part the main compiler (via `import pcl` which adds the two dozen modules needed)
* Q Demo - the PCL library is formed into a separate DLL library
* C Demo - it can either be statically linked (via an OBJ file), or can also use a DLL

Currently the Win64 product includes also the PCL dump routine and the PCL interpreter.

As a DLL, it is single binary of under 200KB, and supports PCL/RUNPCL/EXE/DLL/OBJ/MX/ASM/RUN. (8 different outputs. NASM would be a 9th output, but there can only be one ASM option in a particular build.)

A DLL supporting only RUNPCL (minimal needed to execute PCL code) is about 64KB. Probably this could be reduced as 30KB is the M language's standard library.

### Source Code

Everything is written in my M systems language. Tests are built with the M6 production compiler and run on Windows. M7 is the new compiler.

For use from Q and C languages, suitable interface files are provided (`pcl.q` and `pcl.h`).

The C demo (`cdemo.c`) needs a binary, either `pcl.obj` or `pcl.dll`, but because these are troublesome to distribute, an ASM version `pcl.asm` is provided, in NASM syntax, which can be assembled locally.


### Generating PCL Code

This is done primarily with an API (see for example pcl.q or pcl.h), which provides about 50 functions and a bunch of enumerations for types, opcodes and so on.

That uses the PCL library which as mentioned is either compiled into the front-end, or used as a shared library.

### PCL Types and Opcodes

These are listed and documented here.

### Adding PCL to the C Compiler

C needs to do independent compilation which would limit what this PCL backend could provide. I decided to make a new, more streamlined C compiler which would work only on a single module. This means it can work like a whole-program compiler and can directly generate EXE or DLL files, or run or intepret the programs. (It also makes compilation twice as fast compared with going through intermediate ASM.)

Multi-module C programs can still be built, but via a driver program (a 200-line script), which invokes PCL per-module and with an ASM target (it then invokes my AA assemble-linker on the results).

Some things were challenging. For example the `argn, argv` arguments of `main`, which don't exist under Windows and needs to be emulated. But does happen before PCL or after? I moved that mechanism to after PCL; it takes away that headache from the host.

Another thing was supporting var-args, which in my main implementation, assumes the stack grows downwards. In the PCL interpreter however, it grows upwards!

### Interpreting PCL

This wasn't considered seriously first. Why interpret? PCL as it is is quite unsuitable for interpretation: there too many combinations of operands and types, which need to be sorted at runtime. However I decided to try it anyway. And yes, it was very slow.

But there are some benefits in having a reference implementation that is independent of platform. Debugging becomes easier. Various kinds of survey can be done. If the interpreter at least was ported to another language, that provides one way of getting my M code to run across machines.

There are difficulties however:
* Running interpreted code that calls into external native code requires solving the 'LIBFFI' problem. That has an ugly, awkward solution in that C library. In my language I can solve it trivially, but then porting the code to another language is harder.
* It is not possible to deal with callback functions, where an external function is passed a pointer to a function in your program. Native code can't call a pointer to bytecode!

It does allow very quick development cycles, but that are quick anyway; see below.

Anyway, it's cool.

### Run from Source and JIT

This is possible in two ways:

* Compile to PCL then interpret that (but it is slow, and with the limitations mentioned)
* Compile to PCL then translate to native code then the resulting code in-memory

The latter takes a tiny bit longer, but with typical programs, that is tens of milliseconds. (Eg. sqlite3.c, some 250Kloc, takes 150ms to turn into PCL, but still only 300ms to turn into x64 code. Most projects of mine are smaller.)

So JIT is the usual sense isn't necessary, as whole-program translation from source to native code is more or less instant anyway (depending on the scale of the program of course).

### Targeting Linux x64, and MX Files

This is probably the next challenge. On the face of it it sounds a minor change to the x64 code generator: a different ABI, but a complicated one. (There may also be problems with passing structs by value: the SYS V ABI may need to now the their internal layout, but PCL flattens them into an untyped sequence of bytes.)

Because I do not support Linux binary file formats, I need to generate NASM-format ASM, and use NASM on Linux to produce object files, then use other Linux tools to create an executable.

There are other options, such as the MX file format. That was a binary format I developed for other reasons, which I no longer need, but it is a simple binary executable format, and it's portable. So I could generate that instead. This format needs a small stub program to load and fix up the MX files before calling their entry point. That program is a 900-line C programs, which just needs tweaking to work with `dlopen/dlsym`.

### Generating 'Linear  C'

This is unlikely to be done, but I have experimented with it and it would probably work.That is, each IL instruction translates to a C statement, which the VM stack represented by a set of C locals.

The trouble is that the C generated is terrible with lots of redundant assignments, so that it *needs* an optimising compiler to clean up the mess.

It probably won't be done because one of the reasons for creating PCL was to avoid having to use intermediate C.

### The PCL Runtime

PCL, when turned into native code, mostly generates inline code. Exceptions include calls to external libraries; for example `a ** b` when `a, b` are floats will generate a call to C's `pow` function. But when `a, b` are integers, then inline code is too sprawling; it needs to use a function.

Where doesn't that come from however? It's the responsibility of the PCL backend, but there is no provision for such support functions. I don't want to add a discrete library which then becomes a dependency (eg. a DLL that accompanies to the generate program binary).

I currently use a workaround. The routine for integer `**` is part of M7's runtime and is part of the library when apps are compiled, so it will exist as PCL. The native backend reaches back across PCL and asks the host for a reference. For the C compiler, so an operator doesn't exist.

I don't have a solution yet, but when will be needed for other kinds of support, for example for 128-bit arithmetic. While I'd rule out have a textual input format for PCL, I may rethink that. A crude syntax for representing PCL (not as an output for a front-end, may suffice to describe the small number of routines that may be needed.

### Backend Optimisations

The M6 compiler for x64 does two kinds of enhancements to generate code:

* Some locals and parameters can sometimes be kept in registers
* There is a small peephole optimiser that works on generated x64 code

Neither really make applications much faster. Using locals in register can sometimes give impressive results with benchmarks, or where an M-language routine is called from my scripting language. Mainly they just make the code smaller. As it is, the very impressive throughputs of all my language tools are achieved with pretty much unoptimised code.

PCL's x64 backend doesn't yet have even the above enhancements. So neither M7 nor the new C compiler have them (so code generated by them is a little bit larger too).

They will be added in due course. Generated PCL code can be tided up too. Some is up to the host compiler. There are some reductions that can be done by the PCL API functions (for example combining sequences involving `addpx iloadx istorex` operations).

At the moment however all that is low priority.

### Inline Assembly

This is not directly supported by PCL. With a version involving discrete IL files, it wouldn't be possible at all.

Yet the M7 compiler supports inline assembly. It generates `assem` PCL opcodes, which have a opaque reference to an AST structure in the host which contains more details.

When an `assem` instruction needs to be translated to x64 code, it calls back into the host to deal with it. So there is an untidy leakage of symbols between the host on one side of PCL, and the backend on the other. But it works. The native backend will anyway contain the several hundred reserved words (instructions, registers etc) which are needed to be able to parse assembly.

(The PCL interpreter doesn't suport `assem`, so that is another limitation.)

### PCL as a DLL

This is needed for the Q demo below, but DLL format for this library needs a lot more work. For a start, the library currently does a one-off translation then terminates. A host will expect to call a DLL for multiple programs. Also, the API needs to be refined further. Some variables are exported from the library; I want to use only functions.

### Q Demo

I wanted to try out using PCL from a dynamic language, and via a DLL. The program below synthesises a hello-world program, then selects one of several output options. As shown, it will interpret the resulting program.
````
module pcl

proc main =
    pcl_start("demo")

        dmain:=pc_makesymbol("main", export_id)
        dputs:=pc_makesymbol("puts", import_id)

        pc_defproc(dmain)
            pc_gen(kload, genstring("Hello, World!"))
            pc_setmode(tpu64)

            pc_genxy(kcallp, 1,0, genmemaddr(dputs))

            pc_gen(kload, genint(0))
            pc_setmode(tpi64)

            pc_gen(kstop)
            pc_gen(kretproc)

        pc_endproc()

        pc_addplib("msvcrt")            ! Needed by most targets

    pcl_end()
````
At this point, the generated PCL program exists as global state within the library. Now any one of the following calls can be made. For this test, all but one is commented out:

    pcl_writepcl("hello.pcl")           ! Dump as PCL text

    pcl_runpcl()                        ! Run PCL via interpreter

    pcl_writeasm("hello.asm")           ! Generate ASM for my AA assemble
    pcl_writeasm("hello.asm", 'NASM')   ! Generate ASM for NASM (only one of these two will be available)

    pcl_writeexe("hello.exe")           ! Write Windows PE executable

    pcl_setflags(highmem:2)             ! needed if to be linked via gcc or ld
    pcl_writeobj("hello.obj")           ! Write Windows COFF object file

    pcl_writemx("hello.mx")             ! Write my private executable format
 
    pcl_exec(0)                         ! Run native code in-memory
end
````
That `pcl` module is the file `pcl.q`. This manually written. (The M7 compiler is supposed to write such interface files automatically when creating DLLs, but that needs a lot more work. Besides there was a lot more backend stuff exported that is not needed here.)

### C Demo

The demo was repeated in C; see `cdemo.c`. The matching interface file is `pcl.h`. If someone wants to try this on Windows, they will need the PCL library. I've supplied this an ASM file in NASM format: `pcl.asm`. It needs the NASM assembler to turn it into a `.obj` file. Build instructions are at the top of the `cdemo.c` file.

Not all outputs work. For example, `pcl_exec()` doesn't work if compiled with gcc; that needs investigating (probably I'm writing memory that gcc puts into a read-only section).

### The Other PCL Language

I have two languages called 'PCL'. The other one is the name of the bytecode for my dynamic language, which has been in use since the 1990s. Usually there's no confusion (except when I tried to merge the languages).

Generating stack-based bytecode was so easy for scripting languages, that I wanted the same experience for my native code compiler:
````
    pushf b           # dynamic bytecode; -f means local stackframe variable
    pushf c
    add               # can add ints, floats, stringsetc
    popf a

    load b    i64     # static IL
    load c    i64
    add       i64
    store a
````
The static PCL uses `load/store` rather than `push/pop`, to avoid confusion with hardware `push/pop` operations. `load/store` usually map to register/memory `mov` ops on x64.    




