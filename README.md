## PCL Intermediate Language

* An IL that is suited as the target of lower level languages such as C and my own 'M' systems language
* Provides a stack-based VM
* Uses the usual machine types `u8-u64 i8-i64 r32-r64`, with all aggregate types represented by a single 'block' type of so many bytes
* Although only little higher level then assembly, PCL is a portable code that hides details of registers, ABIs and calling conventions

There is no textual form of PCL; code is generated via an API. There is no binary file format either. It is expected that PCL code is generated by the front-end (the 'Host') and then immediately processed into its final target.

I decided that a text format, while appearing to be simpler to get going with, was not that practical. In a real project, you'd probably end up creating an API to generate PCL source code anyway.

There are some use-cases for textual IL (for example when the host runs on one machine and the PCL is consumed on other). But that can be added on as another front-end language.

PCL is not a product, but previous ones were 64-bit oriented and most integer types were auto-widened to 64 bits. This new version has ops of any width (C mainly works with 32 bits for example), and there is never any automatic widening.

### Availability

This is an experimental project for my own compilers and for a limited range of targets. I'm not really looking at making a tool for general use, for several reasons:

* It's not mature enough
* It doesn't support enough targets (eg. only Win64 right now)
* The native code targets don't generate optimised code
* Everything is undoubtably very buggy
* While the PCL design is reasonably stable, the API is not yet fixed
* There are a number of problems still to sort out, which currently only have workarounds, some of which are detailed below
* It is also aimed at whole-program front-ends (it can be used for independently compiled modules, but then the outputs are limited (to ASM/OBJ)

But mainly I'm not interested in that and don't want to get involved in support.

For me it was an interesting intellectual exercise, plus there was some satisfaction in producing a self-contained 100-200KB library (depends on configuration) that basically does what LLVM does but of a size and complexity several magnitudes smaller.

It is showing what is possible even working at this scale.

### Structure

This shows how PCL is intended to work:

````
Front-ends             IR/IL             Back-ends             

M7 Compiler ──>──┐                ┌────> PCL  ────────────> Text Dump
C Compiler  ──>──┼────> PCL ──>───┼────> RUNP ────────────> Interpret PCL
Q Demo ───────>──┤                ├────> Windows-x64 ─────> EXE/DLL/OBJ/MX/ASM/NASM/RUN
C Demo ───────>──┤                ├────> (Linux-x64 ──────> NASM/MX/RUN)
(PCL text) ───>──┤                ├────> (Linux-ARM64 ────> AT&T-ASM)
(Other) ──────>──┘                ├────> (Z80 8-bit ──────> ZASM)
                                  ├────> (32-bit targets)
                                  └────> (Linear C)
Key:
 PCL          This displays generated PCL in source form for diagnostics. The syntax is not suitable for machine reading to re-generate PCL
 RUNP         This will executable the program by directly interpreting the PCL code, independently of any target
 EXE/DLL/OBJ  Windows' PE-format binaries
 RUN          Runs the generated native code in-memory without writing any binaries
 MX           My private, portable (and simple) binary format, requiring a small stub program to launch
 ASM          x64 assembly in the syntax used by my AA assembler/linker
 NASM         x64 assembly in NASM syntax (NASM runs under Linux too)
 ZASM         My Z80 assembly syntax
 Linear C     Crude, unstructured C source code
````

Elements in parentheses are either experimental or don't exist. However they helped keep the design flexible.

Everything works to some degree. (The M7-EXE compiler is almost production ready and can self-host. C-EXE has some issues. M7/C-RUNPCL is still buggy. There are other minor issues with other combinations. There is a lot to test and lots of configurations.

I'm not yet at the point where I can chain several products together, however some combinations like this one:
````
c:\cxp>\bx\mm -run cc -runp lua fib.lua
````
(`bx\mm` is the M7 compiler. This translates the C compiler `cc` to PCL then to x64 code which is immediately run. `cc` in turn translates the one-file Lua interpreter `lua.c` to PCL, and immediately executes that by interpreting the PCL. In turn, the Lua interpreter loads and runs `fib.lua`.

The tricky bit is managing all those commandline parameters, as each of these three programs should only see the ones relevant to it.)


(`bx\mm` is M7 compiler, which compiles runs `cc` which is the C compiler, whih compiles the one-file Lua interpreter lua.c into PCL

M7 runs the C compiler via -RUNPCL which then runs say Lua via RUNPCL too.)

### Deployment

Each back-end in the chart is intended to be a self-contained library. It is used as follows:

* M7 and C compilers - the build process makes it part the main compiler (via `import pcl` which adds the two dozen modules needed)
* Q Demo - the PCL library is formed into a separate DLL library
* C Demo - it can either be statically linked (via an OBJ file), or can also use a DLL

Currently the Win64 product includes also the PCL dump routine and the PCL interpreter.

As a DLL, it is single binary of under 200KB, and supports PCL/RUNPCL/EXE/DLL/OBJ/MX/ASM/RUN. (8 different outputs. NASM would be a 9th output, but there can only be one ASM option in a particular build.)

A DLL supporting only RUNPCL (minimal needed to execute PCL code) is about 64KB. Probably this could be reduced as 30KB is the M language's standard library.

### Source Code

Everything is written in my M systems language. Tests are built with the M6 production compiler and run on Windows. M7 is the new compiler.

For use from Q and C languages, suitable interface files are provided (`pcl.q` and `pcl.h`).

The C demo (`cdemo.c`) needs a binary, either `pcl.obj` or `pcl.dll`, but because these are troublesome to distribute, an ASM version `pcl.asm` is provided, in NASM syntax, which can be assembled locally.


### Generating PCL Code

This is done primarily with an API (see for example pcl.q or pcl.h), which provides about 50 functions and a bunch of enumerations for types, opcodes and so on.

That uses the PCL library which as mentioned is either compiled into the front-end, or used as a shared library.

### PCL Types and Opcodes

These are listed and documented here.

### Adding PCL to the C Compiler

C needs to do independent compilation which would limit what this PCL backend could provide. I decided to make a new, more streamlined C compiler which would work only on a single module. This means it can work like a whole-program compiler and can directly generate EXE or DLL files, or run or intepret the programs. (It also makes compilation twice as fast compared with going through intermediate ASM.)

Multi-module C programs can still be built, but via a driver program (a 200-line script), which invokes PCL per-module and with an ASM target (it then invokes my AA assemble-linker on the results).

Some things were challenging. For example the `argn, argv` arguments of `main`, which don't exist under Windows and needs to be emulated. But does happen before PCL or after? I moved that mechanism to after PCL; it takes away that headache from the host.

Another thing was supporting var-args, which in my main implementation, assumes the stack grows downwards. In the PCL interpreter however, it grows upwards!

### Interpreting PCL

This wasn't considered seriously first. Why interpret? PCL as it is is quite unsuitable for interpretation: there too many combinations of operands and types, which need to be sorted at runtime. However I decided to try it anyway. And yes, it was very slow.

But there are some benefits in having a reference implementation that is independent of platform. Debugging becomes easier. Various kinds of survey can be done. If the interpreter at least was ported to another language, that provides one way of getting my M code to run across machines.

There are difficulties however:
* Running interpreted code that calls into external native code requires solving the 'LIBFFI' problem. That has an ugly, awkward solution in that C library. In my language I can solve it trivially, but then porting the code to another language is harder.
* It is not possible to deal with callback functions, where an external function is passed a pointer to a function in your program. Native code can't call a pointer to bytecode!

It does allow very quick development cycles, but that are quick anyway; see below.

Anyway, it's cool.

### Run from Source and JIT

This is possible in two ways:

* Compile to PCL then interpret that (but it is slow, and with the limitations mentioned)
* Compile to PCL then translate to native code then the resulting code in-memory

The latter takes a tiny bit longer, but with typical programs, that is tens of milliseconds. (Eg. sqlite3.c, some 250Kloc, takes 150ms to turn into PCL, but still only 300ms to turn into x64 code. Most projects of mine are smaller.)

So JIT is the usual sense isn't necessary, as whole-program translation from source to native code is more or less instant anyway (depending on the scale of the program of course).

### Targeting Linux x64 and MX Files

This is probably the next challenge. On the face of it it sounds a minor change to the x64 code generator: a different ABI, but a complicated one. (There may also be problems with passing structs by value: the SYS V ABI may need to now the their internal layout, but PCL flattens them into an untyped sequence of bytes.)

Because I do not support Linux binary file formats, I need to generate NASM-format ASM, and use NASM on Linux to produce object files, then use other Linux tools to create an executable.

There are other options, such as the MX file format. That was a binary format I developed for other reasons, but no longer need. However is a simple binary executable format, and it is portable. I could generate that instead (after fixing the code generator to produce SYS V code). However that needs stub program to load and fix up MX files before calling their entry point. That program is a 900-line C programs, which just needs tweaking to with `dlopen/dlsym`.

Yet another might be to use the interpreter, but that has some issues as mentioned.

### Generating 'Linear  C'

This is unlikely to be done, but I have experimented with it and it would probably work. The trouble is that the C generated is terrible with lots of redundant assignments, so that it *needs* an optimising compiler to clean up the mess.

It won't be done because one of the reasons for creating PCL was to avoid having to use intermediate C. (A transpiler of sorts from my M language to still exists, but has fallen into disuse.)


### The PCL Runtime

PCL, when turned into native code, mostly generates inline code. Exceptions include calls to external libraries; for example `a ** b` when `a, b` are floats will generate a call to C's `pow` function.

However some code doesn't use an external library, but is too sprawling to generate inline. For example, `a ** b` when `a, b` are integers, uses a routine called `m$power_i64`. Others can include supporting bitfield operations. But where is that code located? Who supplies it, the front-end compiler?

A much older project used textual IL, and such code was generated by some one-time means then appended to the IL produced by the host. Here there is no textual form. I don't want to have a dependency such as another DLL which then has to accompany applications.

I don't have a solution yet. For the M7 compiler, there is a workaround: `m$power_i64` is part of the M7 compiler's runtime. Programs compiled with M7 will use the same system library, so the PCL code for `m$power_i64` exists. The PCL->native backend can call into the host to ask if it to supply a reference to that code which is going to be part of the application anyway.

In the case of the C compiler, there is no built-in `pow` operator for integers, so it doesn't arise. 

But the problem needs to be solved for when there is more demand for runtime routines.


### Backend Optimisations

The M6 compiler does two kinds of enhancements to generated code:

* Some locals and parameters can sometimes be kept in registers
* There is a small peephole optimiser that works on generated x64 code

Neither really make application much faster. Using locals in register can sometimes give impressive results with benchmarks, or where a M-language routine is called from my scripting language. 

Mainly they just make the code smaller. As it is, the very impressive throughputs of all my language tools are achieved with pretty much unoptimised.

PCL's x64 backend doesn't yet have even the above enhancements. So neither M7 nor the new C compiler have them (so code generated by them is a little bit larger too).

They will be added in due course. Generated PCL code can be tided up too. Some is up to the host compiler. There are some reductions that can be done by the PCL API functions (for example combining sequences involving `addpx iloadx istorex).

At the moment however all that as low priority.

### Inline Assembly

This is not directlyh supported by PCL at all. With a version involving discrete IL files, it wouldn't be possible at all.

Yet the M7 compiler supports inline assembler. It generates `assem` PCL opcodes, which have a opaque reference to an AST structure in the host which contains more details.

When an `assem` opcodes need to be translated to x64 code, it calls back into the host to deal with it. So there is an untidy leakage of symbols between the host on one side of PCL, and the backend on the other. But it works.



